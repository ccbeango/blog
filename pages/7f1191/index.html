<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ReactHooks的使用 | CcbeanBlog</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/blog/img/favicon.ico">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <meta name="description" content="web技术博客,简洁至上。JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,NodeJS,Node,Node.js,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,react,css3,html5,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/blog/assets/css/0.styles.76d42078.css" as="style"><link rel="preload" href="/blog/assets/js/app.0ed7b280.js" as="script"><link rel="preload" href="/blog/assets/js/2.7308dfd9.js" as="script"><link rel="preload" href="/blog/assets/js/98.5b594a5f.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.166b2ca6.js"><link rel="prefetch" href="/blog/assets/js/100.194e839b.js"><link rel="prefetch" href="/blog/assets/js/101.0db39944.js"><link rel="prefetch" href="/blog/assets/js/102.e13c8470.js"><link rel="prefetch" href="/blog/assets/js/103.0ae2f2ee.js"><link rel="prefetch" href="/blog/assets/js/104.a261556e.js"><link rel="prefetch" href="/blog/assets/js/105.4d458a5f.js"><link rel="prefetch" href="/blog/assets/js/106.6d2f15cf.js"><link rel="prefetch" href="/blog/assets/js/107.a770982a.js"><link rel="prefetch" href="/blog/assets/js/108.0be9ce8f.js"><link rel="prefetch" href="/blog/assets/js/109.88d01e84.js"><link rel="prefetch" href="/blog/assets/js/11.faae5f41.js"><link rel="prefetch" href="/blog/assets/js/110.d3186629.js"><link rel="prefetch" href="/blog/assets/js/111.37d2b500.js"><link rel="prefetch" href="/blog/assets/js/112.d94648de.js"><link rel="prefetch" href="/blog/assets/js/113.a7cf5597.js"><link rel="prefetch" href="/blog/assets/js/114.a339354f.js"><link rel="prefetch" href="/blog/assets/js/115.597976cc.js"><link rel="prefetch" href="/blog/assets/js/116.c64f1f49.js"><link rel="prefetch" href="/blog/assets/js/117.bbbbb20b.js"><link rel="prefetch" href="/blog/assets/js/118.c9ba24ea.js"><link rel="prefetch" href="/blog/assets/js/119.25208df7.js"><link rel="prefetch" href="/blog/assets/js/12.782cd676.js"><link rel="prefetch" href="/blog/assets/js/120.2e0a20ad.js"><link rel="prefetch" href="/blog/assets/js/121.7bb8f6f5.js"><link rel="prefetch" href="/blog/assets/js/122.562fe94b.js"><link rel="prefetch" href="/blog/assets/js/123.9562f569.js"><link rel="prefetch" href="/blog/assets/js/124.fd67828f.js"><link rel="prefetch" href="/blog/assets/js/125.3262b310.js"><link rel="prefetch" href="/blog/assets/js/126.c6f106af.js"><link rel="prefetch" href="/blog/assets/js/127.4b7016d1.js"><link rel="prefetch" href="/blog/assets/js/128.b3ac8038.js"><link rel="prefetch" href="/blog/assets/js/129.3ef9af3d.js"><link rel="prefetch" href="/blog/assets/js/13.508b65ad.js"><link rel="prefetch" href="/blog/assets/js/130.4b925feb.js"><link rel="prefetch" href="/blog/assets/js/131.37cb5d18.js"><link rel="prefetch" href="/blog/assets/js/132.76026f1f.js"><link rel="prefetch" href="/blog/assets/js/133.5d3d2938.js"><link rel="prefetch" href="/blog/assets/js/134.89b4fe3b.js"><link rel="prefetch" href="/blog/assets/js/135.dd2731dc.js"><link rel="prefetch" href="/blog/assets/js/136.e5cacc53.js"><link rel="prefetch" href="/blog/assets/js/137.39282e0b.js"><link rel="prefetch" href="/blog/assets/js/138.b3801697.js"><link rel="prefetch" href="/blog/assets/js/14.88ac5afd.js"><link rel="prefetch" href="/blog/assets/js/15.b4227c88.js"><link rel="prefetch" href="/blog/assets/js/16.98d2ae02.js"><link rel="prefetch" href="/blog/assets/js/17.6f25717f.js"><link rel="prefetch" href="/blog/assets/js/18.ae934359.js"><link rel="prefetch" href="/blog/assets/js/19.ffe2dcb2.js"><link rel="prefetch" href="/blog/assets/js/20.2c614eab.js"><link rel="prefetch" href="/blog/assets/js/21.4b7f3180.js"><link rel="prefetch" href="/blog/assets/js/22.03f8def7.js"><link rel="prefetch" href="/blog/assets/js/23.861aebfe.js"><link rel="prefetch" href="/blog/assets/js/24.e842cb60.js"><link rel="prefetch" href="/blog/assets/js/25.5685dfd1.js"><link rel="prefetch" href="/blog/assets/js/26.9487cf2a.js"><link rel="prefetch" href="/blog/assets/js/27.cd3b98f4.js"><link rel="prefetch" href="/blog/assets/js/28.1010db9b.js"><link rel="prefetch" href="/blog/assets/js/29.cff77b90.js"><link rel="prefetch" href="/blog/assets/js/3.b0a270e2.js"><link rel="prefetch" href="/blog/assets/js/30.d9d88b77.js"><link rel="prefetch" href="/blog/assets/js/31.4c816fae.js"><link rel="prefetch" href="/blog/assets/js/32.c414f2c2.js"><link rel="prefetch" href="/blog/assets/js/33.cae1fde7.js"><link rel="prefetch" href="/blog/assets/js/34.c149f32c.js"><link rel="prefetch" href="/blog/assets/js/35.36ce97e5.js"><link rel="prefetch" href="/blog/assets/js/36.b7c514b6.js"><link rel="prefetch" href="/blog/assets/js/37.d9459ed5.js"><link rel="prefetch" href="/blog/assets/js/38.84d4e80e.js"><link rel="prefetch" href="/blog/assets/js/39.21769d8b.js"><link rel="prefetch" href="/blog/assets/js/4.1de495bd.js"><link rel="prefetch" href="/blog/assets/js/40.ba8b2c33.js"><link rel="prefetch" href="/blog/assets/js/41.dbc723df.js"><link rel="prefetch" href="/blog/assets/js/42.6d7ee2ec.js"><link rel="prefetch" href="/blog/assets/js/43.3065c2de.js"><link rel="prefetch" href="/blog/assets/js/44.95652c6b.js"><link rel="prefetch" href="/blog/assets/js/45.1bfb7eee.js"><link rel="prefetch" href="/blog/assets/js/46.21f42bfd.js"><link rel="prefetch" href="/blog/assets/js/47.5cf0a7f8.js"><link rel="prefetch" href="/blog/assets/js/48.80e7bcba.js"><link rel="prefetch" href="/blog/assets/js/49.75bf925a.js"><link rel="prefetch" href="/blog/assets/js/5.7e93193d.js"><link rel="prefetch" href="/blog/assets/js/50.1a08250f.js"><link rel="prefetch" href="/blog/assets/js/51.63d67d9a.js"><link rel="prefetch" href="/blog/assets/js/52.4527b3c2.js"><link rel="prefetch" href="/blog/assets/js/53.928eb7b1.js"><link rel="prefetch" href="/blog/assets/js/54.b2c8392c.js"><link rel="prefetch" href="/blog/assets/js/55.84f7c241.js"><link rel="prefetch" href="/blog/assets/js/56.6773809d.js"><link rel="prefetch" href="/blog/assets/js/57.aed02421.js"><link rel="prefetch" href="/blog/assets/js/58.16532c6b.js"><link rel="prefetch" href="/blog/assets/js/59.43238c8c.js"><link rel="prefetch" href="/blog/assets/js/6.d42d0f48.js"><link rel="prefetch" href="/blog/assets/js/60.d868f9ec.js"><link rel="prefetch" href="/blog/assets/js/61.8bc02b72.js"><link rel="prefetch" href="/blog/assets/js/62.83e6c8d0.js"><link rel="prefetch" href="/blog/assets/js/63.ade81187.js"><link rel="prefetch" href="/blog/assets/js/64.cc73a529.js"><link rel="prefetch" href="/blog/assets/js/65.d002206a.js"><link rel="prefetch" href="/blog/assets/js/66.f0665b6d.js"><link rel="prefetch" href="/blog/assets/js/67.11c613ec.js"><link rel="prefetch" href="/blog/assets/js/68.8e2479dd.js"><link rel="prefetch" href="/blog/assets/js/69.02772367.js"><link rel="prefetch" href="/blog/assets/js/7.2b3bcb3f.js"><link rel="prefetch" href="/blog/assets/js/70.3545ebb5.js"><link rel="prefetch" href="/blog/assets/js/71.b7c76516.js"><link rel="prefetch" href="/blog/assets/js/72.035b6ee2.js"><link rel="prefetch" href="/blog/assets/js/73.9feda52a.js"><link rel="prefetch" href="/blog/assets/js/74.d62cf235.js"><link rel="prefetch" href="/blog/assets/js/75.db2ada7c.js"><link rel="prefetch" href="/blog/assets/js/76.8569647d.js"><link rel="prefetch" href="/blog/assets/js/77.ebb5e006.js"><link rel="prefetch" href="/blog/assets/js/78.463a3566.js"><link rel="prefetch" href="/blog/assets/js/79.25bf57ea.js"><link rel="prefetch" href="/blog/assets/js/8.3cf902c7.js"><link rel="prefetch" href="/blog/assets/js/80.4d3043a3.js"><link rel="prefetch" href="/blog/assets/js/81.e6ac7aff.js"><link rel="prefetch" href="/blog/assets/js/82.39390874.js"><link rel="prefetch" href="/blog/assets/js/83.52a99a2b.js"><link rel="prefetch" href="/blog/assets/js/84.4efad80d.js"><link rel="prefetch" href="/blog/assets/js/85.dce1dc90.js"><link rel="prefetch" href="/blog/assets/js/86.3050d700.js"><link rel="prefetch" href="/blog/assets/js/87.67d7c4e3.js"><link rel="prefetch" href="/blog/assets/js/88.4a3a4132.js"><link rel="prefetch" href="/blog/assets/js/89.861690de.js"><link rel="prefetch" href="/blog/assets/js/9.f2b8862e.js"><link rel="prefetch" href="/blog/assets/js/90.f1cdccba.js"><link rel="prefetch" href="/blog/assets/js/91.3abb6471.js"><link rel="prefetch" href="/blog/assets/js/92.66e441c7.js"><link rel="prefetch" href="/blog/assets/js/93.3ae60e73.js"><link rel="prefetch" href="/blog/assets/js/94.b6f4569f.js"><link rel="prefetch" href="/blog/assets/js/95.81abfad5.js"><link rel="prefetch" href="/blog/assets/js/96.eaafaf11.js"><link rel="prefetch" href="/blog/assets/js/97.f464844d.js"><link rel="prefetch" href="/blog/assets/js/99.8a12c6d2.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.76d42078.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/EB-logo.png" alt="CcbeanBlog" class="logo"> <span class="site-name can-hide">CcbeanBlog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/blog/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/4f29ea/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/blog/pages/5bb2dc/" class="nav-link">HTML+CSS</a></li><li class="dropdown-subitem"><a href="/blog/pages/d0b9bd/" class="nav-link">Vue</a></li><li class="dropdown-subitem"><a href="/blog/pages/ff6413/" class="nav-link">React</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/react-learn/" class="nav-link">React使用学习</a></li><li class="dropdown-subitem"><a href="/blog/note/vue2-code/" class="nav-link">Vue2源码探究</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Node" class="dropdown-title"><a href="/blog/nodejs/" class="link-title">Node</a> <span class="title" style="display:none;">Node</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Node文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/1cce55/" class="nav-link">基础</a></li><li class="dropdown-subitem"><a href="/blog/pages/be0ea7/" class="nav-link">问题</a></li><li class="dropdown-subitem"><a href="/blog/pages/6e080e/" class="nav-link">框架</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/data-structures-and-algorithms/" class="nav-link">数据结构与算法</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="打包工具" class="dropdown-title"><a href="/blog/packtool/" class="link-title">打包工具</a> <span class="title" style="display:none;">打包工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>构建工具文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/a542bb/" class="nav-link">webpack</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/webpack5/" class="nav-link">Webpack5使用学习</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/blog/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/3bd9c5/" class="nav-link">MySQL</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/4db4cb/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9f95d1/" class="nav-link">网络</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/c44d61/" class="nav-link">小技巧</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9c8278/" class="nav-link">杂记</a></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/protocol-buffers/" class="nav-link">Protobuf Buffers</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blog/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/blog/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/blog/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/blog/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/ccbeango/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://avatars.githubusercontent.com/u/16501284?v=4"> <div class="blogger-info"><h3>Ccbean</h3> <span>靡不有初，鲜克有终</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/blog/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/4f29ea/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/blog/pages/5bb2dc/" class="nav-link">HTML+CSS</a></li><li class="dropdown-subitem"><a href="/blog/pages/d0b9bd/" class="nav-link">Vue</a></li><li class="dropdown-subitem"><a href="/blog/pages/ff6413/" class="nav-link">React</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/react-learn/" class="nav-link">React使用学习</a></li><li class="dropdown-subitem"><a href="/blog/note/vue2-code/" class="nav-link">Vue2源码探究</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Node" class="dropdown-title"><a href="/blog/nodejs/" class="link-title">Node</a> <span class="title" style="display:none;">Node</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Node文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/1cce55/" class="nav-link">基础</a></li><li class="dropdown-subitem"><a href="/blog/pages/be0ea7/" class="nav-link">问题</a></li><li class="dropdown-subitem"><a href="/blog/pages/6e080e/" class="nav-link">框架</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/data-structures-and-algorithms/" class="nav-link">数据结构与算法</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="打包工具" class="dropdown-title"><a href="/blog/packtool/" class="link-title">打包工具</a> <span class="title" style="display:none;">打包工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>构建工具文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/a542bb/" class="nav-link">webpack</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/webpack5/" class="nav-link">Webpack5使用学习</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/blog/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/3bd9c5/" class="nav-link">MySQL</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/4db4cb/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9f95d1/" class="nav-link">网络</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/c44d61/" class="nav-link">小技巧</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9c8278/" class="nav-link">杂记</a></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/protocol-buffers/" class="nav-link">Protobuf Buffers</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blog/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/blog/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/blog/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/blog/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/ccbeango/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/blog/pages/3f937c/" class="sidebar-link">Hello World</a></li><li><a href="/blog/pages/65114a/" class="sidebar-link">JSX语法</a></li><li><a href="/blog/pages/919785/" class="sidebar-link">JSX语法的本质</a></li><li><a href="/blog/pages/c5633c/" class="sidebar-link">脚手架</a></li><li><a href="/blog/pages/bd5f26/" class="sidebar-link">什么是组件化开发</a></li><li><a href="/blog/pages/f34018/" class="sidebar-link">组件化开发</a></li><li><a href="/blog/pages/3b1483/" class="sidebar-link">setState详解和React性能优化</a></li><li><a href="/blog/pages/77cea2/" class="sidebar-link">受控和非受控组件</a></li><li><a href="/blog/pages/ad645b/" class="sidebar-link">高阶组件</a></li><li><a href="/blog/pages/809a87/" class="sidebar-link">React的样式</a></li><li><a href="/blog/pages/ce6916/" class="sidebar-link">React的过渡动画</a></li><li><a href="/blog/pages/7f1191/" aria-current="page" class="active sidebar-link">ReactHooks的使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/blog/pages/7f1191/#认识hook" class="sidebar-link">认识hook</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#为什么需要hook" class="sidebar-link">为什么需要hook</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#hooks的基本演练" class="sidebar-link">hooks的基本演练</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/7f1191/#hooks基础" class="sidebar-link">hooks基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#state-hook" class="sidebar-link">State Hook</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#effect-hook" class="sidebar-link">Effect Hook</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/7f1191/#effect基本使用" class="sidebar-link">Effect基本使用</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/7f1191/#需要清除effect" class="sidebar-link">需要清除Effect</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/7f1191/#使用多个effect" class="sidebar-link">使用多个Effect</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/7f1191/#effect性能优化" class="sidebar-link">Effect性能优化</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#context-hook" class="sidebar-link">Context Hook</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#usereducer" class="sidebar-link">useReducer</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#usecallback" class="sidebar-link">useCallback</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#usememo" class="sidebar-link">useMemo</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#useref" class="sidebar-link">useRef</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#useimperativehandle" class="sidebar-link">useImperativeHandle</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#uselayouteffect" class="sidebar-link">useLayoutEffect</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/7f1191/#自定义hook" class="sidebar-link">自定义Hook</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#认识自定义hook" class="sidebar-link">认识自定义hook</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#自定义hook练习" class="sidebar-link">自定义Hook练习</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/7f1191/#redux-hooks" class="sidebar-link">Redux Hooks</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#_4-1-useselector使用" class="sidebar-link">4.1. useSelector使用</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/7f1191/#_4-2-usedispatch" class="sidebar-link">4.2. useDispatch</a></li></ul></li></ul></li><li><a href="/blog/pages/18ce7b/" class="sidebar-link">Redux的使用</a></li><li><a href="/blog/pages/d3c53b/" class="sidebar-link">React-Redux</a></li><li><a href="/blog/pages/facc20/" class="sidebar-link">Redux中间件和state管理</a></li><li><a href="/blog/pages/f60ca3/" class="sidebar-link">React-router</a></li><li><a href="/blog/pages/96924f/" class="sidebar-link">React打包发布</a></li><li><a href="/blog/pages/1b0384/" class="sidebar-link">React SSR</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/blog/note/react-learn/#React核心技术与开发实战" data-v-06225672>React核心技术与开发实战</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/ccbeango" target="_blank" title="作者" class="beLink" data-v-06225672>ccbean</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2021-06-30</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">ReactHooks的使用<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="react学习-十二-reacthooks的使用"><a href="#react学习-十二-reacthooks的使用" class="header-anchor">#</a> React学习（十二）——ReactHooks的使用</h1> <h2 id="认识hook"><a href="#认识hook" class="header-anchor">#</a> 认识hook</h2> <h3 id="为什么需要hook"><a href="#为什么需要hook" class="header-anchor">#</a> 为什么需要hook</h3> <p><em>Hook</em> 是 React 16.8 的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。</p> <p>我们先来思考一下<code>class组件</code>相对于<code>函数式组件</code>有什么优势？比较常见的是下面的优势：</p> <ul><li><p>class组件可以定义自己的state，用来保存组件自己内部的状态；</p></li> <li><ul><li>函数式组件不可以，因为函数每次调用都会产生新的临时变量；</li></ul></li> <li><p>class组件有自己的生命周期，我们可以在对应的生命周期中完成自己的逻辑；</p></li> <li><ul><li>比如在<code>componentDidMount</code>中发送网络请求，并且该生命周期函数只会执行一次；</li> <li>函数式组件在学习hooks之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求；</li></ul></li> <li><p>class组件可以在状态改变时只会重新执行render函数以及我们希望重新调用的生命周期函数componentDidUpdate等；</p></li> <li><ul><li>函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次；</li></ul></li></ul> <p>所以，在Hook出现之前，对于上面这些情况我们通常都会编写class组件。</p> <p><strong>但是class组件依然存在很多的问题：</strong></p> <p><strong>复杂组件变得难以理解：</strong></p> <ul><li>我们在最初编写一个class组件时，往往逻辑比较简单，并不会非常复杂。</li> <li>但是随着业务的增多，我们的class组件会变得越来越复杂；</li> <li>比如componentDidMount中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在componentWillUnmount中移除）；</li> <li>而对于这样的class实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度；</li></ul> <p><strong>难以理解的class：</strong></p> <ul><li>很多人发现学习ES6的class是学习React的一个障碍。</li> <li>比如在class中，我们必须搞清楚this的指向到底是谁，所以需要花很多的精力去学习this；</li> <li>虽然我认为前端开发人员必须掌握this，但是依然处理起来非常麻烦；</li></ul> <p><strong>组件复用状态很难</strong>：</p> <ul><li>在前面为了一些状态的复用我们需要通过高阶组件或render props；</li> <li>像我们之前学习的redux中connect或者react-router中的withRouter，这些高阶组件设计的目的就是为了状态的复用；</li> <li>或者类似于Provider、Consumer来共享一些状态，但是多次使用Consumer时，我们的代码就会存在很多嵌套；</li> <li>这些代码让我们不管是编写和设计上来说，都变得非常困难；</li></ul> <p>Hook的出现，可以解决上面提到的这些问题；</p> <p><strong>简单总结一下hooks：</strong></p> <ul><li><strong>它可以让我们在不编写class的情况下使用state以及其他的React特性</strong>；</li> <li>但是我们可以由此延伸出非常多的用法，来让我们前面所提到的问题得到解决；</li></ul> <p>Hook的使用场景：</p> <ul><li>Hook的出现基本可以代替我们之前所有使用class组件的地方（除了一些非常不常用的场景）；</li> <li>但是如果是一个旧的项目，你并不需要直接将所有的代码重构为Hooks，因为它完全向下兼容，你可以渐进式的来使用它；</li> <li>Hook只能在函数组件中使用，不能在类组件，或者函数组件之外的地方使用；</li></ul> <p>函数式组件结合<code>hooks</code>让整个代码变得非常简洁，并且再也不
用考虑<code>this</code>相关的问题；</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages/React/React%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B530.png" alt="image-20210630102618030"></p> <h3 id="hooks的基本演练"><a href="#hooks的基本演练" class="header-anchor">#</a> hooks的基本演练</h3> <p>我们通过一个计数器案例，来对比一下class组件和函数式组件结合hooks的对比：</p> <p>class组件实现：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { PureComponent } from 'react'

export default class App extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      counter: 0
    };
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h2&gt;当前计数 {this.state.counter}&lt;/h2&gt;
        &lt;button onClick={e =&gt; this.increment()}&gt;+1&lt;/button&gt;
        &lt;button onClick={e =&gt; this.decrement()}&gt;-1&lt;/button&gt;
      &lt;/div&gt;
    )
  }

  increment() {
    this.setState({ counter: this.state.counter + 1 });
  }

  decrement() {
    this.setState({ counter: this.state.counter - 1 });
  }
}
</code></pre></div><p>函数式组件实现：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useState } from 'react'

export default function App() {
  const [ counter, setCounter ] = useState(0);

  return (
    &lt;div&gt;
      &lt;h2&gt;当前计数 {counter}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCounter(counter + 1)}&gt;+1&lt;/button&gt;
      &lt;button onClick={e =&gt; setCounter(counter - 1)}&gt;-1&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>会发现上面的代码差异非常大：函数式组件结合hooks让整个代码变得非常简洁，并且再也不用考虑this相关的问题；</p> <p>那么我们来研究一下核心的一段代码代表什么意思：</p> <ul><li><p>useState来自react，需要从react中导入，它是一个hook；</p></li> <li><ul><li>元素一：当前状态的值（第一调用为初始化值）；</li> <li>元素二：设置状态值的函数；</li> <li>参数：初始化值，如果不设置为undefined；</li> <li>返回值：数组，包含两个元素；</li></ul></li> <li><p>点击button按钮后，会完成两件事情：</p></li> <li><ul><li>调用setCount，设置一个新的值；</li> <li>组件重新渲染，并且根据新的值返回DOM结构；</li></ul></li> <li><p>React在重新渲染时，会保留这个state状态，并不会每次都使用初始化值；</p></li></ul> <p>Hook 就是 JavaScript 函数，这个函数可以帮助你 <code>钩入（hook into）</code> React State以及生命周期等特性；</p> <p>但是使用它们会有两个额外的规则：</p> <ul><li>只能在<strong>函数最外层</strong>调用 Hook。不要在循环、条件判断或者子函数中调用。</li> <li>只能在 <strong>React 的函数组件</strong>中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中）。</li></ul> <p>Tip：Hook指的类似于useState、useEffect这样的函数，Hooks是对这类函数的统称；</p> <h2 id="hooks基础"><a href="#hooks基础" class="header-anchor">#</a> hooks基础</h2> <h3 id="state-hook"><a href="#state-hook" class="header-anchor">#</a> State Hook</h3> <p>State Hook的API就是 <code>useState</code>，我们在前面已经进行了学习：</p> <ul><li>**<code>useState</code>**会帮助我们定义一个 <code>state变量</code>，<code>useState</code> 是一种新方法，它与 class 里面的 <code>this.state</code> 提供的功能完全相同。一般来说，在函数退出后变量就会”消失”，而 state 中的变量会被 React 保留。</li> <li>**<code>useState</code>**接受唯一一个参数，在第一次组件被调用时使用来作为初始化值。（如果没有传递参数，那么初始化值为undefined）。</li> <li>**<code>useState</code>**是一个数组，我们可以通过数组的解构，来完成赋值会非常方便。</li></ul> <p>FAQ：为什么叫 <code>useState</code> 而不叫 <code>createState</code>?</p> <ul><li>“Create” 可能不是很准确，因为 state 只在组件首次渲染的时候被创建。</li> <li>在下一次重新渲染时，<code>useState</code> 返回给我们当前的 state。</li> <li>如果每次都创建新的变量，它就不是 “state”了。</li> <li>这也是 Hook 的名字总是以 <code>use</code> 开头的一个原因。</li></ul> <p>当然，我们也可以在一个组件中定义多个变量和复杂变量（数组、对象）：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useState } from 'react'

export default function App() {
  const [count, setCount] = useState(0);
  const [age, setAge] = useState(18);
  const [friends, setFriends] = useState(['tom', 'jack'])
  const [students, setStudents] = useState([
    { id: 1, name: 'ccbean', score: 96 },
    { id: 1, name: 'jack', score: 99 },
    { id: 1, name: 'tom', score: 97 }
  ])

  function addFriend() {
    friends.push('lily');
    setFriends(friends);
  }

  function setStudentAgeWithIndex(index) {
    const newStudents = [...students];
    newStudents[index].score += 1;

    setStudents(newStudents);
  }


  return (
    &lt;div&gt;
      &lt;h2&gt;当前计数：{count}&lt;/h2&gt;
      &lt;h2&gt;我的年龄：{age}&lt;/h2&gt;
      &lt;h2&gt;好友列表&lt;/h2&gt;
      &lt;ul&gt;
        {
          friends.map((item, index) =&gt; (
            &lt;li key={index}&gt;{item}&lt;/li&gt;
          ))
        }
      &lt;/ul&gt;
      &lt;button onClick={e =&gt; setFriends([...friends, 'penny'])}&gt;新增好友&lt;/button&gt;
      {/* 错误方法 */}
      &lt;button onClick={addFriend}&gt;新增好友2&lt;/button&gt;
      &lt;h2&gt;学生列表&lt;/h2&gt;
      {
        students.map((item, index) =&gt; (
          &lt;li key={item.id}&gt;
            学生：{item.name}
            分数：{item.score}
            &lt;button onClick={e =&gt; setStudentAgeWithIndex(index)}&gt;score + 1&lt;/button&gt;
          &lt;/li&gt;
        ))
      }
    &lt;/div&gt;
  )
}
</code></pre></div><p>useState也会出现和class组件中的setState都会发生state合并：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useState } from 'react'

export default function App() {
  const [ counter, setCounter ] = useState(0);

  function increment10() {
    // +40最终只会+10 react会对state进行合并
    // setCounter(counter + 10);
    // setCounter(counter + 10);
    // setCounter(counter + 10);
    // setCounter(counter + 10);

    // 使用函数写法可以实现+40
    setCounter((prevCount) =&gt; prevCount + 10);
    setCounter((prevCount) =&gt; prevCount + 10);
    setCounter((prevCount) =&gt; prevCount + 10);
    setCounter((prevCount) =&gt; prevCount + 10);
  }

  return (
    &lt;div&gt;
      &lt;h2&gt;当前计数 {counter}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCounter(counter + 1)}&gt;+1&lt;/button&gt;
      &lt;button onClick={increment10}&gt;+10&lt;/button&gt;
      &lt;button onClick={e =&gt; setCounter(counter - 1)}&gt;-1&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><h3 id="effect-hook"><a href="#effect-hook" class="header-anchor">#</a> Effect Hook</h3> <p>目前我们已经通过hook在函数式组件中定义state，那么类似于生命周期这些呢？</p> <ul><li>Effect Hook 可以让你来完成一些类似于class中生命周期的功能；</li> <li>事实上，类似于网络请求、手动更新DOM、一些事件的监听，都是React更新DOM的一些副作用（Side Effects）；</li> <li>所以对于完成这些功能的Hook被称之为 Effect Hook；</li></ul> <h4 id="effect基本使用"><a href="#effect基本使用" class="header-anchor">#</a> Effect基本使用</h4> <p>假如我们现在有一个需求：<strong>页面的title总是显示counter的数字</strong></p> <p>使用class组件如何实现呢？</p> <ul><li>我们会发现 <code>document.title</code> 的设置必须在两个生命周期中完成；</li> <li>这是因为React的class组件并没有给我们提供一个统一的生命周期函数，可以让无论是否是第一次渲染都会执行的生命周期函数；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { PureComponent } from 'react'

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = this.state.count;
  }

  componentDidUpdate() {
    document.title = this.state.count;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h2&gt;计数： {this.state.count}&lt;/h2&gt;
        &lt;button onClick={e =&gt; this.increment()}&gt;+1&lt;/button&gt;
      &lt;/div&gt;
    )
  }

  increment() {
    this.setState({
      count: this.state.count + 1
    })
  }
}
</code></pre></div><p>这个时候，我们可以使用useEffect的Hook来完成：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useState, useEffect } from 'react'

export default function App() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    document.title = count;
  });

  return (
    &lt;div&gt;
      &lt;h2&gt;计数： {count}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p><strong>useEffect的解析：</strong></p> <ul><li>通过useEffect的Hook，可以告诉React需要在渲染后执行某些操作；</li> <li>useEffect要求我们传入一个<code>回调函数</code>，在React执行完更新DOM操作之后，就<code>会回调这个函数</code>；</li> <li>默认情况下，无论是第一次渲染之后，还是每次更新之后，都会执行这个 <code>回调函数</code>；</li></ul> <h4 id="需要清除effect"><a href="#需要清除effect" class="header-anchor">#</a> 需要清除Effect</h4> <p>在class组件的编写过程中，某些副作用的代码，我们需要在componentWillUnmount中进行清除：</p> <ul><li>比如我们之前的事件总线或Redux中手动调用subscribe；</li> <li>都需要在componentWillUnmount有对应的取消订阅；</li> <li>Effect Hook通过什么方式来模拟componentWillUnmount呢？</li></ul> <p>useEffect传入的<code>回调函数A本身</code>可以有一个返回值，这个返回值是<code>另外一个回调函数B</code>：</p> <div class="language-react extra-class"><pre class="language-text"><code>type EffectCallback = () =&gt; (void | (() =&gt; void | undefined));
</code></pre></div><p>我们可以这样来编写Effect Hook：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useState, useEffect } from 'react';

export default function EffectHookClear() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    document.title = `当前计数: ${count}`;
    console.log(&quot;每次DOM更新时会回调&quot;);

    return () =&gt; {
      console.log(&quot;DOM被移除时会回调&quot;);
    }
  })

  return (
    &lt;div&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
      &lt;button onClick={e =&gt; setCount(count - 1)}&gt;-1&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p><strong>为什么要在 effect 中返回一个函数？</strong></p> <ul><li>这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数；</li> <li>如此可以将添加和移除订阅的逻辑放在一起；</li> <li>它们都属于 effect 的一部分；</li></ul> <p><strong>React 何时清除 effect？</strong></p> <ul><li>React 会在组件更新和卸载的时候执行清除操作；</li> <li>正如之前学到的，effect 在每次渲染的时候都会执行；</li></ul> <h4 id="使用多个effect"><a href="#使用多个effect" class="header-anchor">#</a> 使用多个Effect</h4> <p>使用Hook的其中一个目的就是解决class中生命周期经常将很多的逻辑放在一起的问题：</p> <ul><li>比如网络请求、事件监听、手动修改DOM，这些往往都会放在componentDidMount中；</li></ul> <p>使用Effect Hook，我们可以将它们分离到不同的useEffect中：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useEffect } from 'react';

export default function MultiUseEffect() {
  useEffect(() =&gt; {
    console.log(&quot;网络请求&quot;);
  });

  useEffect(() =&gt; {
    console.log(&quot;修改DOM&quot;);
  })

  useEffect(() =&gt; {
    console.log(&quot;事件监听&quot;);

    return () =&gt; {
      console.log(&quot;取消监听&quot;);
    }
  })

  return (
    &lt;div&gt;
      &lt;h2&gt;MultiUseEffect&lt;/h2&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p><strong>Hook 允许我们按照代码的用途分离它们，</strong> 而不是像生命周期函数那样：</p> <ul><li>React 将按照 effect 声明的顺序依次调用组件中的<em>每一个</em> effect；</li></ul> <h4 id="effect性能优化"><a href="#effect性能优化" class="header-anchor">#</a> Effect性能优化</h4> <p>默认情况下，useEffect的回调函数会在每次渲染时都重新执行，但是这会导致两个问题：</p> <ul><li>某些代码我们只是希望执行一次即可，类似于componentDidMount和componentWillUnmount中完成的事情；（比如网络请求、订阅和取消订阅）；</li> <li>另外，多次执行也会导致一定的性能问题；</li></ul> <p>我们如何决定useEffect在什么时候应该执行和什么时候不应该执行呢？</p> <ul><li>useEffect实际上有两个参数：</li> <li>参数一：执行的回调函数；</li> <li>参数二：该useEffect在哪些state发生变化时，才重新执行；（受谁的影响）</li></ul> <p>我们来看下面的一个案例：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useState, useEffect } from 'react'

export default function App() {
  const [count, setCount] = useState(0);
  const [isLogin, setIsLogin] = useState(true);
  useEffect(() =&gt; {
    console.log('修改dom');
  }, [count]);

  useEffect(() =&gt; {
    console.log('订阅事件')
  }, []);

  useEffect(() =&gt; {
    console.log('网络请求')
  }, [isLogin]);

  return (
    &lt;div&gt;
      &lt;h2&gt;计数：{count}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
      &lt;h2&gt;{ isLogin ? 'ccbean' : '请登录' }&lt;/h2&gt;
      &lt;button onClick={e =&gt; setIsLogin(!isLogin)}&gt;登录/注销&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>计数器的effect只会在count发生变化时进行调用；网络请求只会在isLogin发生变化时进行调用；</p> <p>如果一个函数我们不希望依赖任何的内容时，也可以传入一个空的数组 []：</p> <ul><li>那么这里的两个回调函数分别对应的就是componentDidMount和componentWillUnmount生命周期函数了；</li></ul> <h3 id="context-hook"><a href="#context-hook" class="header-anchor">#</a> Context Hook</h3> <p>在之前的开发中，我们要在组件中使用共享的Context有两种方式：</p> <ul><li>类组件可以通过 <code>类名.contextType = MyContext</code>方式，在类中获取context；</li> <li>多个Context或者在函数式组件中通过 <code>MyContext.Consumer</code> 方式共享context；</li></ul> <p>但是多个Context共享时的方式会存在大量的嵌套：</p> <ul><li>Context Hook允许我们通过Hook来直接获取某个Context的值；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>const value = useContext(MyContext);
</code></pre></div><p>在App.js中使用Context</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { createContext } from 'react';
import App01 from './01_useContext的使用';

export const UserContext = createContext();
export const ThemeContext = createContext();

export default function App() {
  return (
    &lt;ThemeContext.Provider value={{ color: 'red' }}&gt;
      &lt;UserContext.Provider value={{ name: 'ccbean' }}&gt;
        &lt;App01/&gt;
      &lt;/UserContext.Provider&gt;
    &lt;/ThemeContext.Provider&gt;
  )
}

</code></pre></div><p>在对应的函数式组件中使用Context Hook：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useContext } from 'react'
import { UserContext, ThemeContext } from './index';

export default function App() {
  const user = useContext(UserContext);
  const theme = useContext(ThemeContext);

  return (
    &lt;div&gt;
      &lt;h2&gt;user: {JSON.stringify(user)}&lt;/h2&gt;
      &lt;h2&gt;theme: {JSON.stringify(theme)}&lt;/h2&gt;
    &lt;/div&gt;
  );
}
</code></pre></div><p>注意事项：当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重新渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。</p> <h3 id="usereducer"><a href="#usereducer" class="header-anchor">#</a> useReducer</h3> <p>很多人看到useReducer的第一反应应该是redux的某个替代品，其实并不是。</p> <p>useReducer仅仅是useState的一种替代方案：</p> <ul><li>在某些场景下，如果state的处理逻辑比较复杂，我们可以通过useReducer来对其进行拆分；</li> <li>或者这次修改的state需要依赖之前的state时，也可以使用；</li></ul> <p>单独创建一个reducer/counter.js文件：</p> <div class="language-react extra-class"><pre class="language-text"><code>export function counterReducer(state, action) {
  switch(action.type) {
    case &quot;increment&quot;:
      return {...state, counter: state.counter + 1}
    case &quot;decrement&quot;:
      return {...state, counter: state.counter - 1}
    default:
      return state;
  }
}
</code></pre></div><p>home.js</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useReducer } from 'react'
import { counterReducer } from '../reducer/counter'

export default function Home() {
  const [state, dispatch] = useReducer(counterReducer, {counter: 100});

  return (
    &lt;div&gt;
      &lt;h2&gt;当前计数: {state.counter}&lt;/h2&gt;
      &lt;button onClick={e =&gt; dispatch({type: &quot;increment&quot;})}&gt;+1&lt;/button&gt;
      &lt;button onClick={e =&gt; dispatch({type: &quot;decrement&quot;})}&gt;-1&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>我们来看一下，如果我们创建另外一个profile.js也使用这个reducer函数，是否会进行数据的共享：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useReducer } from 'react'
import { counterReducer } from '../reducer/counter'

export default function Profile() {
  const [state, dispatch] = useReducer(counterReducer, {counter: 0});

  return (
    &lt;div&gt;
      &lt;h2&gt;当前计数: {state.counter}&lt;/h2&gt;
      &lt;button onClick={e =&gt; dispatch({type: &quot;increment&quot;})}&gt;+1&lt;/button&gt;
      &lt;button onClick={e =&gt; dispatch({type: &quot;decrement&quot;})}&gt;-1&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>数据是不会共享的，它们只是使用了相同的counterReducer的函数而已。</p> <p><strong>所以，useReducer只是useState的一种替代品，并不能替代Redux。</strong></p> <h3 id="usecallback"><a href="#usecallback" class="header-anchor">#</a> useCallback</h3> <p>useCallback实际的目的是为了进行性能的优化。</p> <p>如何进行性能的优化呢？</p> <ul><li>useCallback会返回一个函数的 memoized（记忆的） 值；</li> <li>在依赖不变的情况下，多次定义的时候，返回的值是相同的；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>const memoizedCallback = useCallback(
  () =&gt; {
    doSomething(a, b);
  },
  [a, b]
);
</code></pre></div><p>我们来看下面一段很有趣的代码：</p> <ul><li><p>increment1在每次函数组件重新渲染时，会返回相同的值；</p></li> <li><p>increment2每次定义的都是不同的值；</p></li> <li><p>问题：是否increment1会比increment2更加节省性能呢？</p></li> <li><ul><li>事实上，经过一些测试，并没有更加节省内存，因为useCallback中还是会传入一个函数作为参数；</li> <li>increment1和increment2中都有函数的创建过程，创建了相同的函数，所以并不存在increment2每次创建新的函数，而increment1不需要创建新的函数这种性能优化；</li></ul></li> <li><p>那么，为什么说useCallback是为了进行性能优化呢？</p></li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { memo, useState, useCallback } from 'react'

export default function CallbackHookDemo() {
  const [count, setCount] = useState(0);

  const increment1 = useCallback(function increment() {
    setCount(count + 1);
  }, []);

  const increment2 = function() {
    setCount(count + 1);
  }

  return (
    &lt;div&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      &lt;button onClick={increment1}&gt;+1&lt;/button&gt;
      &lt;button onClick={increment2}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>我们来对上面的代码进行改进：</p> <ul><li>在下面的代码中，我们将回调函数传递给了子组件，在子组件中会进行调用；</li> <li>在发生点击时，我们会发现接受increment1的子组件不会重新渲染，但是接受increment2的子组件会重新渲染。因为由于使用useCallback对increment1进行包裹，其只在初次挂载和count发生改变时，才会有所改变，否则返回值是不发生变化的，即increment1返回memoized 版本。</li> <li>所以useCallback最主要用于性能渲染的地方应该是和memo结合起来，决定子组件是否需要重新渲染；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { memo, useState, useCallback } from 'react'

const HYButton = memo((props) =&gt; {
  console.log('HyButton渲染' + props.title)
  return (
    &lt;button onClick={props.increment}&gt;HYButton + 1&lt;/button&gt;
  );
});

export default function CallbackHookDemo() {
  console.log('CallbackHookDemo重新渲染');
  const [count, setCount] = useState(0);
  const [show, setShow] = useState(true);

  const increment1 = useCallback(function increment() {
    setCount(count + 1);
  }, [count]);

  const increment2 = function() {
    setCount(count + 1);
  }

  return (
    &lt;div&gt;
      &lt;button onClick={e =&gt; setShow(!show)}&gt;切换&lt;/button&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      &lt;HYButton title='btn1' increment={increment1} /&gt;
      &lt;HYButton title='btn2' increment={increment2} /&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>通常使用<code>useCallback</code>的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存。所以，<code>useCallback</code>的使用场景是：在一个组件中的函数，传递给子元素进行回调使用时，使用<code>useCallback</code>对函数进行处理，避免子组件不必要的渲染，提升性能。</p> <h3 id="usememo"><a href="#usememo" class="header-anchor">#</a> useMemo</h3> <p>useMemo实际的目的也是为了进行性能的优化。</p> <p>如何进行性能的优化呢？</p> <ul><li>useMemo返回的也是一个 memoized（记忆的） 值；</li> <li>在依赖不变的情况下，多次定义的时候，返回的值是相同的；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);
</code></pre></div><p>我们来看一个案例：</p> <ul><li>无论我们点击了是 <code>+1</code>还是 <code>切换</code> 案例都会重新计算一次；</li> <li>事实上，我们只是希望在count发生变化时重新计算；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { memo, useState, useCallback, useMemo } from 'react'

const calcTotal = (count) =&gt; {
  console.log('计算总数')
  return (1 + count) * count / 2; 
}

export default function CallbackHookDemo() {
  const [count, setCount] = useState(0);
  const [show, setShow] = useState(true);

  // 点击切换也会计算
  const total = calcTotal(count);

  return (
    &lt;div&gt;
      &lt;button onClick={e =&gt; setShow(!show)}&gt;切换&lt;/button&gt;
      &lt;h2&gt;总计: {total}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>这个时候，我们可以使用useMemo来进行性能的优化：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { memo, useState, useCallback, useMemo } from 'react'

const calcTotal = (count) =&gt; {
  console.log('计算总数')
  return (1 + count) * count / 2; 
}

export default function CallbackHookDemo() {
  const [count, setCount] = useState(0);
  const [show, setShow] = useState(true);

  const total = useMemo(() =&gt; {
    return calcTotal(count); 
  }, [count]);


  return (
    &lt;div&gt;
      &lt;button onClick={e =&gt; setShow(!show)}&gt;切换&lt;/button&gt;
      &lt;h2&gt;总计: {total}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>当然，useMemo也可以用于子组件的性能优化：</p> <ul><li>ShowCounter子组件依赖的是一个基本数据类型，所以在比较的时候只要值不变，那么就不会重新渲染；</li> <li>ShowInfo接收的是一个对象，每次都会定义一个新的对象，所以我们需要通过useMemo来对其进行优化；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { memo, useState, useMemo } from 'react'

function calcNum(count) {
  let total = 0;
  for (let i = 0; i &lt; count; i++) {
    total += i;
  }
  console.log(&quot;计算一遍&quot;);
  return total
}

const ShowCounter = memo((props) =&gt; {
  console.log(&quot;重新渲染&quot;);
  return &lt;h1&gt;Counter: {props.total}&lt;/h1&gt;
})

const ShowInfo = memo((props) =&gt; {
  console.log(&quot;ShowInfo重新渲染&quot;);
  return &lt;h2&gt;名字：{props.info.name} 年龄：{props.info.age}&lt;/h2&gt;
})

export default function MemoHookDemo() {
  const [count, setCount] = useState(10);
  const [isLogin, setIsLogin] = useState(true);

  const total = useMemo(() =&gt; {
    return calcNum(count);
  }, [count]);

  // 局部变量 每次点击切换都会渲染 可以使用useState解决
  // const info = { name: 'ccbean', age: 18 };
  // 使用useMemo
  const info = useMemo(() =&gt; {
    return { name: 'ccbean', age: 18 };
  }, [])

  return (
    &lt;div&gt;
      &lt;button onClick={e =&gt; setIsLogin(!isLogin)}&gt;切换&lt;/button&gt;
      &lt;h2&gt;数字和: {total}&lt;/h2&gt;
      &lt;ShowCounter total={total} /&gt;
      &lt;ShowInfo info={info}/&gt;
      &lt;button onClick={e =&gt; setCount(count + 1)}&gt;+1&lt;/button&gt;
      {isLogin &amp;&amp; &lt;h2&gt;Coderwhy&lt;/h2&gt;}
    &lt;/div&gt;
  )
}
</code></pre></div><p><code>useMemo</code>的返回值是值，永远是对返回值来做优化的，返回之可以是基本数据类型、对象类型，也可以是函数类型；<code>useCallback</code>只是针对函数进行优化，它返回的是一个函数。</p> <p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。即相当于<code>useMemo</code>的返回值是函数。</p> <p>我们看具体的例子：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { memo, useState, useCallback, useMemo } from 'react'

const HYButton = memo((props) =&gt; {
  console.log('HyButton渲染' + props.title)
  return (
    &lt;button onClick={props.increment}&gt;HYButton + 1&lt;/button&gt;
  );
});

export default function App() {
  console.log('CallbackHookDemo重新渲染');
  const [count, setCount] = useState(0);
  const [show, setShow] = useState(true);

  const increment1 = useCallback(() =&gt; {
    setCount(count + 1);
  }, [count]);
  // useMemo实现useCallback
  const increment2 = useMemo(() =&gt; {
    return () =&gt; {
      setCount(count + 1);
    }
  }, [count]);

  return (
    &lt;div&gt;
      &lt;button onClick={e =&gt; setShow(!show)}&gt;切换&lt;/button&gt;
      &lt;h2&gt;当前计数: {count}&lt;/h2&gt;
      &lt;HYButton title='btn1' increment={increment1} /&gt;
      &lt;HYButton title='btn2' increment={increment2} /&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p><code>increment1</code>和<code>increment2</code>分别使用useCallback和useMemo实现，可以看到<code>increment2</code>其实就是返回了<code>increment1</code>中的回调函数。</p> <h3 id="useref"><a href="#useref" class="header-anchor">#</a> useRef</h3> <p>useRef返回一个ref对象，返回的ref对象在组件的整个生命周期保持不变。</p> <p>最常用的ref是两种用法：</p> <ul><li>用法一：引入DOM（或者组件，但是需要是class组件）元素；</li> <li>用法二：保存一个数据，这个对象在整个生命周期中可以保存不变；</li></ul> <p>用法一：引用DOM</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useRef, useState } from 'react';

class TestCpn extends React.Component {
  render() {
    return (
      &lt;h2&gt;TestCpn&lt;/h2&gt;
    );
  }
}

function TestCpn2() {
  return (
    &lt;h2&gt;TestCpn2&lt;/h2&gt;
  );
}

export default function App() {
  const [show, setShow] = useState(true);
  const titleRef = useRef();
  const inputRef = useRef();
  const testCpnRef = useRef();
  const testCpnRef2 = useRef(); // 报错

  function changeDOM() {
    titleRef.current.innerHTML = 'Hello React';
    inputRef.current.focus();
    console.log(testCpnRef);
  }

  return (
    &lt;div&gt;
      &lt;button onClick={e =&gt; setShow(!show)}&gt;切换&lt;/button&gt;
      &lt;h2 ref={titleRef}&gt;Hello World&lt;/h2&gt;
      &lt;input ref={inputRef} type=&quot;text&quot; /&gt;
      &lt;TestCpn ref={testCpnRef}/&gt;
      &lt;TestCpn2 ref={testCpnRef2}/&gt;
      &lt;button onClick={changeDOM}&gt;修改DOM&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>用法二：使用ref保存上一次的某一个值</p> <ul><li>useRef可以想象成在ref对象中保存了一个.current的可变盒子；</li> <li>useRef在组件重新渲染时，返回的依然是之前的ref对象，但是current是可以修改的；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useRef, useState } from 'react'

export default function App() {
  const [count, setCount] = useState(0);

  const countRef = useRef(count);

  return (
    &lt;div&gt;
      &lt;h2&gt;useRef中的值：{countRef.current}&lt;/h2&gt;
      &lt;h2&gt;count中的值：{count}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCount(count + 10)}&gt;+10&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>这里可以看到countRef中的值是一直不变的，永远都是初始值<code>0</code>。</p> <p>我们使用useRef实现一个例子，每次点击+10按钮，都会显示上次的值和当前值：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useRef, useState, useEffect } from 'react';

export default function App() {
  const [count, setCount] = useState(0);

  const countRef = useRef(count);

  useEffect(() =&gt; {
    countRef.current = count;
  }, [count]);

  return (
    &lt;div&gt;
      &lt;h2&gt;useRef中的值：{countRef.current}&lt;/h2&gt;
      &lt;h2&gt;count中的值：{count}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCount(count + 10)}&gt;+10&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>上面的代码中，每次+10进行渲染时，count值发生了修改，但因为countRef整个生命周期中useRef中的值保持不变，所以渲染时，count值是最新的，而countRef中的值是没有变化的。渲染完成后，<code>useEffect</code>中副作用修改<code>countRef.current</code>中的值，记录此次渲染时的<code>count</code>值；所以它的记录值正好就是上次的<code>count</code>值。</p> <h3 id="useimperativehandle"><a href="#useimperativehandle" class="header-anchor">#</a> useImperativeHandle</h3> <p>我们先来回顾一下ref和forwardRef结合使用：</p> <ul><li>通过forwardRef可以将ref转发到子组件；</li> <li>子组件拿到父组件中创建的ref，绑定到自己的某一个元素中；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { forwardRef, useRef } from 'react';

const HYInput = forwardRef((props, ref) =&gt; {
  return (
    &lt;input ref={ref} type=&quot;text&quot;/&gt;
  );
})

export default function App() {
  const inputRef = useRef();

  return (
    &lt;div&gt;
      &lt;HYInput ref={inputRef}/&gt;
      &lt;button onClick={e =&gt; inputRef.current.focus()}&gt;聚焦&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>上面的做法本身没有什么问题，但是我们是将子组件的DOM直接暴露给了父组件：</p> <ul><li>直接暴露给父组件带来的问题是某些情况的不可控；</li> <li>父组件可以拿到DOM后进行任意的操作；</li> <li>但是，事实上在上面的案例中，我们只是希望父组件可以操作的focus，其他并不希望它随意操作；</li></ul> <p>通过useImperativeHandle可以只暴露固定的操作：</p> <ul><li>通过useImperativeHandle的Hook，将<code>传入的ref</code>和<code>useImperativeHandle第二个参数返回的对象</code>绑定到了一起；</li> <li>所以在父组件中，使用 <code>inputRef.current</code>时，实际上使用的是useImperativeHandle<code>返回的对象</code>；</li> <li>比如我调用了 <code>focus函数</code>，甚至可以调用 <code>printHello函数</code>；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { forwardRef, useImperativeHandle, useRef } from 'react';

const HYInput = forwardRef((props, ref) =&gt; {
  // 子组件的ref
  const inputRef = useRef();
  // 只对外面使用的ref暴露需要的方法
  useImperativeHandle(ref, () =&gt; ({
    focus: () =&gt; {
      inputRef.current.focus();
    },
    printHello: () =&gt; {
      console.log('hello world')
    }
  }), [ inputRef.current ]);

  return (
    &lt;input ref={inputRef} type=&quot;text&quot;/&gt;
  );
})

export default function App() {
  const inputRef = useRef();

  return (
    &lt;div&gt;
      &lt;HYInput ref={inputRef}/&gt;
      &lt;button onClick={e =&gt; inputRef.current.focus()}&gt;聚焦&lt;/button&gt;
      &lt;button onClick={e =&gt; inputRef.current.printHello()}&gt;Hello World&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><h3 id="uselayouteffect"><a href="#uselayouteffect" class="header-anchor">#</a> useLayoutEffect</h3> <p>useLayoutEffect看起来和useEffect非常的相似，事实上他们也只有一点区别而已：</p> <ul><li>useEffect会在渲染的内容更新到DOM上后执行，不会阻塞DOM的更新；</li> <li>useLayoutEffect会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新；</li></ul> <p>如果我们希望在某些操作发生之后再更新DOM，那么应该将这个操作放到useLayoutEffect。</p> <p>两者的渲染流程如下：</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages/React/React%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B531.png" alt="image-20210701123459020"></p> <p>我们来看下面的一段代码：</p> <ul><li>这段代码在开发中会发生闪烁的现象；</li> <li>因为我们先将count设置为了8，那么DOM会被更新，并且会执行一次useEffect中的回调函数；</li> <li>在useEffect中我们发现count为8，又执行一次setCount操作，那么DOM会再次被更新，并且useEffect又会被执行一次；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useState, useEffect } from 'react'

export default function App() {
  const [count, setCount] = useState(10);
  
  useEffect(() =&gt; {
    if (count === 8) {
      setCount(Math.random());
    }
  });
  
  return (
    &lt;div&gt;
      &lt;h2&gt;数字：{count}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCount(8)}&gt;修改&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>事实上，我们上面的操作的目的是在count被设置为8时，随机另外一个数字：</p> <ul><li>如果我们使用useLayoutEffect，那么会等到useLayoutEffect代码执行完毕后，再进行DOM的更新；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useState, useLayoutEffect } from 'react'

export default function App() {
  const [count, setCount] = useState(10);
  
  useLayoutEffect(() =&gt; {
    if (count === 8) {
      setCount(Math.random());
    }
  });
  
  return (
    &lt;div&gt;
      &lt;h2&gt;数字：{count}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setCount(8)}&gt;修改&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><h2 id="自定义hook"><a href="#自定义hook" class="header-anchor">#</a> 自定义Hook</h2> <h3 id="认识自定义hook"><a href="#认识自定义hook" class="header-anchor">#</a> 认识自定义hook</h3> <p><strong>自定义Hook本质上只是一种函数代码逻辑的抽取，严格意义上来说，它本身并不算React的特性。</strong></p> <p>需求：所有的组件在创建和销毁时都进行打印</p> <ul><li>组件被创建：打印 <code>组件被创建了</code>；</li> <li>组件被销毁：打印 <code>组件被销毁了</code>；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>export default function CustomHookDemo() {
  useEffect(() =&gt; {
    console.log(&quot;组件被创建了&quot;);
    return () =&gt; {
      console.log(&quot;组件被销毁了&quot;);
    }
  }, [])

  return (
    &lt;div&gt;
      &lt;h2&gt;CustomHookDemo&lt;/h2&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>但是这样来做意味着所有的组件都需要有对应的逻辑：</p> <div class="language-react extra-class"><pre class="language-text"><code>function Home(props) {
  useEffect(() =&gt; {
    console.log(&quot;组件被创建了&quot;);
    return () =&gt; {
      console.log(&quot;组件被销毁了&quot;);
    }
  }, [])
  return &lt;h2&gt;Home&lt;/h2&gt;
}

function Profile(props) {
  useEffect(() =&gt; {
    console.log(&quot;组件被创建了&quot;);
    return () =&gt; {
      console.log(&quot;组件被销毁了&quot;);
    }
  }, [])
  return &lt;h2&gt;Profile&lt;/h2&gt;
}
</code></pre></div><p>如何可以对它们的逻辑进行抽取呢？</p> <ul><li>非常简单，函数以特殊的方式命名，以 <code>use</code> 开头即可；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>function useLoggingLife() {
  useEffect(() =&gt; {
    console.log(&quot;组件被创建了&quot;);
    return () =&gt; {
      console.log(&quot;组件被销毁了&quot;);
    }
  }, [])
}
</code></pre></div><p>当然，自定义Hook可以有参数，也可以有返回值：</p> <div class="language-react extra-class"><pre class="language-text"><code>function useLoggingLife(name) {
  useEffect(() =&gt; {
    console.log(`${name}组件被创建了`);
    return () =&gt; {
      console.log(`${name}组件被销毁了`);
    }
  }, [])
}
</code></pre></div><h3 id="自定义hook练习"><a href="#自定义hook练习" class="header-anchor">#</a> 自定义Hook练习</h3> <p>我们通过一些案例来练习一下自定义Hook。</p> <p><strong>使用User、Token的Context</strong></p> <p>比如多个组件都需要使用User和Token的Context：</p> <ul><li>这段代码我们在每次使用user和token时都需要导入对应的Context，并且需要使用两次useContext；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useContext } from 'react'
import { UserContext, TokenContext } from './index'
import useUserToken from './hooks/user-hook'; 

export default function CustomHookContextDemo() {
  const user = useContext(UserContext);
  const token = useContext(TokenContext);

  console.log(user, token);

  const a = useUserToken();
  console.log(a);

  return (
    &lt;div&gt;
      &lt;h2&gt;CustomHookContextDemo&lt;/h2&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>我们可以抽取到一个自定义Hook中：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> UserContext<span class="token punctuation">,</span> TokenContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">useUserToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>UserContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>TokenContext<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>user<span class="token punctuation">,</span> token<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>获取窗口滚动的位置</strong></p> <p>在开发中，某些场景我们可能总是希望获取创建滚动的位置：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useEffect, useState } from 'react'

export default function CustomScrollPositionHook() {

  const [scrollPosition, setScrollPosition] = useState(0);

  useEffect(() =&gt; {
    const handleScroll = () =&gt; {
      setScrollPosition(window.scrollY);
    }
    document.addEventListener(&quot;scroll&quot;, handleScroll);

    return () =&gt; {
      document.removeEventListener(&quot;scroll&quot;, handleScroll);
    }
  }, [])

  return (
    &lt;div style={{padding: &quot;1000px 0&quot;}}&gt;
      &lt;h2 style={{position: &quot;fixed&quot;, top: 0, left: 0}}&gt;CustomScrollPositionHook: {scrollPosition}&lt;/h2&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>但是如果每一个组件都有对应这样的一个逻辑，那么就会存在很多的冗余代码：</p> <div class="language-react extra-class"><pre class="language-text"><code>function useScrollPosition() {
  const [scrollPosition, setScrollPosition] = useState(0);

  useEffect(() =&gt; {
    const handleScroll = () =&gt; {
      setScrollPosition(window.scrollY);
    }
    document.addEventListener(&quot;scroll&quot;, handleScroll);

    return () =&gt; {
      document.removeEventListener(&quot;scroll&quot;, handleScroll);
    }
  }, [])

  return scrollPosition;
}
</code></pre></div><p><strong>数据存储的localStorage</strong></p> <p>在开发中，我们会有一些数据希望通过localStorage进行存储（当然，你可以根据自己的情况选择sessionStorage）</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { useState, useEffect } from 'react'

export default function CustomDataStoreHook() {
  const [name, setName] = useState(() =&gt; {
    return JSON.parse(window.localStorage.getItem(&quot;name&quot;))
  });

  useEffect(() =&gt; {
    window.localStorage.setItem(&quot;name&quot;, JSON.stringify(name));
  }, [name])

  return (
    &lt;div&gt;
      &lt;h2&gt;CustomDataStoreHook: {name}&lt;/h2&gt;
      &lt;button onClick={e =&gt; setName(&quot;coderwhy&quot;)}&gt;设置name&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>如果每一个里面都有这样的逻辑，那么代码就会变得非常冗余：</p> <div class="language-react extra-class"><pre class="language-text"><code>function useLocalStorange(key) {
  const [data, setData] = useState(() =&gt; {
    return JSON.parse(window.localStorage.getItem(key))
  });

  useEffect(() =&gt; {
    window.localStorage.setItem(key, JSON.stringify(data));
  }, [data]);

  return [data, setData];
}
</code></pre></div><h2 id="redux-hooks"><a href="#redux-hooks" class="header-anchor">#</a> Redux Hooks</h2> <p>在之前的redux开发中，为了让组件和redux结合起来，我们使用了react-redux中的connect：</p> <ul><li>但是这种方式必须使用<code>高阶函数</code>结合返回的<code>高阶组件</code>；</li> <li>并且必须编写：<code>mapStateToProps</code>和 <code>mapDispatchToProps</code>映射的函数；</li></ul> <p>在Redux7.1开始，提供了Hook的方式，我们再也不需要编写connect以及对应的映射函数了</p> <h3 id="_4-1-useselector使用"><a href="#_4-1-useselector使用" class="header-anchor">#</a> 4.1. useSelector使用</h3> <p>useSelector的作用是将state映射到组件中：</p> <ul><li>参数一：将state映射到需要的数据中；</li> <li>参数二：可以进行比较来决定是否组件重新渲染；（后续讲解）</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>const result: any = useSelector(selector: Function, equalityFn?: Function)
</code></pre></div><p>现在，我可以改进一下之前的Profile中使用redux的代码：</p> <div class="language-react extra-class"><pre class="language-text"><code>function Profile(props) {
  const {banners, recommends, counter} = useSelector(state =&gt; ({
    banners: state.homeInfo.banners,
    recommends: state.homeInfo.recommends
  }));

  console.log(&quot;Profile重新渲染&quot;);

  return (
    &lt;div&gt;
      &lt;h2&gt;数字: {counter}&lt;/h2&gt;
      &lt;h1&gt;Banners&lt;/h1&gt;
      &lt;ul&gt;
        {
          banners.map((item, index) =&gt; {
            return &lt;li key={item.acm}&gt;{item.title}&lt;/li&gt;
          })
        }
      &lt;/ul&gt;
      &lt;h1&gt;Recommends&lt;/h1&gt;
      &lt;ul&gt;
        {
          recommends.map((item, index) =&gt; {
            return &lt;li key={item.acm}&gt;{item.title}&lt;/li&gt;
          })
        }
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}
</code></pre></div><p>但是这段代码会有一个问题：</p> <ul><li>当前我们的组件并不依赖counter，但是counter发生改变时，依然会引起Profile的重新渲染；</li></ul> <p>原因是什么呢？</p> <ul><li>useSelector默认会比较我们返回的两个对象是否相等；</li> <li>如何比较呢？<code>const refEquality = (a, b) =&gt; a === b</code>；</li> <li>也就是我们必须返回两个完全相等的对象才可以不引起重新渲染；</li></ul> <p>这个时候，我们可以使用react-redux中给我们提供的 shallowEqual：</p> <ul><li>这段代码的作用是避免不必要的重新渲染；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>  const {banners, recommends, counter} = useSelector(state =&gt; ({
    banners: state.homeInfo.banners,
    recommends: state.homeInfo.recommends
  }), shallowEqual);
</code></pre></div><p>当然，你也可以编写自己的比较函数，来决定是否重新渲染。</p> <h3 id="_4-2-usedispatch"><a href="#_4-2-usedispatch" class="header-anchor">#</a> 4.2. useDispatch</h3> <p>useDispatch非常简单，就是直接获取dispatch函数，之后在组件中直接使用即可：</p> <div class="language-react extra-class"><pre class="language-text"><code>const dispatch = useDispatch()
</code></pre></div><p>直接使用dispatch：</p> <div class="language-react extra-class"><pre class="language-text"><code>&lt;button onClick={e =&gt; dispatch(subAction(1))}&gt;-1&lt;/button&gt;
&lt;button onClick={e =&gt; dispatch(subAction(5))}&gt;-5&lt;/button&gt;
</code></pre></div><p>我们还可以通过useStore来获取当前的store对象：</p> <div class="language-react extra-class"><pre class="language-text"><code>const store = useStore()
</code></pre></div><p>在组件中可以使用store：</p> <div class="language-react extra-class"><pre class="language-text"><code>const store = useStore();
console.log(store.getState());
</code></pre></div></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/ccbeango/blog/edit/master/docs/React核心技术与开发实战/12.ReactHooks的使用.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2021/11/10, 12:11:50</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/blog/pages/ce6916/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">React的过渡动画</div></a> <a href="/blog/pages/18ce7b/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Redux的使用</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/pages/ce6916/" class="prev">React的过渡动画</a></span> <span class="next"><a href="/blog/pages/18ce7b/">Redux的使用</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/blog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/blog/pages/78ad41/"><div>
            阅读精通正则表达式总结
            <!----></div></a> <span class="date">09-29</span></dt></dl><dl><dd>02</dd> <dt><a href="/blog/pages/1e1cbc/"><div>
            项目搭建规范的配置
            <!----></div></a> <span class="date">07-15</span></dt></dl><dl><dd>03</dd> <dt><a href="/blog/pages/4c97eb/"><div>
            Vite的使用
            <!----></div></a> <span class="date">07-03</span></dt></dl> <dl><dd></dd> <dt><a href="/blog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="liuyh940@gamil.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/ccbeango" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://space.bilibili.com/316494239" title="Bilibili" target="_blank" class="iconfont icon-bilibili"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2018-2023
    <span>Ccbeango</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.0ed7b280.js" defer></script><script src="/blog/assets/js/2.7308dfd9.js" defer></script><script src="/blog/assets/js/98.5b594a5f.js" defer></script>
  </body>
</html>
