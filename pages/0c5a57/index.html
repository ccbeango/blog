<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构与算法-排序 | CcbeanBlog</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/blog/img/favicon.ico">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <meta name="description" content="web技术博客,简洁至上。JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,NodeJS,Node,Node.js,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,react,css3,html5,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/blog/assets/css/0.styles.76d42078.css" as="style"><link rel="preload" href="/blog/assets/js/app.0ed7b280.js" as="script"><link rel="preload" href="/blog/assets/js/2.7308dfd9.js" as="script"><link rel="preload" href="/blog/assets/js/83.52a99a2b.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.166b2ca6.js"><link rel="prefetch" href="/blog/assets/js/100.194e839b.js"><link rel="prefetch" href="/blog/assets/js/101.0db39944.js"><link rel="prefetch" href="/blog/assets/js/102.e13c8470.js"><link rel="prefetch" href="/blog/assets/js/103.0ae2f2ee.js"><link rel="prefetch" href="/blog/assets/js/104.a261556e.js"><link rel="prefetch" href="/blog/assets/js/105.4d458a5f.js"><link rel="prefetch" href="/blog/assets/js/106.6d2f15cf.js"><link rel="prefetch" href="/blog/assets/js/107.a770982a.js"><link rel="prefetch" href="/blog/assets/js/108.0be9ce8f.js"><link rel="prefetch" href="/blog/assets/js/109.88d01e84.js"><link rel="prefetch" href="/blog/assets/js/11.faae5f41.js"><link rel="prefetch" href="/blog/assets/js/110.d3186629.js"><link rel="prefetch" href="/blog/assets/js/111.37d2b500.js"><link rel="prefetch" href="/blog/assets/js/112.d94648de.js"><link rel="prefetch" href="/blog/assets/js/113.a7cf5597.js"><link rel="prefetch" href="/blog/assets/js/114.a339354f.js"><link rel="prefetch" href="/blog/assets/js/115.597976cc.js"><link rel="prefetch" href="/blog/assets/js/116.c64f1f49.js"><link rel="prefetch" href="/blog/assets/js/117.bbbbb20b.js"><link rel="prefetch" href="/blog/assets/js/118.c9ba24ea.js"><link rel="prefetch" href="/blog/assets/js/119.25208df7.js"><link rel="prefetch" href="/blog/assets/js/12.782cd676.js"><link rel="prefetch" href="/blog/assets/js/120.2e0a20ad.js"><link rel="prefetch" href="/blog/assets/js/121.7bb8f6f5.js"><link rel="prefetch" href="/blog/assets/js/122.562fe94b.js"><link rel="prefetch" href="/blog/assets/js/123.9562f569.js"><link rel="prefetch" href="/blog/assets/js/124.fd67828f.js"><link rel="prefetch" href="/blog/assets/js/125.3262b310.js"><link rel="prefetch" href="/blog/assets/js/126.c6f106af.js"><link rel="prefetch" href="/blog/assets/js/127.4b7016d1.js"><link rel="prefetch" href="/blog/assets/js/128.b3ac8038.js"><link rel="prefetch" href="/blog/assets/js/129.3ef9af3d.js"><link rel="prefetch" href="/blog/assets/js/13.508b65ad.js"><link rel="prefetch" href="/blog/assets/js/130.4b925feb.js"><link rel="prefetch" href="/blog/assets/js/131.37cb5d18.js"><link rel="prefetch" href="/blog/assets/js/132.76026f1f.js"><link rel="prefetch" href="/blog/assets/js/133.5d3d2938.js"><link rel="prefetch" href="/blog/assets/js/134.89b4fe3b.js"><link rel="prefetch" href="/blog/assets/js/135.dd2731dc.js"><link rel="prefetch" href="/blog/assets/js/136.e5cacc53.js"><link rel="prefetch" href="/blog/assets/js/137.39282e0b.js"><link rel="prefetch" href="/blog/assets/js/138.b3801697.js"><link rel="prefetch" href="/blog/assets/js/14.88ac5afd.js"><link rel="prefetch" href="/blog/assets/js/15.b4227c88.js"><link rel="prefetch" href="/blog/assets/js/16.98d2ae02.js"><link rel="prefetch" href="/blog/assets/js/17.6f25717f.js"><link rel="prefetch" href="/blog/assets/js/18.ae934359.js"><link rel="prefetch" href="/blog/assets/js/19.ffe2dcb2.js"><link rel="prefetch" href="/blog/assets/js/20.2c614eab.js"><link rel="prefetch" href="/blog/assets/js/21.4b7f3180.js"><link rel="prefetch" href="/blog/assets/js/22.03f8def7.js"><link rel="prefetch" href="/blog/assets/js/23.861aebfe.js"><link rel="prefetch" href="/blog/assets/js/24.e842cb60.js"><link rel="prefetch" href="/blog/assets/js/25.5685dfd1.js"><link rel="prefetch" href="/blog/assets/js/26.9487cf2a.js"><link rel="prefetch" href="/blog/assets/js/27.cd3b98f4.js"><link rel="prefetch" href="/blog/assets/js/28.1010db9b.js"><link rel="prefetch" href="/blog/assets/js/29.cff77b90.js"><link rel="prefetch" href="/blog/assets/js/3.b0a270e2.js"><link rel="prefetch" href="/blog/assets/js/30.d9d88b77.js"><link rel="prefetch" href="/blog/assets/js/31.4c816fae.js"><link rel="prefetch" href="/blog/assets/js/32.c414f2c2.js"><link rel="prefetch" href="/blog/assets/js/33.cae1fde7.js"><link rel="prefetch" href="/blog/assets/js/34.c149f32c.js"><link rel="prefetch" href="/blog/assets/js/35.36ce97e5.js"><link rel="prefetch" href="/blog/assets/js/36.b7c514b6.js"><link rel="prefetch" href="/blog/assets/js/37.d9459ed5.js"><link rel="prefetch" href="/blog/assets/js/38.84d4e80e.js"><link rel="prefetch" href="/blog/assets/js/39.21769d8b.js"><link rel="prefetch" href="/blog/assets/js/4.1de495bd.js"><link rel="prefetch" href="/blog/assets/js/40.ba8b2c33.js"><link rel="prefetch" href="/blog/assets/js/41.dbc723df.js"><link rel="prefetch" href="/blog/assets/js/42.6d7ee2ec.js"><link rel="prefetch" href="/blog/assets/js/43.3065c2de.js"><link rel="prefetch" href="/blog/assets/js/44.95652c6b.js"><link rel="prefetch" href="/blog/assets/js/45.1bfb7eee.js"><link rel="prefetch" href="/blog/assets/js/46.21f42bfd.js"><link rel="prefetch" href="/blog/assets/js/47.5cf0a7f8.js"><link rel="prefetch" href="/blog/assets/js/48.80e7bcba.js"><link rel="prefetch" href="/blog/assets/js/49.75bf925a.js"><link rel="prefetch" href="/blog/assets/js/5.7e93193d.js"><link rel="prefetch" href="/blog/assets/js/50.1a08250f.js"><link rel="prefetch" href="/blog/assets/js/51.63d67d9a.js"><link rel="prefetch" href="/blog/assets/js/52.4527b3c2.js"><link rel="prefetch" href="/blog/assets/js/53.928eb7b1.js"><link rel="prefetch" href="/blog/assets/js/54.b2c8392c.js"><link rel="prefetch" href="/blog/assets/js/55.84f7c241.js"><link rel="prefetch" href="/blog/assets/js/56.6773809d.js"><link rel="prefetch" href="/blog/assets/js/57.aed02421.js"><link rel="prefetch" href="/blog/assets/js/58.16532c6b.js"><link rel="prefetch" href="/blog/assets/js/59.43238c8c.js"><link rel="prefetch" href="/blog/assets/js/6.d42d0f48.js"><link rel="prefetch" href="/blog/assets/js/60.d868f9ec.js"><link rel="prefetch" href="/blog/assets/js/61.8bc02b72.js"><link rel="prefetch" href="/blog/assets/js/62.83e6c8d0.js"><link rel="prefetch" href="/blog/assets/js/63.ade81187.js"><link rel="prefetch" href="/blog/assets/js/64.cc73a529.js"><link rel="prefetch" href="/blog/assets/js/65.d002206a.js"><link rel="prefetch" href="/blog/assets/js/66.f0665b6d.js"><link rel="prefetch" href="/blog/assets/js/67.11c613ec.js"><link rel="prefetch" href="/blog/assets/js/68.8e2479dd.js"><link rel="prefetch" href="/blog/assets/js/69.02772367.js"><link rel="prefetch" href="/blog/assets/js/7.2b3bcb3f.js"><link rel="prefetch" href="/blog/assets/js/70.3545ebb5.js"><link rel="prefetch" href="/blog/assets/js/71.b7c76516.js"><link rel="prefetch" href="/blog/assets/js/72.035b6ee2.js"><link rel="prefetch" href="/blog/assets/js/73.9feda52a.js"><link rel="prefetch" href="/blog/assets/js/74.d62cf235.js"><link rel="prefetch" href="/blog/assets/js/75.db2ada7c.js"><link rel="prefetch" href="/blog/assets/js/76.8569647d.js"><link rel="prefetch" href="/blog/assets/js/77.ebb5e006.js"><link rel="prefetch" href="/blog/assets/js/78.463a3566.js"><link rel="prefetch" href="/blog/assets/js/79.25bf57ea.js"><link rel="prefetch" href="/blog/assets/js/8.3cf902c7.js"><link rel="prefetch" href="/blog/assets/js/80.4d3043a3.js"><link rel="prefetch" href="/blog/assets/js/81.e6ac7aff.js"><link rel="prefetch" href="/blog/assets/js/82.39390874.js"><link rel="prefetch" href="/blog/assets/js/84.4efad80d.js"><link rel="prefetch" href="/blog/assets/js/85.dce1dc90.js"><link rel="prefetch" href="/blog/assets/js/86.3050d700.js"><link rel="prefetch" href="/blog/assets/js/87.67d7c4e3.js"><link rel="prefetch" href="/blog/assets/js/88.4a3a4132.js"><link rel="prefetch" href="/blog/assets/js/89.861690de.js"><link rel="prefetch" href="/blog/assets/js/9.f2b8862e.js"><link rel="prefetch" href="/blog/assets/js/90.f1cdccba.js"><link rel="prefetch" href="/blog/assets/js/91.3abb6471.js"><link rel="prefetch" href="/blog/assets/js/92.66e441c7.js"><link rel="prefetch" href="/blog/assets/js/93.3ae60e73.js"><link rel="prefetch" href="/blog/assets/js/94.b6f4569f.js"><link rel="prefetch" href="/blog/assets/js/95.81abfad5.js"><link rel="prefetch" href="/blog/assets/js/96.eaafaf11.js"><link rel="prefetch" href="/blog/assets/js/97.f464844d.js"><link rel="prefetch" href="/blog/assets/js/98.5b594a5f.js"><link rel="prefetch" href="/blog/assets/js/99.8a12c6d2.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.76d42078.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/EB-logo.png" alt="CcbeanBlog" class="logo"> <span class="site-name can-hide">CcbeanBlog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/blog/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/4f29ea/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/blog/pages/5bb2dc/" class="nav-link">HTML+CSS</a></li><li class="dropdown-subitem"><a href="/blog/pages/d0b9bd/" class="nav-link">Vue</a></li><li class="dropdown-subitem"><a href="/blog/pages/ff6413/" class="nav-link">React</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/react-learn/" class="nav-link">React使用学习</a></li><li class="dropdown-subitem"><a href="/blog/note/vue2-code/" class="nav-link">Vue2源码探究</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Node" class="dropdown-title"><a href="/blog/nodejs/" class="link-title">Node</a> <span class="title" style="display:none;">Node</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Node文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/1cce55/" class="nav-link">基础</a></li><li class="dropdown-subitem"><a href="/blog/pages/be0ea7/" class="nav-link">问题</a></li><li class="dropdown-subitem"><a href="/blog/pages/6e080e/" class="nav-link">框架</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/data-structures-and-algorithms/" class="nav-link">数据结构与算法</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="打包工具" class="dropdown-title"><a href="/blog/packtool/" class="link-title">打包工具</a> <span class="title" style="display:none;">打包工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>构建工具文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/a542bb/" class="nav-link">webpack</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/webpack5/" class="nav-link">Webpack5使用学习</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/blog/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/3bd9c5/" class="nav-link">MySQL</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/4db4cb/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9f95d1/" class="nav-link">网络</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/c44d61/" class="nav-link">小技巧</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9c8278/" class="nav-link">杂记</a></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/protocol-buffers/" class="nav-link">Protobuf Buffers</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blog/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/blog/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/blog/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/blog/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/ccbeango/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://avatars.githubusercontent.com/u/16501284?v=4"> <div class="blogger-info"><h3>Ccbean</h3> <span>靡不有初，鲜克有终</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/blog/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/4f29ea/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/blog/pages/5bb2dc/" class="nav-link">HTML+CSS</a></li><li class="dropdown-subitem"><a href="/blog/pages/d0b9bd/" class="nav-link">Vue</a></li><li class="dropdown-subitem"><a href="/blog/pages/ff6413/" class="nav-link">React</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/react-learn/" class="nav-link">React使用学习</a></li><li class="dropdown-subitem"><a href="/blog/note/vue2-code/" class="nav-link">Vue2源码探究</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Node" class="dropdown-title"><a href="/blog/nodejs/" class="link-title">Node</a> <span class="title" style="display:none;">Node</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Node文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/1cce55/" class="nav-link">基础</a></li><li class="dropdown-subitem"><a href="/blog/pages/be0ea7/" class="nav-link">问题</a></li><li class="dropdown-subitem"><a href="/blog/pages/6e080e/" class="nav-link">框架</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/data-structures-and-algorithms/" class="nav-link">数据结构与算法</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="打包工具" class="dropdown-title"><a href="/blog/packtool/" class="link-title">打包工具</a> <span class="title" style="display:none;">打包工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>构建工具文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/a542bb/" class="nav-link">webpack</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/webpack5/" class="nav-link">Webpack5使用学习</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/blog/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/3bd9c5/" class="nav-link">MySQL</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/4db4cb/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9f95d1/" class="nav-link">网络</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/c44d61/" class="nav-link">小技巧</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9c8278/" class="nav-link">杂记</a></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/protocol-buffers/" class="nav-link">Protobuf Buffers</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blog/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/blog/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/blog/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/blog/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/ccbeango/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/blog/pages/d2c2b3/" class="sidebar-link">认识数据结构与算法</a></li><li><a href="/blog/pages/e422b9/" class="sidebar-link">数据结构与算法-数组</a></li><li><a href="/blog/pages/7e2173/" class="sidebar-link">数据结构与算法-栈</a></li><li><a href="/blog/pages/22d79a/" class="sidebar-link">数据结构与算法-队列</a></li><li><a href="/blog/pages/182ff8/" class="sidebar-link">数据结构与算法-链表</a></li><li><a href="/blog/pages/689217/" class="sidebar-link">数据结构与算法-双向链表</a></li><li><a href="/blog/pages/29a8d3/" class="sidebar-link">数据结构与算法-集合</a></li><li><a href="/blog/pages/529961/" class="sidebar-link">数据结构与算法-字典</a></li><li><a href="/blog/pages/c1778a/" class="sidebar-link">数据结构与算法-哈希表</a></li><li><a href="/blog/pages/698b1c/" class="sidebar-link">数据结构与算法-树</a></li><li><a href="/blog/pages/43a3be/" class="sidebar-link">数据结构与算法-二叉搜索树</a></li><li><a href="/blog/pages/a84937/" class="sidebar-link">数据结构与算法-红黑树（一）</a></li><li><a href="/blog/pages/2be117/" class="sidebar-link">数据结构与算法-红黑树（二）</a></li><li><a href="/blog/pages/fdcb4c/" class="sidebar-link">数据结构与算法-二叉堆</a></li><li><a href="/blog/pages/7a0cec/" class="sidebar-link">数据结构与算法-图</a></li><li><a href="/blog/pages/0c5a57/" aria-current="page" class="active sidebar-link">数据结构与算法-排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#排序介绍" class="sidebar-link">排序介绍</a></li><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#冒泡排序" class="sidebar-link">冒泡排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#冒泡排序思路" class="sidebar-link">冒泡排序思路</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#冒泡排序实现" class="sidebar-link">冒泡排序实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#冒泡排序效率" class="sidebar-link">冒泡排序效率</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#选择排序" class="sidebar-link">选择排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#选择排序思路" class="sidebar-link">选择排序思路</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#选择排序实现" class="sidebar-link">选择排序实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#选择排序效率" class="sidebar-link">选择排序效率</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#插入排序" class="sidebar-link">插入排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#插入排序思路" class="sidebar-link">插入排序思路</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#插入排序实现" class="sidebar-link">插入排序实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#插入排序效率" class="sidebar-link">插入排序效率</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#希尔排序" class="sidebar-link">希尔排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#希尔排序思路" class="sidebar-link">希尔排序思路</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#希尔排序实现" class="sidebar-link">希尔排序实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#希尔排序效率" class="sidebar-link">希尔排序效率</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#快速排序" class="sidebar-link">快速排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#快速排序思路" class="sidebar-link">快速排序思路</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#快速排序实现" class="sidebar-link">快速排序实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#快速排序效率" class="sidebar-link">快速排序效率</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#堆排序" class="sidebar-link">堆排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#堆排序思路" class="sidebar-link">堆排序思路</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#堆排序实现" class="sidebar-link">堆排序实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#堆排序效率" class="sidebar-link">堆排序效率</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#归并排序" class="sidebar-link">归并排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#归并排序思路" class="sidebar-link">归并排序思路</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#归并排序实现" class="sidebar-link">归并排序实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#归并排序效率" class="sidebar-link">归并排序效率</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#计数排序" class="sidebar-link">计数排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#计数排序思路" class="sidebar-link">计数排序思路</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#计数排序实现" class="sidebar-link">计数排序实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#计数排序效率" class="sidebar-link">计数排序效率</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#桶排序" class="sidebar-link">桶排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#桶排序思路" class="sidebar-link">桶排序思路</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#桶排序实现" class="sidebar-link">桶排序实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#桶排序效率" class="sidebar-link">桶排序效率</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/0c5a57/#基数排序" class="sidebar-link">基数排序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#基数排序思路" class="sidebar-link">基数排序思路</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#基数排序实现" class="sidebar-link">基数排序实现</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/0c5a57/#基数排序效率" class="sidebar-link">基数排序效率</a></li></ul></li></ul></li><li><a href="/blog/pages/38f11a/" class="sidebar-link">数据结构与算法-总结</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/blog/categories/?category=JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95" title="分类" data-v-06225672>JavaScript数据结构与算法</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/ccbeango" target="_blank" title="作者" class="beLink" data-v-06225672>ccbean</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-01-18</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">数据结构与算法-排序<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="数据结构与算法-排序"><a href="#数据结构与算法-排序" class="header-anchor">#</a> 数据结构与算法 - 排序</h1> <p>排序算法演示网站：https://visualgo.net/zh/sorting</p> <h2 id="排序介绍"><a href="#排序介绍" class="header-anchor">#</a> 排序介绍</h2> <p>一旦我们将数据放置在某个数据结构中存储起来后(比如数组)，就可能根据需求对数据进行不同方式的排序</p> <ul><li>比如对姓名按字母排序</li> <li>对学生按年龄排序</li> <li>对商品按照价格排序</li> <li>对城市按照面积或者人口数量排序</li> <li>对恒星按照大小排序</li></ul> <p>由于排序非常重要而且可能非常耗时，所以它已经成为一个计算机科学中广泛研究的课题，人们已经研究出一套成熟的方案来实现排序。学习已有的排序方法是非常有必要的。</p> <h2 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h2> <h3 id="冒泡排序思路"><a href="#冒泡排序思路" class="header-anchor">#</a> 冒泡排序思路</h3> <ol><li>对未排序的元素从头到尾依次进行两两比较</li> <li>首先选取第1个元素和第2个比较，如果第一个元素大，则交换位置；否则不交换</li> <li>然后后移动一位，选择第2个和第3个进行比较，依次类推，当一轮比较完成，最大的在未排序元素的最右边，成为已排序元素。</li> <li>重复上面步骤，每一轮都会少一个待排序元素，直至所有元素排序完成</li></ol> <h3 id="冒泡排序实现"><a href="#冒泡排序实现" class="header-anchor">#</a> 冒泡排序实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 冒泡排序
 */</span>
<span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 外层循环：根据元素个数，决定几轮冒泡</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 内层循环：每轮比较相邻元素的大小</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><p><strong>代码分析</strong></p> <p>通过两层循环来实现冒泡排序：</p> <ul><li>外层循环：控制一共需要多少轮冒泡；每轮排序都排除掉已经排序的元素。
<ul><li>第一轮排序，冒泡到最后一个<code>length - 1</code></li> <li>第二轮排序，冒泡到倒数第二个元素<code>lenght - 2</code></li></ul></li> <li>内层循环：根据每轮冒泡未排序元素个数，确定每轮冒泡，相邻元素的比较次数
<ul><li>第一次比较，0和1；</li> <li>第二次比较，1和2；以此类推</li></ul></li></ul> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F1.png" alt="排序1"></p> <p>交换元素位置<code>swap</code>函数代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 交换元素位置
 * @param {*} arr 
 * @param {*} idxA 
 * @param {*} idxB 
 */</span>
<span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> idxA<span class="token punctuation">,</span> idxB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>idxA<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>idxB<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>idxB<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>idxA<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="冒泡排序效率"><a href="#冒泡排序效率" class="header-anchor">#</a> 冒泡排序效率</h3> <p>比较次数：<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^2)" class="katex-error" style="color:#cc0000;">$O(n^2)</span></span>$</p> <ul><li>第一次比较<code>n - 1</code>次，第二次比较<code>n-2</code>次，......最后一次比较<code>1</code>次</li> <li>那么比较次数就是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲(n - 1) + (n - …" class="katex-error" style="color:#cc0000;">$(n - 1) + (n - 2) + ... + 1 = \frac{n(n - 1)}{2}</span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，即</mtext></mrow><annotation encoding="application/x-tex">，即</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span></span></span></span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>$</li></ul> <p>交换次数：<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^2)" class="katex-error" style="color:#cc0000;">$O(n^2)</span></span>$</p> <ul><li>每次比较有需要交换和不需要两种可能，如果每两次比较需要一次交换，那么交换次数就是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲\frac{n(n - 1)}…" class="katex-error" style="color:#cc0000;">$\frac{n(n - 1)}{2} / 2 = \frac{n(n - 1)}{4}</span></span>$ 即 <span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^2)" class="katex-error" style="color:#cc0000;">$O(n^2)</span></span>$</li></ul> <h2 id="选择排序"><a href="#选择排序" class="header-anchor">#</a> 选择排序</h2> <p>选择排序改进了冒泡排序，将交换的次数由O(N²)减少到O(N)，但是比较的次数依然是O(N²)</p> <h3 id="选择排序思路"><a href="#选择排序思路" class="header-anchor">#</a> 选择排序思路</h3> <ol><li>选择第1个索引位置元素，然后依次与后面元素比较</li> <li>比较过程中，如果第i个位置元素比第1个小，记录i位置索引</li> <li>每次比较都记录最小索引，一轮比较结束后，交换首次选出的待比较元素与最小元素的位置</li> <li>后移一位选择待比较元素，重复步骤，直到所有元素比较完毕</li></ol> <h3 id="选择排序实现"><a href="#选择排序实现" class="header-anchor">#</a> 选择排序实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 选择排序
 */</span>
<span class="token keyword">function</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 外层循环：每次初始化标记最小元素位置索引</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> min <span class="token operator">=</span> i
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 内层循环：记录一轮循环中，未排序的元素中最小元素位置索引</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        min <span class="token operator">=</span> j
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 最小元素位置索引不等于每次循环初始值 i 本身</span>
    <span class="token comment">// 说明最小元素在后面，交换原i位置元素和min位置元素 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!==</span> min<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> min<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><p><strong>代码分析</strong></p> <p>通过两层循环来实现冒泡排序：</p> <ul><li>外层循环：每次初始化标记最小元素位置索引</li> <li>内层循环：记录一轮循环中，未排序的元素中最小元素位置索引</li> <li>最小元素位置索引不等于每次循环初始值 i 本身，说明最小元素在后面，交换原i位置元素和min位置元素</li></ul> <h3 id="选择排序效率"><a href="#选择排序效率" class="header-anchor">#</a> 选择排序效率</h3> <p>比较次数：<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^2)" class="katex-error" style="color:#cc0000;">$O(n^2)</span></span>$</p> <ul><li>比较次数同冒泡排序，都为<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲\frac{n(n - 1)}…" class="katex-error" style="color:#cc0000;">$\frac{n(n - 1)}{2}</span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，即</mtext></mrow><annotation encoding="application/x-tex">，即</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span></span></span></span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>$</li></ul> <p>交换次数：<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n)" class="katex-error" style="color:#cc0000;">$O(n)</span></span>$</p> <ul><li>交换次数未<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲n - 1" class="katex-error" style="color:#cc0000;">$n - 1</span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，即</mtext></mrow><annotation encoding="application/x-tex">，即</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span></span></span></span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>$</li> <li>所以通常认为选择排序在执行效率上是高于冒泡排序的</li></ul> <h2 id="插入排序"><a href="#插入排序" class="header-anchor">#</a> 插入排序</h2> <p>插入排序思想的核心是局部有序。</p> <ul><li>比如在一个队列中的人，我们选择其中一个作为标记的队员。这个被标记的队员左边的所有队员已经是局部有序的。</li> <li>这意味着，有一部分人是按顺序排列好的。有一部分还没有顺序。</li></ul> <h3 id="插入排序思路"><a href="#插入排序思路" class="header-anchor">#</a> 插入排序思路</h3> <ol><li>首先取出一个元素，认为该元素左边的元素已经是有序的。第一次取第一个元素</li> <li>从已选择元素的右侧取出一个新元素，然后从后向前依次与已排序元素进行比对</li> <li>如果本次选取已排序元素大于新元素，则向前移动一位继续选取已排序元素与新元素比对</li> <li>直到找到已选取元素小于新元素，将新元素插入到这个后面</li> <li>重复以上步骤直到所有元素排序完毕</li></ol> <h3 id="插入排序实现"><a href="#插入排序实现" class="header-anchor">#</a> 插入排序实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 插入排序
 */</span>
<span class="token keyword">function</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 外层循环：每次选出待排序元素</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> element <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// 选出待排序元素</span>

    <span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token comment">// 记录新插入位置 默认在原位置</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 后移前一个元素</span>
      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
      j<span class="token operator">--</span> <span class="token comment">// 更新插入位置</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 插入元素到索引j位置</span>
    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> element
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>代码分析</strong></p> <p>通过两层循环实现插入排序：</p> <ul><li>外层循环：取出待插入（排序）元素
<ul><li>从1开始，默认0位置已排序好</li> <li>选出待排序元素，暂存到element</li></ul></li> <li>内层while循环：确定插入位置
<ul><li>如果前面元素大于待插入元素，将前面的元素后移一位</li> <li>更新插入位置<code>j--</code></li></ul></li></ul> <h3 id="插入排序效率"><a href="#插入排序效率" class="header-anchor">#</a> 插入排序效率</h3> <p>比较次数：<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^2)" class="katex-error" style="color:#cc0000;">$O(n^2)</span></span>$</p> <ul><li>第一次<strong>最多</strong>比较<code>1</code>次，第二次<strong>最多</strong>比较<code>2</code>次，...... 最后一次<strong>最多</strong>比较<code>n - 1</code>次</li> <li>那么最多比较次数就是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲(n - 1) + (n - …" class="katex-error" style="color:#cc0000;">$(n - 1) + (n - 2) + ... + 1 = \frac{n(n - 1)}{2}</span></span>$</li> <li>但并不是每次插入都需要这么多次比较，可能只比较一次就插找到了插入位置</li> <li>所以平均只有全体比较次数的一半，<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲\frac{n(n - 1)}…" class="katex-error" style="color:#cc0000;">$\frac{n(n - 1)}{2} / 2 = \frac{n(n - 1)}{4}</span></span>$</li> <li>复杂度虽然仍是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^2)" class="katex-error" style="color:#cc0000;">$O(n^2)</span></span>$，但平均情况下，相对于选择排序，比较次数少了一半。</li> <li>也就是说，<strong>插入排序最差情况下比较次数等于选择排序和冒泡排序</strong></li></ul> <p>复制次数：<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^2)" class="katex-error" style="color:#cc0000;">$O(n^2)</span></span>$</p> <ul><li>第一次<strong>最多</strong>复制<code>1</code>次，第二次<strong>最多</strong>复制<code>2</code>次，...... 最后一次<strong>最多</strong>复制<code>n - 1</code>次</li> <li>那么最多复制次数就是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲(n - 1) + (n - …" class="katex-error" style="color:#cc0000;">$(n - 1) + (n - 2) + ... + 1 = \frac{n(n - 1)}{2}</span></span>$</li> <li>平均复制次数是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲\frac{n(n - 1)}…" class="katex-error" style="color:#cc0000;">$\frac{n(n - 1)}{2} / 2 = \frac{n(n - 1)}{4}</span></span>$</li></ul> <p>交换次数：<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n)" class="katex-error" style="color:#cc0000;">$O(n)</span></span>$</p> <ul><li>交换次数为外层循环次数</li></ul> <p>对于基本有序的情况</p> <ul><li>对于已经有序或基本有序的数据来说，插入排序要好很多。</li> <li>当数据有序的时候，while循环的条件总是为假，所以它变成了外层循环中的一个简单语句，执行N-1次</li> <li>在这种情况下，算法运行至需要N(N)的时间，效率相对来说会更高</li> <li>另外别忘了，我们的比较次数是选择排序的一半，所以这个算法的效率是高于选择排序的</li></ul> <h2 id="希尔排序"><a href="#希尔排序" class="header-anchor">#</a> 希尔排序</h2> <p>希尔排序，也称递减增量排序，是插入排序的一种更高效的改进版本。</p> <ul><li>希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布。</li> <li>希尔算法首次突破了计算机界一直认为的**算法的时间复杂度都是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O( n^2)" class="katex-error" style="color:#cc0000;">$O( n^2)</span></span>$**的大关，为了纪念该算法里程碑式的意义，用Shell来命名该算法</li></ul> <p>回顾插入排序：</p> <ul><li>在插入排序执行到一半的时候，标识符左边这部分数据项都是排好序的，而标识符右边的数据项是没有排序的</li> <li>此时，取出指向的那个数据项，把它存储在一个临时变量中；接着，从刚刚移除的位置左边第一个单元开始，每次把有序的数据项向右移动一个单元，直到存储在临时变量中的数据项可以成功插入</li></ul> <p>插入排序的问题：</p> <ul><li><p>假设一个很小的数据项在很靠近右端的位置上，这里本来应该是较大的数据项的位置</p></li> <li><p>把这个小数据项移动到左边的正确位置，所有的中间数据项都必须向右移动一位</p></li> <li><p>如果每个步骤对数据项都进行n次复制，平均下来是移动n/2，N个元素就是n²/2，所以我们通常认为插入排序的效率是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^2)" class="katex-error" style="color:#cc0000;">$O(n^2)</span></span>$</p></li> <li><p>如果有某种方式，不需要一个个移动所有中间的数据项，就能把较小的数据项移动到左边，那么这个算法的执行效率就会有很大的改进，希尔排序实现了这种方法</p></li></ul> <h3 id="希尔排序思路"><a href="#希尔排序思路" class="header-anchor">#</a> 希尔排序思路</h3> <p>希尔排序主要通过对数据进行<strong>分组</strong>实现快速排序</p> <ol><li>首先确定一个增量gap，按序列增量进行分组</li> <li>根据设定的增量gap将序列分为gap个组，每组再进行局部的插入排序</li> <li>排序完成后，减小增量gap，每组再进行局部单独排序，直至gap减小到1，进行最后一次排序即可。</li></ol> <p>整个排序过程和插入排序思路相同，区别在于，比较后希尔排序元素可能需要移动gap，插入排序每次移动1。gap为1时，就是插入排序。</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F2.png" alt="排序2"></p> <p>如上图：81, 94, 11, 96, 12, 35, 17, 95, 28, 58, 41, 75, 15.</p> <ul><li>我们先让间隔为5分组，同颜色为一组，得到 (81, 35, 41)、(94, 17, 75)、(11, 95, 15)、(96, 28)、(12, 58)</li> <li>分组插入排序后的新序列，一定可以让数字离自己的正确位置更近一步</li> <li>再让间隔位3，得到(35, 28, 75, 58, 95)、(17, 12, 15, 81)、(11, 41, 96, 94)</li> <li>分组插入排序后的新序列，让数字离自己的正确位置又近了一步</li> <li>最后，我们让间隔为1，也就是所有数据看成一组进行插入排序，这时，数字都离自己的位置更近，那么需要复制的次数一定会减少很多</li></ul> <p><strong>增量gap选择</strong></p> <p>原始序列：</p> <ul><li>希尔排序原稿中，他建议的初始间距是N / 2，简单的把每趟排序分成两半</li> <li>也就是说，对于N = 100的数组，增量间隔序列为: 50、25、12、6、3、1</li> <li>最坏时间复杂度是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^2)" class="katex-error" style="color:#cc0000;">$O(n^2)</span></span>$</li></ul> <p>Knuth增量序列：</p> <ul><li>{1, 4, 13, 40 ...}，多项式为<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲\frac{1}{2}(3^k…" class="katex-error" style="color:#cc0000;">$\frac{1}{2}(3^k-1)</span></span>$</li> <li>最坏时间复杂度是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^\frac{3}{2}…" class="katex-error" style="color:#cc0000;">$O(n^\frac{3}{2})</span></span>$</li></ul> <p>Hibbard增量序列：</p> <ul><li>{1, 3, 5, 7 ...} ，多项式为<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲2^k - 1" class="katex-error" style="color:#cc0000;">$2^k - 1</span></span>$</li> <li>这种增量的最坏复杂度为<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^\frac{3}{2}…" class="katex-error" style="color:#cc0000;">$O(n^\frac{3}{2})</span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>；猜想的平均复杂度为</mtext></mrow><annotation encoding="application/x-tex">；猜想的平均复杂度为</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">；</span><span class="mord cjk_fallback">猜</span><span class="mord cjk_fallback">想</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">杂</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">为</span></span></span></span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mfrac><mn>5</mn><mn>4</mn></mfrac></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^\frac{5}{4})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.20402em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>$，未被证明</li></ul> <p>Sedgewick增量序列：</p> <ul><li>{1, 5, 19, 41, 109 ...}，该序列的多项或是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲9 * 4^i - 9 * 2…" class="katex-error" style="color:#cc0000;">$9 * 4^i - 9 * 2^1 + 1</span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>或是</mtext></mrow><annotation encoding="application/x-tex">或是</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">是</span></span></span></span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>4</mn><mi>i</mi></msup><mo>−</mo><mn>3</mn><mo>∗</mo><msup><mn>2</mn><mi>i</mi></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">4^i - 3 * 2^i + 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span>$</li> <li>猜想：最坏复杂度为<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^\frac{4}{3}…" class="katex-error" style="color:#cc0000;">$O(n^\frac{4}{3})</span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，平均复杂度为</mtext></mrow><annotation encoding="application/x-tex">，平均复杂度为</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">杂</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">为</span></span></span></span></span><span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mfrac><mn>7</mn><mn>6</mn></mfrac></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^\frac{7}{6})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.20402em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>$</li></ul> <h3 id="希尔排序实现"><a href="#希尔排序实现" class="header-anchor">#</a> 希尔排序实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 希尔排序
 */</span>
<span class="token keyword">function</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 普通增量序列</span>
  <span class="token comment">// let gap = Math.floor(arr.length / 2) // 默认增量</span>

  <span class="token comment">// Knuth增量序列</span>
  <span class="token keyword">let</span> gap <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// gap 1, 4, 13, 40 ...</span>
    gap <span class="token operator">=</span> gap <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 第一层循环：while循环，使gap不断减小</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 第二层循环：插入排序 以gap为增量，进行分组，对分组进行插入排序</span>
    <span class="token comment">// 每组从第二个开始排序，默认第一个为有序的</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> element <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

      <span class="token comment">// 第三层循环：确定插入位置</span>
      <span class="token keyword">let</span> j <span class="token operator">=</span> i
      <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> gap <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">&gt;</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token comment">// 每次元素后移gap</span>
        j <span class="token operator">-=</span> gap
      <span class="token punctuation">}</span>

      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> element
    <span class="token punctuation">}</span>

    <span class="token comment">// 普通增量 重新计算增量</span>
    <span class="token comment">// gap = Math.floor(gap / 2)</span>
    <span class="token comment">// Knuth增量 重新计算增量</span>
    gap <span class="token operator">=</span> <span class="token punctuation">(</span>gap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><p>代码分析：</p> <ol><li>首先确定gap增量，第一层循环控制增量不断减小，直至<code>gap = 1</code></li> <li>第二层循环，以gap为增量，进行分组，对分组进行插入排序</li> <li>第三层循环：确定插入位置，元素需要后移时，后移gap长度</li></ol> <h3 id="希尔排序效率"><a href="#希尔排序效率" class="header-anchor">#</a> 希尔排序效率</h3> <p>希尔排序的效率和增量有直接关系</p> <ul><li>原稿中的增量效率都高于简单排序，最坏时间复杂度<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^2)" class="katex-error" style="color:#cc0000;">$O(n^2)</span></span>$</li> <li>Knuth增量序列，最坏时间复杂度是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^\frac{3}{2}…" class="katex-error" style="color:#cc0000;">$O(n^\frac{3}{2})</span></span>$</li> <li>Hibbard增量序列，最坏时间复杂度为<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^\frac{3}{2}…" class="katex-error" style="color:#cc0000;">$O(n^\frac{3}{2})</span></span>$</li> <li>Sedgewick增量序列，最坏复杂度为<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n^\frac{4}{3}…" class="katex-error" style="color:#cc0000;">$O(n^\frac{4}{3})</span></span>$</li></ul> <h2 id="快速排序"><a href="#快速排序" class="header-anchor">#</a> 快速排序</h2> <p><strong>快速排序</strong>可以说是<strong>目前所有排序算法</strong>中，<strong>最快</strong>的一种排序算法。当然，没有任何一种算法是在任意情况下都是最优的。但是，大多数情况下快速排序是比较好的选择。</p> <p>快速排序的核心思想是<strong>分而治之</strong>，先选出一个数据（比如65），将比其小的数据都放在它的左边，将比它大的数据都放在它的右边。这个数据称为<strong>枢纽</strong>。</p> <h3 id="快速排序思路"><a href="#快速排序思路" class="header-anchor">#</a> 快速排序思路</h3> <ol><li>在待排序的数据集中，选择一个数作为枢纽<code>pivot</code></li> <li>所有小于基准<code>pivot</code>的元素放在枢纽<code>pivot</code>的左边；所有大于基准的元素放在右边</li> <li>对基准左右两边的子集不断重复上面两个步骤，直到所有子集只剩下一个元素为止</li></ol> <p>比如，现在有一个数据集{85, 24, 63, 45, 17, 31, 96, 50}，怎么对其排序呢？</p> <ul><li><p>第一步，选择中间的元素45作为枢纽（其实可以任意选择有的直接选择第一个元素，之后讨论如何选择枢纽）</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F3.png" alt="排序3"></p></li> <li><p>第二步，按照顺序，将每个元素与枢纽进行比较，形成两个子集，一个&quot;小于45&quot;，另一个&quot;大于等于45&quot;。</p></li></ul> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F4.png" alt="排序4"></p> <ul><li><p>第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F5.png" alt="排序5"></p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F6.png" alt="排序6"></p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F7.png" alt="排序7"></p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F8.png" alt="排序8"></p></li></ul> <p><strong>枢纽选择</strong></p> <ul><li><p>一种方案是直接选择第一个元素作为枢纽，但第一个作为枢纽在某些情况下，效率并不是特别高</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F9.png" alt="排序9"></p></li> <li><p>第二种是使用随机数，随机取枢纽，但是随机函数本身就是一个耗性能的操作</p></li> <li><p>第三种比较优秀的解决方案是：取头、中、尾的中位数。例如 8、12、3的中位数就是8</p></li></ul> <h3 id="快速排序实现"><a href="#快速排序实现" class="header-anchor">#</a> 快速排序实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 快速排序 - 获取枢纽
 *  - 选择中位数作为枢纽
 * @param {*} left 最左侧索引
 * @param {*} right 左右侧索引
 */</span>
<span class="token keyword">function</span> <span class="token function">getPivot</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> center <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>

  <span class="token comment">// 排序选中的左、中、右三个数，由大到小</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>center<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> center<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>center<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> center<span class="token punctuation">,</span> right<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>center<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> center<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 中位数与倒数第二个数交换位置 倒数第一的数一定比中位数大，直接当作放在右边</span>
  <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> center<span class="token punctuation">,</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

  <span class="token comment">// 返回选择的枢纽pivot</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">[</span>right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 快速排序
 * @param {*} arr 待排序数组
 * @param {*} left 待排序数组最左边索引
 * @param {*} right 待排序数组最右边索引
 * @returns
 */</span>
<span class="token keyword">function</span> <span class="token function">quickSort</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取枢纽</span>
    <span class="token keyword">const</span> pivot <span class="token operator">=</span> <span class="token function">getPivot</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>

    <span class="token comment">// 创建两个指针</span>
    <span class="token keyword">let</span> l <span class="token operator">=</span> left <span class="token comment">// 左边指向最左</span>
    <span class="token keyword">let</span> r <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment">// 右边指向倒数第二个 枢纽的位置</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token operator">++</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 右移左指针到大于pivot的位置</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token operator">--</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 左移右指针到小于pivot的位置</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>  <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token comment">// 左指针索引小于右指针 交换左右指针指向的元素位置</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 交换左指针指向的元素和枢纽元素</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

    <span class="token comment">// 左、右子集递归</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><p>有集合，{23, 4, 76, 10, 72, 7, 99, 12, 13}，过程如下图所示：</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F10.svg" alt="排序10"></p> <ul><li><p><strong>(a)</strong> 首先9个元素，从0开始</p></li> <li><p><strong>(b)</strong> 找出中位数<code>(left + right) / 2</code>，即<code>(0 + 8) / 2 = 4</code></p></li> <li><p><strong>(c)</strong> 对找出的三个元素进行排序，然后交换中位数<code>23</code>与倒数第二个元素<code>12</code>的位置</p></li> <li><p><strong>(d)</strong> 初始化左右两个指针，分别指向要排序的第一个元素<code>13</code>和最后一个要排序的元素<code>23</code>即中位数</p></li> <li><p><strong>(e)</strong> 右移左指针找到第一个比中位数<code>23</code>大的元素<code>76</code>，左移右指针找到第一个比中位数<code>23</code>小的元素<code>7</code>，交换这两个元素</p></li> <li><p><strong>(f)</strong> 继续右移左指针找到比中位数<code>23</code>大的元素<code>76</code>，再左移右指针，找到比中位数<code>23</code>小的元素<code>12</code>，此时<code>left = 5; right = 4; left &gt;= right;</code>，停止查找</p></li> <li><p><strong>(g)</strong> 交换<code>left = 5</code>的元素<code>76</code>与中位数<code>23</code>的位置，即完成此次中位数的左右分割</p></li> <li><p><strong>(h)</strong> <code>23</code>左侧和右侧分别为小于和大于它的元素子集。</p></li> <li><p><strong>(i)</strong> 子集重复上面步骤，完成排序</p></li></ul> <h3 id="快速排序效率"><a href="#快速排序效率" class="header-anchor">#</a> 快速排序效率</h3> <p>快速排序的最坏情况效率</p> <ul><li>每次选择的枢纽都是最左边或者最右边的，那么效率等同于冒泡排序</li> <li>上面的实现方法不可能遇到最坏的情况，因为是三个值中选择中位值</li></ul> <p>快速排序的平均效率</p> <ul><li>快速排序的平均效率是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(nlogn)" class="katex-error" style="color:#cc0000;">$O(nlogn)</span></span>$</li></ul> <h2 id="堆排序"><a href="#堆排序" class="header-anchor">#</a> 堆排序</h2> <p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p> <ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列</p></li> <li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列</p></li></ul> <h3 id="堆排序思路"><a href="#堆排序思路" class="header-anchor">#</a> 堆排序思路</h3> <ol><li>将数据集合创建成最大堆</li> <li>创建成最大堆后，最大值会被存储在数组的第一个位置，将这个值与堆的最后一个值交换位置，堆的大小减1；那么最大值就已经排好顺序</li> <li>然后将堆的根节点下移堆化，再创建现有对数据的最大堆，重复步骤2，直到堆的大小为1</li></ol> <h3 id="堆排序实现"><a href="#堆排序实现" class="header-anchor">#</a> 堆排序实现</h3> <p>对于给定位置index的节点：</p> <ul><li>它的左子节点的位置是<code>index * 2 + 1</code>（如果位置可用）；</li> <li>它的右侧子节点的位置是 <code>index * 2 + 2</code>（如果位置可用）；</li> <li>它的父节点位置是 <code>(index - 1) / 2</code>，向下取整（如果位置可用）。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 下移堆化 大顶堆
 * @param {*} arr 
 * @param {*} index 
 * @param {*} heapSize 
 */</span>
<span class="token keyword">function</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> heapSize</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> largest <span class="token operator">=</span> index

  <span class="token keyword">const</span> left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token keyword">const</span> right <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> heapSize <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 左子节点更大</span>
    largest <span class="token operator">=</span> left
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> heapSize <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 再比对 右子节点更大</span>
    largest <span class="token operator">=</span> right
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> largest<span class="token punctuation">)</span> <span class="token comment">// 交换位置</span>
    <span class="token comment">// largest位置此时为原index位置的节点，可能比子节点小，再进行堆化</span>
    <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> heapSize<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 堆排序
 */</span>
<span class="token keyword">function</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 构建堆 从最后一个父节点位置开始</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> heapSize <span class="token operator">=</span> arr<span class="token punctuation">.</span>length
  <span class="token keyword">while</span> <span class="token punctuation">(</span>heapSize <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>heapSize<span class="token punctuation">)</span> <span class="token comment">// 交换最大值和堆的最后一个值，然后堆大小减1</span>
    <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heapSize<span class="token punctuation">)</span> <span class="token comment">// 重新下移堆化</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><p>理解了二叉堆，堆排序的代码很简单，不再分析。</p> <p><strong>问题</strong></p> <p>构建堆时，<code>i</code>的初始值是<code>Math.floor(arr.length / 2) - 1</code>，这是最后一个非叶子节点的索引，为什么呢？</p> <p>我们假设数组长度为<code>n</code>，最后一个父节点序号是<code>i</code>，分两种情形考虑：</p> <ul><li>情况1：<strong>堆的最后一个非叶子节点若只有左子节点</strong> <ul><li>左子节点为<code>n - 1</code>，又是<code>i * 2 + 1</code>，那么<code>n - 1 = i * 2 + 1</code>即<code>i = (n - 1) / 2 - 1</code></li></ul></li> <li>情况2：<strong>堆的最后一个非叶子节点有左右两个子节点</strong> <ul><li>左子节点是<code>n - 2</code>，那么<code>n - 2 = i * 2 + 1</code>即<code>i = (n - 1) / 2 - 1</code></li> <li>右子节点是<code>n - 1</code>，那么<code>n - 1 = i * 2 + 2</code>即<code>i = (n - 1) / 2 - 1</code></li> <li>两个节点的父节点<code>i</code>都是<code>i = (n - 1) / 2 - 1</code></li></ul></li></ul> <p>很显然，当完全二叉树最后一个节点是其父节点的左孩子时，树的节点数为偶数；</p> <p>当完全二叉树最后一个节点是其父节点的右孩子时，树的节点数为奇数。</p> <p>JS中如果除不尽就向下取整，那么<code>(n - 1) / 2 - 1</code>就是<code>n / 2 - 1</code>。</p> <h3 id="堆排序效率"><a href="#堆排序效率" class="header-anchor">#</a> 堆排序效率</h3> <p>堆排序的平均时间复杂度为<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲Ο(nlogn)" class="katex-error" style="color:#cc0000;">$Ο(nlogn)</span></span>$</p> <h2 id="归并排序"><a href="#归并排序" class="header-anchor">#</a> 归并排序</h2> <p>归并排序的核心思想是分而治之，将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p> <h3 id="归并排序思路"><a href="#归并排序思路" class="header-anchor">#</a> 归并排序思路</h3> <ol><li>将待排序集合等分成两份，然后再将子集进行分割，依此分割，直到每个子集只有一个元素</li> <li>接着将分割的两个子集合并成大的子集，依此合并，直到最后合并成一个数组</li></ol> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F11.png" alt="排序11"></p> <h3 id="归并排序实现"><a href="#归并排序实现" class="header-anchor">#</a> 归并排序实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 合并两个数组
 * @param {*} lArr
 * @param {*} rArr
 * @returns
 */</span>
<span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">lArr<span class="token punctuation">,</span> rArr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>lArr<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rArr<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>lArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> rArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">?</span> lArr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> rArr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>lArr<span class="token punctuation">,</span> rArr<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 归并排序
 * @param {*} arr 
 * @returns 
 */</span>
<span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> midIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>

    <span class="token comment">// 递归 分割数组</span>
    <span class="token keyword">const</span> lArr <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> midIndex<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> rArr <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
    <span class="token comment">// 数组合并</span>
    arr <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>lArr<span class="token punctuation">,</span> rArr<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><h3 id="归并排序效率"><a href="#归并排序效率" class="header-anchor">#</a> 归并排序效率</h3> <p>堆排序的平均时间复杂度为<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲Ο(nlogn)" class="katex-error" style="color:#cc0000;">$Ο(nlogn)</span></span>$</p> <h2 id="计数排序"><a href="#计数排序" class="header-anchor">#</a> 计数排序</h2> <p>计数排序是分布式排序。分布式排序使用已组织好的辅助数据结构——桶，然后进行合并，得到排序好的数组。</p> <p>计数排序是一个整数排序算法，空间取决于最大的数字。</p> <h3 id="计数排序思路"><a href="#计数排序思路" class="header-anchor">#</a> 计数排序思路</h3> <ol><li>统计排序数组中最大值，使用最大值作为桶的最大索引来创建数组</li> <li>遍历排序数组，将数组中元素值作为桶的索引，对应桶索引计数加<code>1</code></li> <li>此时元素已在桶中排好序，遍历取出桶中元素不为0的索引，依次放入到排序数组中即可</li></ol> <h3 id="计数排序实现"><a href="#计数排序实现" class="header-anchor">#</a> 计数排序实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 计数排序
 */</span>
<span class="token keyword">function</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 找到最大值 作为 最大索引</span>
  <span class="token comment">// let max = arr[0]</span>
  <span class="token comment">// for (let i = 1; i &lt; arr.length; i++) {</span>
  <span class="token comment">//   if (max &lt; arr[i]) {</span>
  <span class="token comment">//     max = arr[i]</span>
  <span class="token comment">//   }</span>
  <span class="token comment">// }</span>
  <span class="token keyword">let</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span> <span class="token comment">// 最大值 作为 最大索引</span>

  <span class="token comment">// 创建桶 根据arr的最大值，创建数组用于计数</span>
  <span class="token keyword">const</span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> element <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    buckets<span class="token punctuation">[</span>element<span class="token punctuation">]</span><span class="token operator">++</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 迭代buckets数组并构建排序后的结果数组</span>
  <span class="token keyword">let</span> sortedIndex <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 元素排序后的索引位置 默认0开始</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 可能有相同的值，所以要根据计数值递减来将元素放到结果数组中合适的位置</span>
      arr<span class="token punctuation">[</span>sortedIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i
      buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><p>运行如下图所示：</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F12.png" alt="排序12"></p> <h3 id="计数排序效率"><a href="#计数排序效率" class="header-anchor">#</a> 计数排序效率</h3> <p>时间复杂度是<span class="vuepress-eq"><span title="ParseError: KaTeX parse error: Can&amp;#x27;t use function &amp;#x27;$1#x27; in math mode at position 1: $̲O(n + k)" class="katex-error" style="color:#cc0000;">$O(n + k)</span></span>$，其中k是临时计数数组的大小</p> <h2 id="桶排序"><a href="#桶排序" class="header-anchor">#</a> 桶排序</h2> <p>当数组中取值范围过大，或者不是整数时，可以使用桶排序来解决，其类似于计数排序创建的统计数组，桶排序需要创建若干个“桶“来协助排序。</p> <h3 id="桶排序思路"><a href="#桶排序思路" class="header-anchor">#</a> 桶排序思路</h3> <ol><li>每一个桶代表一个区间范围，里面可以承载一个或多个元素，首先我们要创建这些桶并明确每个桶的区间范围。<code>区间大小 = （最大值 - 最小值）/ 桶的数量</code></li> <li>遍历原始数组，把各元素放入各自的桶中</li> <li>每个桶内的元素分别排序</li> <li>遍历所有桶，输出所有元素</li></ol> <h3 id="桶排序实现"><a href="#桶排序实现" class="header-anchor">#</a> 桶排序实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 桶排序
 * @param {*} arr 
 * @param {*} bucketSize 每个桶的大小
 * @returns 
 */</span>
<span class="token keyword">function</span> <span class="token function">bucketSort</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> bucketSize <span class="token operator">=</span> <span class="token number">5</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span>
  <span class="token keyword">let</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span>

  <span class="token comment">// 创建桶</span>
  <span class="token keyword">let</span> bucketCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>max <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment">// 桶数量</span>
  <span class="token keyword">const</span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>bucketCount<span class="token punctuation">)</span> <span class="token comment">// 初始化桶</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    buckets<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 计算索引并放入桶中</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> bucketIdx <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span>
    buckets<span class="token punctuation">[</span>bucketIdx<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 桶数据排序</span>
  <span class="token keyword">const</span> sortedArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 插入排序</span>
    sortedArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token function">insertionSort</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> sortedArr
<span class="token punctuation">}</span>
</code></pre></div><p>排序如下图</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F13.png" alt="排序13"></p> <h3 id="桶排序效率"><a href="#桶排序效率" class="header-anchor">#</a> 桶排序效率</h3> <h2 id="基数排序"><a href="#基数排序" class="header-anchor">#</a> 基数排序</h2> <p>基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p> <h3 id="基数排序思路"><a href="#基数排序思路" class="header-anchor">#</a> 基数排序思路</h3> <ol><li><p>先以个位数的大小来对数据进行排序，接着以十位数的大小来对数据进行排序，接着以百位数的，依此类推</p></li> <li><p>在对某位数进行排序时，是用桶来排序的，排到最后，就是一组有序的元素</p> <ul><li><p>设置大小范围为0 - 9的10个桶，然后把具有相同的数值的数放进桶</p></li> <li><p>再把桶里的数按照0到9号桶的顺序取出来，重复个位、十位、百位......</p></li> <li><p>最后排序完成</p></li></ul></li></ol> <h3 id="基数排序实现"><a href="#基数排序实现" class="header-anchor">#</a> 基数排序实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 获得元素基于有效位应该插入的桶的索引</span>
<span class="token keyword">const</span> <span class="token function-variable function">getBucketIndex</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> minValue<span class="token punctuation">,</span> significantDigit<span class="token punctuation">,</span> radixBase</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> significantDigit<span class="token punctuation">)</span> <span class="token operator">%</span> radixBase<span class="token punctuation">)</span>

<span class="token comment">// 基于有效位的计数排序</span>
<span class="token keyword">const</span> <span class="token function-variable function">countingSortForRadix</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> radixBase<span class="token punctuation">,</span> significantDigit<span class="token punctuation">,</span> minValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> bucketsIndex
  <span class="token keyword">const</span> buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> aux <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 基于基数初始化桶</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> radixBase<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 基于数组中数的有效位进行计数排序</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    bucketsIndex <span class="token operator">=</span> <span class="token function">getBucketIndex</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> minValue<span class="token punctuation">,</span> significantDigit<span class="token punctuation">,</span> radixBase<span class="token punctuation">)</span>
    buckets<span class="token punctuation">[</span>bucketsIndex<span class="token punctuation">]</span><span class="token operator">++</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 由于进行的是计数排序，还需要计算累积结果来得到正确的计数值,即累加后才能得出相应元素基于有效位排序后应该插入的正确索引</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> radixBase<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> buckets<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 倒序遍历原始数组，将原始数组按有效位排序后相应的元素插入到新数组的正确索引</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    bucketsIndex <span class="token operator">=</span> <span class="token function">getBucketIndex</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> minValue<span class="token punctuation">,</span> significantDigit<span class="token punctuation">,</span> radixBase<span class="token punctuation">)</span>
    <span class="token comment">// 这里很关键，--buckets[bucketsIndex]就是该元素基于有效值排序后要插入的正确索引</span>
    aux<span class="token punctuation">[</span><span class="token operator">--</span>buckets<span class="token punctuation">[</span>bucketsIndex<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将aux(排序好的)数组中的每个值转移到原始数组中</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> array
<span class="token punctuation">}</span>

<span class="token comment">// 基数排序，根据数字的有效位或基数将整数分布到桶中</span>
<span class="token keyword">function</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> radixBase <span class="token operator">=</span> <span class="token number">10</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> array
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> minValue <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span>array<span class="token punctuation">)</span>
  <span class="token keyword">const</span> maxValue <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>array<span class="token punctuation">)</span>
  <span class="token comment">// 对每一个有效位执行计数排序，从1开始</span>
  <span class="token keyword">let</span> significantDigit <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token comment">// 继续这个过程直到没有待排序的有效位</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> significantDigit <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    array <span class="token operator">=</span> <span class="token function">countingSortForRadix</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> radixBase<span class="token punctuation">,</span> significantDigit<span class="token punctuation">,</span> minValue<span class="token punctuation">)</span>
    significantDigit <span class="token operator">*=</span> radixBase
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> array
<span class="token punctuation">}</span>
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F14.png" alt="排序14"></p> <h3 id="基数排序效率"><a href="#基数排序效率" class="header-anchor">#</a> 基数排序效率</h3> <ul><li>时间复杂度：O(k∗n)</li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/ccbeango/blog/edit/master/docs/JavaScript数据结构与算法/16.数据结构与算法-排序.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/01/25, 18:32:14</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/blog/pages/7a0cec/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">数据结构与算法-图</div></a> <a href="/blog/pages/38f11a/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">数据结构与算法-总结</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/pages/7a0cec/" class="prev">数据结构与算法-图</a></span> <span class="next"><a href="/blog/pages/38f11a/">数据结构与算法-总结</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/blog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/blog/pages/78ad41/"><div>
            阅读精通正则表达式总结
            <!----></div></a> <span class="date">09-29</span></dt></dl><dl><dd>02</dd> <dt><a href="/blog/pages/1e1cbc/"><div>
            项目搭建规范的配置
            <!----></div></a> <span class="date">07-15</span></dt></dl><dl><dd>03</dd> <dt><a href="/blog/pages/4c97eb/"><div>
            Vite的使用
            <!----></div></a> <span class="date">07-03</span></dt></dl> <dl><dd></dd> <dt><a href="/blog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="liuyh940@gamil.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/ccbeango" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://space.bilibili.com/316494239" title="Bilibili" target="_blank" class="iconfont icon-bilibili"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2018-2023
    <span>Ccbeango</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.0ed7b280.js" defer></script><script src="/blog/assets/js/2.7308dfd9.js" defer></script><script src="/blog/assets/js/83.52a99a2b.js" defer></script>
  </body>
</html>
