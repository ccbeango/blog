<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>setState详解和React性能优化 | CcbeanBlog</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/blog/img/favicon.ico">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <meta name="description" content="web技术博客,简洁至上。JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,NodeJS,Node,Node.js,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,react,css3,html5,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/blog/assets/css/0.styles.76d42078.css" as="style"><link rel="preload" href="/blog/assets/js/app.0ed7b280.js" as="script"><link rel="preload" href="/blog/assets/js/2.7308dfd9.js" as="script"><link rel="preload" href="/blog/assets/js/93.3ae60e73.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.166b2ca6.js"><link rel="prefetch" href="/blog/assets/js/100.194e839b.js"><link rel="prefetch" href="/blog/assets/js/101.0db39944.js"><link rel="prefetch" href="/blog/assets/js/102.e13c8470.js"><link rel="prefetch" href="/blog/assets/js/103.0ae2f2ee.js"><link rel="prefetch" href="/blog/assets/js/104.a261556e.js"><link rel="prefetch" href="/blog/assets/js/105.4d458a5f.js"><link rel="prefetch" href="/blog/assets/js/106.6d2f15cf.js"><link rel="prefetch" href="/blog/assets/js/107.a770982a.js"><link rel="prefetch" href="/blog/assets/js/108.0be9ce8f.js"><link rel="prefetch" href="/blog/assets/js/109.88d01e84.js"><link rel="prefetch" href="/blog/assets/js/11.faae5f41.js"><link rel="prefetch" href="/blog/assets/js/110.d3186629.js"><link rel="prefetch" href="/blog/assets/js/111.37d2b500.js"><link rel="prefetch" href="/blog/assets/js/112.d94648de.js"><link rel="prefetch" href="/blog/assets/js/113.a7cf5597.js"><link rel="prefetch" href="/blog/assets/js/114.a339354f.js"><link rel="prefetch" href="/blog/assets/js/115.597976cc.js"><link rel="prefetch" href="/blog/assets/js/116.c64f1f49.js"><link rel="prefetch" href="/blog/assets/js/117.bbbbb20b.js"><link rel="prefetch" href="/blog/assets/js/118.c9ba24ea.js"><link rel="prefetch" href="/blog/assets/js/119.25208df7.js"><link rel="prefetch" href="/blog/assets/js/12.782cd676.js"><link rel="prefetch" href="/blog/assets/js/120.2e0a20ad.js"><link rel="prefetch" href="/blog/assets/js/121.7bb8f6f5.js"><link rel="prefetch" href="/blog/assets/js/122.562fe94b.js"><link rel="prefetch" href="/blog/assets/js/123.9562f569.js"><link rel="prefetch" href="/blog/assets/js/124.fd67828f.js"><link rel="prefetch" href="/blog/assets/js/125.3262b310.js"><link rel="prefetch" href="/blog/assets/js/126.c6f106af.js"><link rel="prefetch" href="/blog/assets/js/127.4b7016d1.js"><link rel="prefetch" href="/blog/assets/js/128.b3ac8038.js"><link rel="prefetch" href="/blog/assets/js/129.3ef9af3d.js"><link rel="prefetch" href="/blog/assets/js/13.508b65ad.js"><link rel="prefetch" href="/blog/assets/js/130.4b925feb.js"><link rel="prefetch" href="/blog/assets/js/131.37cb5d18.js"><link rel="prefetch" href="/blog/assets/js/132.76026f1f.js"><link rel="prefetch" href="/blog/assets/js/133.5d3d2938.js"><link rel="prefetch" href="/blog/assets/js/134.89b4fe3b.js"><link rel="prefetch" href="/blog/assets/js/135.dd2731dc.js"><link rel="prefetch" href="/blog/assets/js/136.e5cacc53.js"><link rel="prefetch" href="/blog/assets/js/137.39282e0b.js"><link rel="prefetch" href="/blog/assets/js/138.b3801697.js"><link rel="prefetch" href="/blog/assets/js/14.88ac5afd.js"><link rel="prefetch" href="/blog/assets/js/15.b4227c88.js"><link rel="prefetch" href="/blog/assets/js/16.98d2ae02.js"><link rel="prefetch" href="/blog/assets/js/17.6f25717f.js"><link rel="prefetch" href="/blog/assets/js/18.ae934359.js"><link rel="prefetch" href="/blog/assets/js/19.ffe2dcb2.js"><link rel="prefetch" href="/blog/assets/js/20.2c614eab.js"><link rel="prefetch" href="/blog/assets/js/21.4b7f3180.js"><link rel="prefetch" href="/blog/assets/js/22.03f8def7.js"><link rel="prefetch" href="/blog/assets/js/23.861aebfe.js"><link rel="prefetch" href="/blog/assets/js/24.e842cb60.js"><link rel="prefetch" href="/blog/assets/js/25.5685dfd1.js"><link rel="prefetch" href="/blog/assets/js/26.9487cf2a.js"><link rel="prefetch" href="/blog/assets/js/27.cd3b98f4.js"><link rel="prefetch" href="/blog/assets/js/28.1010db9b.js"><link rel="prefetch" href="/blog/assets/js/29.cff77b90.js"><link rel="prefetch" href="/blog/assets/js/3.b0a270e2.js"><link rel="prefetch" href="/blog/assets/js/30.d9d88b77.js"><link rel="prefetch" href="/blog/assets/js/31.4c816fae.js"><link rel="prefetch" href="/blog/assets/js/32.c414f2c2.js"><link rel="prefetch" href="/blog/assets/js/33.cae1fde7.js"><link rel="prefetch" href="/blog/assets/js/34.c149f32c.js"><link rel="prefetch" href="/blog/assets/js/35.36ce97e5.js"><link rel="prefetch" href="/blog/assets/js/36.b7c514b6.js"><link rel="prefetch" href="/blog/assets/js/37.d9459ed5.js"><link rel="prefetch" href="/blog/assets/js/38.84d4e80e.js"><link rel="prefetch" href="/blog/assets/js/39.21769d8b.js"><link rel="prefetch" href="/blog/assets/js/4.1de495bd.js"><link rel="prefetch" href="/blog/assets/js/40.ba8b2c33.js"><link rel="prefetch" href="/blog/assets/js/41.dbc723df.js"><link rel="prefetch" href="/blog/assets/js/42.6d7ee2ec.js"><link rel="prefetch" href="/blog/assets/js/43.3065c2de.js"><link rel="prefetch" href="/blog/assets/js/44.95652c6b.js"><link rel="prefetch" href="/blog/assets/js/45.1bfb7eee.js"><link rel="prefetch" href="/blog/assets/js/46.21f42bfd.js"><link rel="prefetch" href="/blog/assets/js/47.5cf0a7f8.js"><link rel="prefetch" href="/blog/assets/js/48.80e7bcba.js"><link rel="prefetch" href="/blog/assets/js/49.75bf925a.js"><link rel="prefetch" href="/blog/assets/js/5.7e93193d.js"><link rel="prefetch" href="/blog/assets/js/50.1a08250f.js"><link rel="prefetch" href="/blog/assets/js/51.63d67d9a.js"><link rel="prefetch" href="/blog/assets/js/52.4527b3c2.js"><link rel="prefetch" href="/blog/assets/js/53.928eb7b1.js"><link rel="prefetch" href="/blog/assets/js/54.b2c8392c.js"><link rel="prefetch" href="/blog/assets/js/55.84f7c241.js"><link rel="prefetch" href="/blog/assets/js/56.6773809d.js"><link rel="prefetch" href="/blog/assets/js/57.aed02421.js"><link rel="prefetch" href="/blog/assets/js/58.16532c6b.js"><link rel="prefetch" href="/blog/assets/js/59.43238c8c.js"><link rel="prefetch" href="/blog/assets/js/6.d42d0f48.js"><link rel="prefetch" href="/blog/assets/js/60.d868f9ec.js"><link rel="prefetch" href="/blog/assets/js/61.8bc02b72.js"><link rel="prefetch" href="/blog/assets/js/62.83e6c8d0.js"><link rel="prefetch" href="/blog/assets/js/63.ade81187.js"><link rel="prefetch" href="/blog/assets/js/64.cc73a529.js"><link rel="prefetch" href="/blog/assets/js/65.d002206a.js"><link rel="prefetch" href="/blog/assets/js/66.f0665b6d.js"><link rel="prefetch" href="/blog/assets/js/67.11c613ec.js"><link rel="prefetch" href="/blog/assets/js/68.8e2479dd.js"><link rel="prefetch" href="/blog/assets/js/69.02772367.js"><link rel="prefetch" href="/blog/assets/js/7.2b3bcb3f.js"><link rel="prefetch" href="/blog/assets/js/70.3545ebb5.js"><link rel="prefetch" href="/blog/assets/js/71.b7c76516.js"><link rel="prefetch" href="/blog/assets/js/72.035b6ee2.js"><link rel="prefetch" href="/blog/assets/js/73.9feda52a.js"><link rel="prefetch" href="/blog/assets/js/74.d62cf235.js"><link rel="prefetch" href="/blog/assets/js/75.db2ada7c.js"><link rel="prefetch" href="/blog/assets/js/76.8569647d.js"><link rel="prefetch" href="/blog/assets/js/77.ebb5e006.js"><link rel="prefetch" href="/blog/assets/js/78.463a3566.js"><link rel="prefetch" href="/blog/assets/js/79.25bf57ea.js"><link rel="prefetch" href="/blog/assets/js/8.3cf902c7.js"><link rel="prefetch" href="/blog/assets/js/80.4d3043a3.js"><link rel="prefetch" href="/blog/assets/js/81.e6ac7aff.js"><link rel="prefetch" href="/blog/assets/js/82.39390874.js"><link rel="prefetch" href="/blog/assets/js/83.52a99a2b.js"><link rel="prefetch" href="/blog/assets/js/84.4efad80d.js"><link rel="prefetch" href="/blog/assets/js/85.dce1dc90.js"><link rel="prefetch" href="/blog/assets/js/86.3050d700.js"><link rel="prefetch" href="/blog/assets/js/87.67d7c4e3.js"><link rel="prefetch" href="/blog/assets/js/88.4a3a4132.js"><link rel="prefetch" href="/blog/assets/js/89.861690de.js"><link rel="prefetch" href="/blog/assets/js/9.f2b8862e.js"><link rel="prefetch" href="/blog/assets/js/90.f1cdccba.js"><link rel="prefetch" href="/blog/assets/js/91.3abb6471.js"><link rel="prefetch" href="/blog/assets/js/92.66e441c7.js"><link rel="prefetch" href="/blog/assets/js/94.b6f4569f.js"><link rel="prefetch" href="/blog/assets/js/95.81abfad5.js"><link rel="prefetch" href="/blog/assets/js/96.eaafaf11.js"><link rel="prefetch" href="/blog/assets/js/97.f464844d.js"><link rel="prefetch" href="/blog/assets/js/98.5b594a5f.js"><link rel="prefetch" href="/blog/assets/js/99.8a12c6d2.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.76d42078.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/EB-logo.png" alt="CcbeanBlog" class="logo"> <span class="site-name can-hide">CcbeanBlog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/blog/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/4f29ea/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/blog/pages/5bb2dc/" class="nav-link">HTML+CSS</a></li><li class="dropdown-subitem"><a href="/blog/pages/d0b9bd/" class="nav-link">Vue</a></li><li class="dropdown-subitem"><a href="/blog/pages/ff6413/" class="nav-link">React</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/react-learn/" class="nav-link">React使用学习</a></li><li class="dropdown-subitem"><a href="/blog/note/vue2-code/" class="nav-link">Vue2源码探究</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Node" class="dropdown-title"><a href="/blog/nodejs/" class="link-title">Node</a> <span class="title" style="display:none;">Node</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Node文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/1cce55/" class="nav-link">基础</a></li><li class="dropdown-subitem"><a href="/blog/pages/be0ea7/" class="nav-link">问题</a></li><li class="dropdown-subitem"><a href="/blog/pages/6e080e/" class="nav-link">框架</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/data-structures-and-algorithms/" class="nav-link">数据结构与算法</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="打包工具" class="dropdown-title"><a href="/blog/packtool/" class="link-title">打包工具</a> <span class="title" style="display:none;">打包工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>构建工具文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/a542bb/" class="nav-link">webpack</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/webpack5/" class="nav-link">Webpack5使用学习</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/blog/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/3bd9c5/" class="nav-link">MySQL</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/4db4cb/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9f95d1/" class="nav-link">网络</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/c44d61/" class="nav-link">小技巧</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9c8278/" class="nav-link">杂记</a></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/protocol-buffers/" class="nav-link">Protobuf Buffers</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blog/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/blog/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/blog/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/blog/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/ccbeango/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://avatars.githubusercontent.com/u/16501284?v=4"> <div class="blogger-info"><h3>Ccbean</h3> <span>靡不有初，鲜克有终</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/blog/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/4f29ea/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/blog/pages/5bb2dc/" class="nav-link">HTML+CSS</a></li><li class="dropdown-subitem"><a href="/blog/pages/d0b9bd/" class="nav-link">Vue</a></li><li class="dropdown-subitem"><a href="/blog/pages/ff6413/" class="nav-link">React</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/react-learn/" class="nav-link">React使用学习</a></li><li class="dropdown-subitem"><a href="/blog/note/vue2-code/" class="nav-link">Vue2源码探究</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Node" class="dropdown-title"><a href="/blog/nodejs/" class="link-title">Node</a> <span class="title" style="display:none;">Node</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Node文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/1cce55/" class="nav-link">基础</a></li><li class="dropdown-subitem"><a href="/blog/pages/be0ea7/" class="nav-link">问题</a></li><li class="dropdown-subitem"><a href="/blog/pages/6e080e/" class="nav-link">框架</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/data-structures-and-algorithms/" class="nav-link">数据结构与算法</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="打包工具" class="dropdown-title"><a href="/blog/packtool/" class="link-title">打包工具</a> <span class="title" style="display:none;">打包工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>构建工具文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/a542bb/" class="nav-link">webpack</a></li></ul></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/webpack5/" class="nav-link">Webpack5使用学习</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/blog/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/3bd9c5/" class="nav-link">MySQL</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/4db4cb/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9f95d1/" class="nav-link">网络</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/c44d61/" class="nav-link">小技巧</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/9c8278/" class="nav-link">杂记</a></li><li class="dropdown-item"><h4>系列笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/protocol-buffers/" class="nav-link">Protobuf Buffers</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blog/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/blog/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/blog/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/blog/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/ccbeango/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/blog/pages/3f937c/" class="sidebar-link">Hello World</a></li><li><a href="/blog/pages/65114a/" class="sidebar-link">JSX语法</a></li><li><a href="/blog/pages/919785/" class="sidebar-link">JSX语法的本质</a></li><li><a href="/blog/pages/c5633c/" class="sidebar-link">脚手架</a></li><li><a href="/blog/pages/bd5f26/" class="sidebar-link">什么是组件化开发</a></li><li><a href="/blog/pages/f34018/" class="sidebar-link">组件化开发</a></li><li><a href="/blog/pages/3b1483/" aria-current="page" class="active sidebar-link">setState详解和React性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/blog/pages/3b1483/#setstate的使用" class="sidebar-link">setState的使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/3b1483/#为什么使用setstate" class="sidebar-link">为什么使用setState</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3b1483/#setstate异步更新" class="sidebar-link">setState异步更新</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3b1483/#setstate一定是异步吗" class="sidebar-link">setState一定是异步吗</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3b1483/#setstate的数据合并" class="sidebar-link">setState的数据合并</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/blog/pages/3b1483/#react性能优化" class="sidebar-link">React性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/3b1483/#diffing算法" class="sidebar-link">Diffing算法</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/3b1483/#对比不同类型的元素" class="sidebar-link">对比不同类型的元素</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/3b1483/#对比同一类型的元素" class="sidebar-link">对比同一类型的元素</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/3b1483/#对子节点进行递归" class="sidebar-link">对子节点进行递归</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3b1483/#keys的优化" class="sidebar-link">keys的优化</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/3b1483/#scu的优化" class="sidebar-link">SCU的优化</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/3b1483/#render函数被调用" class="sidebar-link">render函数被调用</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/3b1483/#shouldcomponentupdate" class="sidebar-link">shouldComponentUpdate</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/3b1483/#purecomponent和memo" class="sidebar-link">PureComponent和memo</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/3b1483/#不可变数据的力量" class="sidebar-link">不可变数据的力量</a></li></ul></li></ul></li><li><a href="/blog/pages/77cea2/" class="sidebar-link">受控和非受控组件</a></li><li><a href="/blog/pages/ad645b/" class="sidebar-link">高阶组件</a></li><li><a href="/blog/pages/809a87/" class="sidebar-link">React的样式</a></li><li><a href="/blog/pages/ce6916/" class="sidebar-link">React的过渡动画</a></li><li><a href="/blog/pages/7f1191/" class="sidebar-link">ReactHooks的使用</a></li><li><a href="/blog/pages/18ce7b/" class="sidebar-link">Redux的使用</a></li><li><a href="/blog/pages/d3c53b/" class="sidebar-link">React-Redux</a></li><li><a href="/blog/pages/facc20/" class="sidebar-link">Redux中间件和state管理</a></li><li><a href="/blog/pages/f60ca3/" class="sidebar-link">React-router</a></li><li><a href="/blog/pages/96924f/" class="sidebar-link">React打包发布</a></li><li><a href="/blog/pages/1b0384/" class="sidebar-link">React SSR</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/blog/note/react-learn/#React核心技术与开发实战" data-v-06225672>React核心技术与开发实战</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/ccbeango" target="_blank" title="作者" class="beLink" data-v-06225672>ccbean</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2021-01-10</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">setState详解和React性能优化<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="react学习-七-setstate详解和react性能优化"><a href="#react学习-七-setstate详解和react性能优化" class="header-anchor">#</a> React学习（七）—— setState详解和React性能优化</h1> <h2 id="setstate的使用"><a href="#setstate的使用" class="header-anchor">#</a> setState的使用</h2> <h3 id="为什么使用setstate"><a href="#为什么使用setstate" class="header-anchor">#</a> 为什么使用setState</h3> <p>开发中我们并不能直接通过修改state的值来让界面发生更新，因为我们修改了<code>state</code>之后，希望React根据最新的<code>State</code>来重新渲染界面，但是这种方式的修改React并不知道数据发生了变化。我们必须通过<code>setState</code>来告知React数据已经发生了变化。</p> <p><code>setState</code>是从Component中继承过来的，在类组件中可以直接使用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// react/src/ReactBaseclasses.js</span>
<span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">partialState<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">invariant</span><span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span>
      <span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">||</span>
      partialState <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token string">'setState(...): takes an object of state variables to update or a '</span> <span class="token operator">+</span>
      <span class="token string">'function which returns an object of state variables.'</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> partialState<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token string">'setState'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><h3 id="setstate异步更新"><a href="#setstate异步更新" class="header-anchor">#</a> setState异步更新</h3> <p>setState是异步更新的。</p> <p>下面的例子点击按钮修改<code>Hello World</code>为<code>Hello React</code>，页面中的文字虽然变化了，但是<code>changeText()</code>方法同步执行打印的文本内容仍是<code>Hello World</code>。</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages/React/React%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B524.gif" alt="558989"></p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { Component } from 'react'

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      message: 'Hello World'
    };
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h2&gt;{this.state.message}&lt;/h2&gt;
        &lt;button onClick={() =&gt; this.changeText()}&gt;改变文本&lt;/button&gt;
      &lt;/div&gt;
    )
  }

  changeText() {
    this.setState({
      message: 'Hello React'
    });

    console.log(this.state.message);
  }
}
</code></pre></div><p>为什么<code>setState</code>是异步更新呢？</p> <blockquote><p>https://github.com/facebook/react/issues/11527</p></blockquote> <ul><li><p><code>setState</code>设计成异步，可以显著的提升性能；</p> <ul><li>如果每次调用<code>setState</code>都进行一次更新，那么意味着<code>render</code>函数会被频繁调用，界面重新渲染，这样效率是很低的；</li> <li>好的办法应该是获取到多个更新，之后进行批量更新；</li></ul></li> <li><p>如果同步更新了<code>state</code>，但是还没执行到<code>render</code>函数，那么<code>state</code>和<code>props</code>不能保持同步；</p> <ul><li><code>state</code>和<code>props</code>不能保持一致性，会在开发中产生很多的问题；如父组件和子组件的数据不同步，子组件中接受的props是旧的数据。</li></ul> <p>那么如何可以获取到更新后的值呢？</p> <ul><li>setState接受两个参数：第二个参数是一个回调函数，这个回调函数会在更新后会执行；</li> <li>格式如下：setState(partialState, callback)</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>changeText() {
  this.setState({
    message: &quot;你好啊,李银河&quot;
  }, () =&gt; {
    console.log(this.state.message); // 你好啊,李银河
  });
}
</code></pre></div><p>当然，我们也可以在生命周期函数中获取更新后的数据：</p> <div class="language-react extra-class"><pre class="language-text"><code>componentDidUpdate(prevProps, provState, snapshot) {
  console.log(this.state.message);
}
</code></pre></div></li></ul> <h3 id="setstate一定是异步吗"><a href="#setstate一定是异步吗" class="header-anchor">#</a> setState一定是异步吗</h3> <p>疑惑：setState一定是异步更新的吗？</p> <p>验证一：在setTimeout中的更新：</p> <div class="language-react extra-class"><pre class="language-text"><code>changeText() {
  setTimeout(() =&gt; {
    this.setState({
      message: &quot;你好啊,李银河&quot;
    });
    console.log(this.state.message); // 你好啊,李银河
  }, 0);
}
</code></pre></div><p>验证二：原生DOM事件：</p> <div class="language-react extra-class"><pre class="language-text"><code>componentDidMount() {
  const btnEl = document.getElementById(&quot;btn&quot;);
  btnEl.addEventListener('click', () =&gt; {
    this.setState({
      message: &quot;你好啊,李银河&quot;
    });
    console.log(this.state.message); // 你好啊,李银河
  })
}
</code></pre></div><p>其实分成两种情况：</p> <ul><li>在组件生命周期或React合成事件中，setState是异步；</li> <li>在setTimeout或者原生dom事件中，setState是同步；</li></ul> <p>为什么React会使用合成事件对象？</p> <p>React不止运行在浏览器，还可能运行在手机端（React-Native）。如果运行在浏览器中，那么此时就会把浏览器原生DOM对象和一些其他属性合成到合成事件对象中；如果在手机上，就会使用手机端原生控件对象。到底要使用哪个对象，React在最初始化时是不知道的，会根据环境来判断。</p> <p>React中其实是通过一个函数来确定的：enqueueSetState部分实现（
react-reconciler/ReactFiberClassComponent.js）</p> <p>每个组件对象都有一个updater对象</p> <div class="language-react extra-class"><pre class="language-text"><code> enqueueSetState(inst, payload, callback) {
    const fiber = getInstance(inst);
    const currentTime = requestCurrentTimeForUpdate();
    const suspenseConfig = requestCurrentSuspenseConfig();
    const expirationTime = computeExpirationForFiber(
      currentTime,
      fiber,
      suspenseConfig,
    );

    const update = createUpdate(expirationTime, suspenseConfig);
    update.payload = payload;
    if (callback !== undefined &amp;&amp; callback !== null) {
      if (__DEV__) {
        warnOnInvalidCallback(callback, 'setState');
      }
      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleWork(fiber, expirationTime);
  },
</code></pre></div><p><code>computeExpirationForFiber</code>会决定此次的更新是同步还是批量异步，位置在<code>packages\react-reconciler\src\ReactFiberWorkLoop.js</code>。</p> <p><code>createUpdate</code>会创建一个更新对象，然后<code>enqueueUpdate</code>会生成链表，<code>scheduleWork</code>安排执行相关任务。</p> <p><code>enqueueUpdate</code>生成链表源码如下：</p> <p><code>packages\react-reconciler\src\ReactUpdateQueue.js</code></p> <div class="language-react extra-class"><pre class="language-text"><code>export function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) {
  const updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    // Only occurs if the fiber has been unmounted.
    return;
  }

  const sharedQueue = updateQueue.shared;
  const pending = sharedQueue.pending;
  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }
  sharedQueue.pending = update;

  if (__DEV__) {
    if (
      currentlyProcessingQueue === sharedQueue &amp;&amp;
      !didWarnUpdateInsideUpdate
    ) {
      console.error(
        'An update (setState, replaceState, or forceUpdate) was scheduled ' +
          'from inside an update function. Update functions should be pure, ' +
          'with zero side-effects. Consider using componentDidUpdate or a ' +
          'callback.',
      );
      didWarnUpdateInsideUpdate = true;
    }
  }
}
</code></pre></div><h3 id="setstate的数据合并"><a href="#setstate的数据合并" class="header-anchor">#</a> setState的数据合并</h3> <p>比如我们还是有一个counter属性，记录当前的数字：</p> <ul><li>如果进行如下操作，那么counter会变成几呢？答案是1；</li> <li>为什么呢？因为它会对多个state进行合并；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>  increment() {
    this.setState({
      counter: this.state.counter + 1
    });

    this.setState({
      counter: this.state.counter + 1
    });

    this.setState({
      counter: this.state.counter + 1
    });
  }
</code></pre></div><p>在源码中，有一个do-while循环会对update队列进行处理，内部对多个state进行了合并。</p> <p>如何可以做到，让counter最终变成3呢？</p> <div class="language-react extra-class"><pre class="language-text"><code>increment() {
  this.setState((state, props) =&gt; {
    return {
      counter: state.counter + 1
    }
  })

  this.setState((state, props) =&gt; {
    return {
      counter: state.counter + 1
    }
  })

  this.setState((state, props) =&gt; {
    return {
      counter: state.counter + 1
    }
  })
  }
</code></pre></div><p>为什么传入一个函数就可以变出3呢？</p> <ul><li><p>原因是多个state进行合并时，每次遍历，都会执行一次函数：</p> <p><code>partialState = payload.call(instance, prevState, nextProps);</code></p></li></ul> <p>packages\react-reconciler\src\ReactUpdateQueue.js</p> <div class="language-react extra-class"><pre class="language-text"><code>export function processUpdateQueue&lt;State&gt;(
  workInProgress: Fiber,
  props: any,
  instance: any,
  renderExpirationTime: ExpirationTime,
): void {
  // This is always non-null on a ClassComponent or HostRoot
  const queue: UpdateQueue&lt;State&gt; = (workInProgress.updateQueue: any);

  hasForceUpdate = false;

  if (__DEV__) {
    currentlyProcessingQueue = queue.shared;
  }

  // The last rebase update that is NOT part of the base state.
  let baseQueue = queue.baseQueue;

  // The last pending update that hasn't been processed yet.
  let pendingQueue = queue.shared.pending;
  if (pendingQueue !== null) {
    // We have new updates that haven't been processed yet.
    // We'll add them to the base queue.
    if (baseQueue !== null) {
      // Merge the pending queue and the base queue.
      let baseFirst = baseQueue.next;
      let pendingFirst = pendingQueue.next;
      baseQueue.next = pendingFirst;
      pendingQueue.next = baseFirst;
    }

    baseQueue = pendingQueue;

    queue.shared.pending = null;
    // TODO: Pass `current` as argument
    const current = workInProgress.alternate;
    if (current !== null) {
      const currentQueue = current.updateQueue;
      if (currentQueue !== null) {
        currentQueue.baseQueue = pendingQueue;
      }
    }
  }

  // These values may change as we process the queue.
  if (baseQueue !== null) {
    let first = baseQueue.next;
    // Iterate through the list of updates to compute the result.
    let newState = queue.baseState;
    let newExpirationTime = NoWork;

    let newBaseState = null;
    let newBaseQueueFirst = null;
    let newBaseQueueLast = null;

    if (first !== null) {
      let update = first;
      do {
        const updateExpirationTime = update.expirationTime;
        if (updateExpirationTime &lt; renderExpirationTime) {
          // Priority is insufficient. Skip this update. If this is the first
          // skipped update, the previous update/state is the new base
          // update/state.
          const clone: Update&lt;State&gt; = {
            expirationTime: update.expirationTime,
            suspenseConfig: update.suspenseConfig,

            tag: update.tag,
            payload: update.payload,
            callback: update.callback,

            next: (null: any),
          };
          if (newBaseQueueLast === null) {
            newBaseQueueFirst = newBaseQueueLast = clone;
            newBaseState = newState;
          } else {
            newBaseQueueLast = newBaseQueueLast.next = clone;
          }
          // Update the remaining priority in the queue.
          if (updateExpirationTime &gt; newExpirationTime) {
            newExpirationTime = updateExpirationTime;
          }
        } else {
          // This update does have sufficient priority.

          if (newBaseQueueLast !== null) {
            const clone: Update&lt;State&gt; = {
              expirationTime: Sync, // This update is going to be committed so we never want uncommit it.
              suspenseConfig: update.suspenseConfig,

              tag: update.tag,
              payload: update.payload,
              callback: update.callback,

              next: (null: any),
            };
            newBaseQueueLast = newBaseQueueLast.next = clone;
          }

          // Mark the event time of this update as relevant to this render pass.
          // TODO: This should ideally use the true event time of this update rather than
          // its priority which is a derived and not reverseable value.
          // TODO: We should skip this update if it was already committed but currently
          // we have no way of detecting the difference between a committed and suspended
          // update here.
          markRenderEventTimeAndConfig(
            updateExpirationTime,
            update.suspenseConfig,
          );

          // Process this update.
          newState = getStateFromUpdate(
            workInProgress,
            queue,
            update,
            newState,
            props,
            instance,
          );
          const callback = update.callback;
          if (callback !== null) {
            workInProgress.effectTag |= Callback;
            let effects = queue.effects;
            if (effects === null) {
              queue.effects = [update];
            } else {
              effects.push(update);
            }
          }
        }
        update = update.next;
        if (update === null || update === first) {
          pendingQueue = queue.shared.pending;
          if (pendingQueue === null) {
            break;
          } else {
            // An update was scheduled from inside a reducer. Add the new
            // pending updates to the end of the list and keep processing.
            update = baseQueue.next = pendingQueue.next;
            pendingQueue.next = first;
            queue.baseQueue = baseQueue = pendingQueue;
            queue.shared.pending = null;
          }
        }
      } while (true);
    }

    if (newBaseQueueLast === null) {
      newBaseState = newState;
    } else {
      newBaseQueueLast.next = (newBaseQueueFirst: any);
    }

    queue.baseState = ((newBaseState: any): State);
    queue.baseQueue = newBaseQueueLast;

    // Set the remaining expiration time to be whatever is remaining in the queue.
    // This should be fine because the only two other things that contribute to
    // expiration time are props and context. We're already in the middle of the
    // begin phase by the time we start processing the queue, so we've already
    // dealt with the props. Context in components that specify
    // shouldComponentUpdate is tricky; but we'll have to account for
    // that regardless.
    markUnprocessedUpdateTime(newExpirationTime);
    workInProgress.expirationTime = newExpirationTime;
    workInProgress.memoizedState = newState;
  }

  if (__DEV__) {
    currentlyProcessingQueue = null;
  }
}
</code></pre></div><p>getStateFromUpdate获取新的state</p> <div class="language-react extra-class"><pre class="language-text"><code>function getStateFromUpdate&lt;State&gt;(
  workInProgress: Fiber,
  queue: UpdateQueue&lt;State&gt;,
  update: Update&lt;State&gt;,
  prevState: State,
  nextProps: any,
  instance: any,
): any {
  switch (update.tag) {
   ...
    // Intentional fallthrough
    case UpdateState: {
      const payload = update.payload;
      let partialState;
      if (typeof payload === 'function') {
        // Updater function
        if (__DEV__) {
          enterDisallowedContextReadInDEV();
          if (
            debugRenderPhaseSideEffectsForStrictMode &amp;&amp;
            workInProgress.mode &amp; StrictMode
          ) {
            payload.call(instance, prevState, nextProps);
          }
        }
        partialState = payload.call(instance, prevState, nextProps);
        if (__DEV__) {
          exitDisallowedContextReadInDEV();
        }
      } else {
        // Partial state object
        partialState = payload;
      }
      if (partialState === null || partialState === undefined) {
        // Null and undefined are treated as no-ops.
        return prevState;
      }
      // Merge the partial state and the previous state.
      return Object.assign({}, prevState, partialState);
    }
    case ForceUpdate: {
      hasForceUpdate = true;
      return prevState;
    }
  }
  return prevState;
}
</code></pre></div><p>最后，如果需要，会合并对象<code>return Object.assign({}, prevState, partialState);</code></p> <h2 id="react性能优化"><a href="#react性能优化" class="header-anchor">#</a> React性能优化</h2> <p>我们知道React的渲染流程：</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages/React/React%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B525.png" alt="image-20210622114027542"></p> <p>React的更新流程是：</p> <p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages/React/React%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B526.png" alt="image-20210622114110703"></p> <p>React在props或state发生改变时，会调用React的render方法，会创建一颗不同的树。</p> <p>React需要基于这两颗不同的树之间的差别来判断如何有效的更新UI：</p> <ul><li>如果一棵树参考另外一棵树进行完全比较更新，那么即使是最先进的算法，该算法的复杂程度为 O(n 3 )，其中 n 是树中元素的数量；</li> <li>https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf；</li> <li>如果在 React 中使用了该算法，那么展示 1000 个元素所需要执行的计算量将在十亿的量级范围；</li> <li>这个开销太过昂贵了，React的更新性能会变得非常低效；</li></ul> <p>于是，React对这个算法进行了优化，将其优化成了O(n)，如何优化的呢？</p> <ul><li>同层节点之间相互比较，不会垮节点比较；</li> <li>不同类型的节点，产生不同的树结构；</li> <li>开发中，可以通过key来指定哪些节点在不同的渲染下保持稳定；</li></ul> <h3 id="diffing算法"><a href="#diffing算法" class="header-anchor">#</a> Diffing算法</h3> <h4 id="对比不同类型的元素"><a href="#对比不同类型的元素" class="header-anchor">#</a> 对比不同类型的元素</h4> <p>当节点为不同的元素，React会拆卸原有的树，并且建立起新的树：</p> <ul><li>当一个元素从 <code>&lt;a&gt;</code> 变成 <code>&lt;img&gt;</code>，从 <code>&lt;Article&gt;</code> 变成 <code>&lt;Comment&gt;</code>，或从 <code>&lt;Button&gt;</code> 变成 <code>&lt;div&gt;</code> 都会触发一个完整的重建流程；</li> <li>当卸载一棵树时，对应的DOM节点也会被销毁，组件实例将执行 <code>componentWillUnmount()</code> 方法；</li> <li>当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中，组件实例将执行 <code>componentWillMount()</code> 方法，紧接着 <code>componentDidMount()</code> 方法；</li></ul> <p>比如下面的代码更改：</p> <ul><li>React 会销毁 <code>Counter</code> 组件并且重新装载一个新的组件，而不会对Counter进行复用；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt;
  &lt;Counter /&gt;
&lt;/div&gt;

&lt;span&gt;
  &lt;Counter /&gt;
&lt;/span&gt;
</code></pre></div><h4 id="对比同一类型的元素"><a href="#对比同一类型的元素" class="header-anchor">#</a> 对比同一类型的元素</h4> <p>当比对两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。</p> <p>比如下面的代码更改：</p> <ul><li>通过比对这两个元素，React 知道只需要修改 DOM 元素上的 <code>className</code> 属性；</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&gt;

&lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&gt;
</code></pre></div><p>比如下面的代码更改：</p> <ul><li>当更新 <code>style</code> 属性时，React 仅更新有所更变的属性。</li> <li>通过比对这两个元素，React 知道只需要修改 DOM 元素上的 <code>color</code> 样式，无需修改 <code>fontWeight</code>。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div style={{color: 'red', fontWeight: 'bold'}} /&gt;

&lt;div style={{color: 'green', fontWeight: 'bold'}} /&gt;
</code></pre></div><p>如果是同类型的组件元素：</p> <ul><li>组件会保持不变，React会更新该组件的props，并且调用<code>componentWillReceiveProps()</code> 和 <code>componentWillUpdate()</code> 方法；</li> <li>下一步，调用 <code>render()</code> 方法，diff 算法将在之前的结果以及新的结果中进行递归；</li></ul> <h4 id="对子节点进行递归"><a href="#对子节点进行递归" class="header-anchor">#</a> 对子节点进行递归</h4> <p>在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。</p> <p>我们来看一下在最后插入一条数据的情况：</p> <ul><li>前面两个比较是完全相同的，所以不会产生mutation；</li> <li>最后一个比较，产生一个mutation，将其插入到新的DOM树中即可；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
  &lt;li&gt;third&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><p>但是如果我们是在中间插入一条数据：</p> <ul><li>React会对每一个子元素产生一个mutation，而不是保持 <code>&lt;li&gt;星际穿越&lt;/li&gt;</code>和<code>&lt;li&gt;盗梦空间&lt;/li&gt;</code>的不变；</li> <li>这种低效的比较方式会带来一定的性能问题；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>&lt;ul&gt;
  &lt;li&gt;星际穿越&lt;/li&gt;
  &lt;li&gt;盗梦空间&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li&gt;大话西游&lt;/li&gt;
  &lt;li&gt;星际穿越&lt;/li&gt;
  &lt;li&gt;盗梦空间&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><h3 id="keys的优化"><a href="#keys的优化" class="header-anchor">#</a> keys的优化</h3> <p>我们在前面遍历列表时，总是会提示一个警告，让我们加入一个key属性：</p> <p>我们来看一个案例：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { Component } from 'react'

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      movies: [&quot;星际穿越&quot;, &quot;盗梦空间&quot;]
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h2&gt;电影列表&lt;/h2&gt;
        &lt;ul&gt;
          {
            this.state.movies.map((item, index) =&gt; {
              return &lt;li&gt;{item}&lt;/li&gt;
            })
          }
        &lt;/ul&gt;
        &lt;button onClick={e =&gt; this.insertMovie()}&gt;插入数据&lt;/button&gt;
      &lt;/div&gt;
    )
  }

  insertMovie() {
  }
}
</code></pre></div><p>方式一：在最后位置插入数据</p> <ul><li>这种情况，有无key意义并不大</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>insertMovie() {
  const newMovies = [...this.state.movies, &quot;大话西游&quot;];
  this.setState({
    movies: newMovies
  })
}
</code></pre></div><p>方式二：在前面插入数据</p> <ul><li>这种做法，在没有key的情况下，所有的li都需要进行修改；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>insertMovie() {
  const newMovies = [&quot;大话西游&quot;, ...this.state.movies];
  this.setState({
    movies: newMovies
  })
}
</code></pre></div><p>当子元素(这里的li)拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素：</p> <ul><li>在下面这种场景下，key为111和222的元素仅仅进行位移，不需要进行任何的修改；</li> <li>将key为333的元素插入到最前面的位置即可；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>&lt;ul&gt;
  &lt;li key=&quot;111&quot;&gt;星际穿越&lt;/li&gt;
  &lt;li key=&quot;222&quot;&gt;盗梦空间&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li key=&quot;333&quot;&gt;Connecticut&lt;/li&gt;
  &lt;li key=&quot;111&quot;&gt;星际穿越&lt;/li&gt;
  &lt;li key=&quot;222&quot;&gt;盗梦空间&lt;/li&gt;
&lt;/ul&gt;
</code></pre></div><p>key的注意事项：</p> <ul><li>key应该是唯一的；</li> <li>key不要使用随机数（随机数在下一次render时，会重新生成一个数字）；</li> <li>使用index作为key，对性能是没有优化的；</li></ul> <h3 id="scu的优化"><a href="#scu的优化" class="header-anchor">#</a> SCU的优化</h3> <h4 id="render函数被调用"><a href="#render函数被调用" class="header-anchor">#</a> render函数被调用</h4> <p>我们使用之前的一个嵌套案例：</p> <ul><li>在App中，我们增加了一个计数器的代码；</li> <li>当点击+1时，会重新调用App的render函数；</li> <li>而当App的render函数被调用时，所有的子组件的render函数都会被重新调用；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { Component } from 'react';

function Header() {
  console.log(&quot;Header Render 被调用&quot;);
  return &lt;h2&gt;Header&lt;/h2&gt;
}

class Main extends Component {
  render() {
    console.log(&quot;Main Render 被调用&quot;);
    return (
      &lt;div&gt;
        &lt;Banner/&gt;
        &lt;ProductList/&gt;
      &lt;/div&gt;
    )
  }
}

function Banner() {
  console.log(&quot;Banner Render 被调用&quot;);
  return &lt;div&gt;Banner&lt;/div&gt;
}

function ProductList() {
  console.log(&quot;ProductList Render 被调用&quot;);
  return (
    &lt;ul&gt;
      &lt;li&gt;商品1&lt;/li&gt;
      &lt;li&gt;商品2&lt;/li&gt;
      &lt;li&gt;商品3&lt;/li&gt;
      &lt;li&gt;商品4&lt;/li&gt;
      &lt;li&gt;商品5&lt;/li&gt;
    &lt;/ul&gt;
  )
}

function Footer() {
  console.log(&quot;Footer Render 被调用&quot;);
  return &lt;h2&gt;Footer&lt;/h2&gt;
}

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0
    }
  }

  render() {
    console.log(&quot;App Render 被调用&quot;);

    return (
      &lt;div&gt;
        &lt;h2&gt;当前计数: {this.state.counter}&lt;/h2&gt;
        &lt;button onClick={e =&gt; this.increment()}&gt;+1&lt;/button&gt;
        &lt;Header/&gt;
        &lt;Main/&gt;
        &lt;Footer/&gt;
      &lt;/div&gt;
    )
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }
}
</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/ccbeango/blogImages/React/React%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B527.png" alt="image-20210622173604563"></p> <p>那么，我们可以思考一下，在以后的开发中，我们只要是修改了App中的数据，所有的组件都需要重新render，进行diff算法，性能必然是很低的：</p> <ul><li>事实上，很多的组件没有必须要重新render；</li> <li>它们调用render应该有一个前提，就是依赖的数据（state、props）发生改变时，再调用自己的render方法；</li></ul> <p>如何来控制render方法是否被调用呢？</p> <ul><li>通过<code>shouldComponentUpdate</code>方法即可；</li></ul> <h4 id="shouldcomponentupdate"><a href="#shouldcomponentupdate" class="header-anchor">#</a> shouldComponentUpdate</h4> <p>React给我们提供了一个生命周期方法 <code>shouldComponentUpdate</code>（很多时候，我们简称为SCU），这个方法接受参数，并且需要有返回值：</p> <ul><li><p>该方法有两个参数：</p></li> <li><ul><li>参数一：nextProps 修改之后，最新的props属性</li> <li>参数二：nextState 修改之后，最新的state属性</li></ul></li> <li><p>该方法返回值是一个boolean类型</p></li> <li><ul><li>返回值为true，那么就需要调用render方法；</li> <li>返回值为false，那么久不需要调用render方法；</li> <li>默认返回的是true，也就是只要state发生改变，就会调用render方法；</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>shouldComponentUpdate(nextProps, nextState) {
  return true;
}
</code></pre></div><p>我们可以控制它返回的内容，来决定是否需要重新渲染。</p> <p>比如我们在App中增加一个message属性：</p> <ul><li>jsx中并没有依赖这个message，那么它的改变不应该引起重新渲染；</li> <li>但是因为render监听到state的改变，就会重新render，所以最后render方法还是被重新调用了；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { Component } from 'react';

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0,
      message: &quot;Hello World&quot;
    }
  }

  render() {
    console.log(&quot;App Render 被调用&quot;);

    return (
      &lt;div&gt;
        &lt;h2&gt;当前计数: {this.state.counter}&lt;/h2&gt;
        &lt;button onClick={e =&gt; this.increment()}&gt;+1&lt;/button&gt;
        &lt;button onClick={e =&gt; this.changeText()}&gt;改变文本&lt;/button&gt;
      &lt;/div&gt;
    )
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }

  changeText() {
    this.setState({
      message: &quot;你好啊,李银河&quot;
    })
  }
}
</code></pre></div><p>这个时候，我们可以通过实现shouldComponentUpdate来决定要不要重新调用render方法：</p> <ul><li>这个时候，我们改变counter时，会重新渲染；</li> <li>如果，我们改变的是message，那么默认返回的是false，那么就不会重新渲染；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>shouldComponentUpdate(nextProps, nextState) {
  if (nextState.counter !== this.state.counter) {
    return true;
  }

  return false;
}
</code></pre></div><p>但是我们的代码依然没有优化到最好，因为当counter改变时，所有的子组件依然重新渲染了：</p> <ul><li>所以，事实上，我们应该实现所有的子组件的shouldComponentUpdate；</li></ul> <p>比如Main组件，可以进行如下实现：</p> <ul><li><code>shouldComponentUpdate</code>默认返回一个false；</li> <li>在特定情况下，需要更新时，我们在上面添加对应的条件即可；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>class Main extends Component {

  shouldComponentUpdate(nextProps, nextState) {
    return false;
  }

  render() {
    console.log(&quot;Main Render 被调用&quot;);
    return (
      &lt;div&gt;
        &lt;Banner/&gt;
        &lt;ProductList/&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre></div><h4 id="purecomponent和memo"><a href="#purecomponent和memo" class="header-anchor">#</a> PureComponent和memo</h4> <p>如果所有的类，我们都需要手动来实现 shouldComponentUpdate，那么会给我们开发者增加非常多的工作量。</p> <p>我们来设想一下shouldComponentUpdate中的各种判断的目的是什么？</p> <ul><li>props或者state中的数据是否发生了改变，来决定shouldComponentUpdate返回true或者false；</li></ul> <p>事实上React已经考虑到了这一点，所以React已经默认帮我们实现好了，如何实现呢？</p> <ul><li>将class基础自PureComponent。</li></ul> <p>比如我们修改Main组件的代码：</p> <div class="language-react extra-class"><pre class="language-text"><code>class Main extends PureComponent {
  render() {
    console.log(&quot;Main Render 被调用&quot;);
    return (
      &lt;div&gt;
        &lt;Banner/&gt;
        &lt;ProductList/&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre></div><p>完整代码如下：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { Component, PureComponent } from 'react';

function Header() {
  console.log(&quot;Header Render 被调用&quot;);
  return &lt;h2&gt;Header&lt;/h2&gt;
}

class Main extends PureComponent {
  render() {
    console.log(&quot;Main Render 被调用&quot;);
    return (
      &lt;div&gt;
        &lt;Banner/&gt;
        &lt;ProductList/&gt;
      &lt;/div&gt;
    )
  }
}

class Banner extends PureComponent {
  render() {
    console.log(&quot;Banner Render 被调用&quot;);
    return &lt;div&gt;Banner&lt;/div&gt;
  }
}


function ProductList() {
  console.log(&quot;ProductList Render 被调用&quot;);
  return (
    &lt;ul&gt;
      &lt;li&gt;商品1&lt;/li&gt;
      &lt;li&gt;商品2&lt;/li&gt;
      &lt;li&gt;商品3&lt;/li&gt;
      &lt;li&gt;商品4&lt;/li&gt;
      &lt;li&gt;商品5&lt;/li&gt;
    &lt;/ul&gt;
  )
}

function Footer() {
  console.log(&quot;Footer Render 被调用&quot;);
  return &lt;h2&gt;Footer&lt;/h2&gt;
}

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0
    }
  }

  render() {
    console.log(&quot;App Render 被调用&quot;);

    return (
      &lt;div&gt;
        &lt;h2&gt;当前计数: {this.state.counter}&lt;/h2&gt;
        &lt;button onClick={e =&gt; this.increment()}&gt;+1&lt;/button&gt;
        &lt;Header/&gt;
        &lt;Main/&gt;
        &lt;Footer/&gt;
      &lt;/div&gt;
    )
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }
}
</code></pre></div><p>PureComponent的原理是什么呢？</p> <ul><li>对props和state进行浅层比较；</li></ul> <p>源码中有一个方法<code>checkShouldComponentUpdate</code>会校验我们实例中的<code>render</code>是否需要调用。</p> <p><code>\packages\react-reconciler\src\ReactFiberClassComponent.js</code></p> <ul><li>如果实例中有<code>shouldComponentUpdate</code>方法，那么会调用此方法，并根据此方法的返回布尔值决定是否重新<code>render</code></li> <li>如果实例继承的是<code>PureComponent</code>，就会进行浅层比较，决定是否重新render</li> <li>默认这个方法会返回<code>true</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span>
  <span class="token parameter">workInProgress<span class="token punctuation">,</span>
  ctor<span class="token punctuation">,</span>
  oldProps<span class="token punctuation">,</span>
  newProps<span class="token punctuation">,</span>
  oldState<span class="token punctuation">,</span>
  newState<span class="token punctuation">,</span>
  nextContext<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> instance<span class="token punctuation">.</span>shouldComponentUpdate <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>
        debugRenderPhaseSideEffectsForStrictMode <span class="token operator">&amp;&amp;</span>
        workInProgress<span class="token punctuation">.</span>mode <span class="token operator">&amp;</span> StrictMode
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Invoke the function an extra time to help detect side-effects.</span>
        instance<span class="token punctuation">.</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>newProps<span class="token punctuation">,</span> newState<span class="token punctuation">,</span> nextContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">startPhaseTimer</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> <span class="token string">'shouldComponentUpdate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> shouldUpdate <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>
      newProps<span class="token punctuation">,</span>
      newState<span class="token punctuation">,</span>
      nextContext<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">stopPhaseTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldUpdate <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>
          <span class="token string">'%s.shouldComponentUpdate(): Returned undefined instead of a '</span> <span class="token operator">+</span>
            <span class="token string">'boolean value. Make sure to return true or false.'</span><span class="token punctuation">,</span>
          <span class="token function">getComponentName</span><span class="token punctuation">(</span>ctor<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">'Component'</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> shouldUpdate<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctor<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> ctor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isPureReactComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在<code>packages\react\src\ReactBaseClasses.js</code>中：</p> <ul><li>有一个属性是<code>pureComponentPrototype.isPureReactComponent = true;</code>定义是否是<code>PureComponent</code>；</li> <li>那么上面的<code>checkShouldComponentUpdate</code>就可以根据这个属性判断执行了</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Convenience component with default shallow equality check for sCU.
 */</span>
<span class="token keyword">function</span> <span class="token function">PureComponent</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context<span class="token punctuation">,</span> updater</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>
  <span class="token comment">// If a component has string refs, we will assign a different object later.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>refs <span class="token operator">=</span> emptyObject<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updater <span class="token operator">=</span> updater <span class="token operator">||</span> ReactNoopUpdateQueue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> pureComponentPrototype <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">PureComponent</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComponentDummy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pureComponentPrototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> PureComponent<span class="token punctuation">;</span>
<span class="token comment">// Avoid an extra prototype jump for these methods.</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>pureComponentPrototype<span class="token punctuation">,</span> <span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
pureComponentPrototype<span class="token punctuation">.</span>isPureReactComponent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>那么，如果是一个函数式组件呢？</strong></p> <p>我们需要使用一个高阶组件memo：</p> <ul><li>我们将之前的Header、Banner、ProductList都通过memo函数进行一层包裹；</li> <li>Footer没有使用memo函数进行包裹；</li> <li>最终的效果是，当counter发生改变时，Header、Banner、ProductList的函数不会重新执行，而Footer的函数会被重新执行；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>import React, { Component, PureComponent, memo } from 'react';

const MemoHeader = memo(function Header() {
  console.log(&quot;Header Render 被调用&quot;);
  return &lt;h2&gt;Header&lt;/h2&gt;
})


class Main extends PureComponent {
  render() {
    console.log(&quot;Main Render 被调用&quot;);
    return (
      &lt;div&gt;
        &lt;Banner/&gt;
        &lt;ProductList/&gt;
      &lt;/div&gt;
    )
  }
}

class Banner extends PureComponent {
  render() {
    console.log(&quot;Banner Render 被调用&quot;);
    return &lt;div&gt;Banner&lt;/div&gt;
  }
}


function ProductList() {
  console.log(&quot;ProductList Render 被调用&quot;);
  return (
    &lt;ul&gt;
      &lt;li&gt;商品1&lt;/li&gt;
      &lt;li&gt;商品2&lt;/li&gt;
      &lt;li&gt;商品3&lt;/li&gt;
      &lt;li&gt;商品4&lt;/li&gt;
      &lt;li&gt;商品5&lt;/li&gt;
    &lt;/ul&gt;
  )
}

function Footer() {
  console.log(&quot;Footer Render 被调用&quot;);
  return &lt;h2&gt;Footer&lt;/h2&gt;
}

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      counter: 0
    }
  }

  render() {
    console.log(&quot;App Render 被调用&quot;);

    return (
      &lt;div&gt;
        &lt;h2&gt;当前计数: {this.state.counter}&lt;/h2&gt;
        &lt;button onClick={e =&gt; this.increment()}&gt;+1&lt;/button&gt;
        &lt;MemoHeader/&gt;
        &lt;Main/&gt;
        &lt;Footer/&gt;
      &lt;/div&gt;
    )
  }

  increment() {
    this.setState({
      counter: this.state.counter + 1
    })
  }
}
</code></pre></div><p>memo在<code>\packages\react\src\memo.js</code>文件中，返回了一个对象，这个对象中有一个compare函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> memo<span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> React$ElementType<span class="token punctuation">,</span>
  compare<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">oldProps</span><span class="token operator">:</span> Props<span class="token punctuation">,</span> <span class="token literal-property property">newProps</span><span class="token operator">:</span> Props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> boolean<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isValidElementType</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>
        <span class="token string">'memo: The first argument must be a component. Instead '</span> <span class="token operator">+</span>
          <span class="token string">'received: %s'</span><span class="token punctuation">,</span>
        type <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">'null'</span> <span class="token operator">:</span> <span class="token keyword">typeof</span> type<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_MEMO_TYPE</span><span class="token punctuation">,</span>
    type<span class="token punctuation">,</span>
    <span class="token literal-property property">compare</span><span class="token operator">:</span> compare <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> compare<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>具体的比较在<code>packages\react-reconciler\src\ReactFiberBeginWork.js</code>中</p> <ul><li>如果自己在memo中传入了compare函数，就是用传入的，否则使用<code>shallowEqual</code>浅比较。</li> <li>所以memo的本质上做了一个浅比较</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">updateMemoComponent</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">current</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">workInProgress</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">Component</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">nextProps</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  updateExpirationTime<span class="token punctuation">,</span>
  <span class="token literal-property property">renderExpirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> Fiber <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> type <span class="token operator">=</span> Component<span class="token punctuation">.</span>type<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      <span class="token function">isSimpleFunctionComponent</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      Component<span class="token punctuation">.</span>compare <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
      <span class="token comment">// SimpleMemoComponent codepath doesn't resolve outer props either.</span>
      Component<span class="token punctuation">.</span>defaultProps <span class="token operator">===</span> <span class="token keyword">undefined</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> resolvedType <span class="token operator">=</span> type<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        resolvedType <span class="token operator">=</span> <span class="token function">resolveFunctionForHotReloading</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// If this is a plain function component without default props,</span>
      <span class="token comment">// and with only the default shallow comparison, we upgrade it</span>
      <span class="token comment">// to a SimpleMemoComponent to allow fast path updates.</span>
      workInProgress<span class="token punctuation">.</span>tag <span class="token operator">=</span> SimpleMemoComponent<span class="token punctuation">;</span>
      workInProgress<span class="token punctuation">.</span>type <span class="token operator">=</span> resolvedType<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">validateFunctionComponentInDev</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token function">updateSimpleMemoComponent</span><span class="token punctuation">(</span>
        current<span class="token punctuation">,</span>
        workInProgress<span class="token punctuation">,</span>
        resolvedType<span class="token punctuation">,</span>
        nextProps<span class="token punctuation">,</span>
        updateExpirationTime<span class="token punctuation">,</span>
        renderExpirationTime<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> innerPropTypes <span class="token operator">=</span> type<span class="token punctuation">.</span>propTypes<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>innerPropTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Inner memo component props aren't currently validated in createElement.</span>
        <span class="token comment">// We could move it there, but we'd still need this for lazy code path.</span>
        <span class="token function">checkPropTypes</span><span class="token punctuation">(</span>
          innerPropTypes<span class="token punctuation">,</span>
          nextProps<span class="token punctuation">,</span> <span class="token comment">// Resolved props</span>
          <span class="token string">'prop'</span><span class="token punctuation">,</span>
          <span class="token function">getComponentName</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">,</span>
          getCurrentFiberStackInDev<span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token function">createFiberFromTypeAndProps</span><span class="token punctuation">(</span>
      Component<span class="token punctuation">.</span>type<span class="token punctuation">,</span>
      <span class="token keyword">null</span><span class="token punctuation">,</span>
      nextProps<span class="token punctuation">,</span>
      <span class="token keyword">null</span><span class="token punctuation">,</span>
      workInProgress<span class="token punctuation">.</span>mode<span class="token punctuation">,</span>
      renderExpirationTime<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    child<span class="token punctuation">.</span>ref <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>ref<span class="token punctuation">;</span>
    child<span class="token punctuation">.</span>return <span class="token operator">=</span> workInProgress<span class="token punctuation">;</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> child<span class="token punctuation">;</span>
    <span class="token keyword">return</span> child<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> type <span class="token operator">=</span> Component<span class="token punctuation">.</span>type<span class="token punctuation">;</span>
    <span class="token keyword">const</span> innerPropTypes <span class="token operator">=</span> type<span class="token punctuation">.</span>propTypes<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>innerPropTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Inner memo component props aren't currently validated in createElement.</span>
      <span class="token comment">// We could move it there, but we'd still need this for lazy code path.</span>
      <span class="token function">checkPropTypes</span><span class="token punctuation">(</span>
        innerPropTypes<span class="token punctuation">,</span>
        nextProps<span class="token punctuation">,</span> <span class="token comment">// Resolved props</span>
        <span class="token string">'prop'</span><span class="token punctuation">,</span>
        <span class="token function">getComponentName</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">,</span>
        getCurrentFiberStackInDev<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> currentChild <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>child<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> Fiber<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This is always exactly one child</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>updateExpirationTime <span class="token operator">&lt;</span> renderExpirationTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This will be the props with resolved defaultProps,</span>
    <span class="token comment">// unlike current.memoizedProps which will be the unresolved ones.</span>
    <span class="token keyword">const</span> prevProps <span class="token operator">=</span> currentChild<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
    <span class="token comment">// Default to shallow comparison</span>
    <span class="token keyword">let</span> compare <span class="token operator">=</span> Component<span class="token punctuation">.</span>compare<span class="token punctuation">;</span>
    compare <span class="token operator">=</span> compare <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> compare <span class="token operator">:</span> shallowEqual<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>ref <span class="token operator">===</span> workInProgress<span class="token punctuation">.</span>ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>
        current<span class="token punctuation">,</span>
        workInProgress<span class="token punctuation">,</span>
        renderExpirationTime<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// React DevTools reads this flag.</span>
  workInProgress<span class="token punctuation">.</span>effectTag <span class="token operator">|=</span> PerformedWork<span class="token punctuation">;</span>
  <span class="token keyword">let</span> newChild <span class="token operator">=</span> <span class="token function">createWorkInProgress</span><span class="token punctuation">(</span>currentChild<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  newChild<span class="token punctuation">.</span>ref <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>ref<span class="token punctuation">;</span>
  newChild<span class="token punctuation">.</span>return <span class="token operator">=</span> workInProgress<span class="token punctuation">;</span>
  workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> newChild<span class="token punctuation">;</span>
  <span class="token keyword">return</span> newChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="不可变数据的力量"><a href="#不可变数据的力量" class="header-anchor">#</a> 不可变数据的力量</h4> <p>我们通过一个案例来演练我们之前说的不可变数据的重要性：</p> <div class="language-react extra-class"><pre class="language-text"><code>import React, { PureComponent } from 'react'

export default class App extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      friends: [
        { name: &quot;lilei&quot;, age: 20, height: 1.76 },
        { name: &quot;lucy&quot;, age: 18, height: 1.65 },
        { name: &quot;tom&quot;, age: 30, height: 1.78 }
      ]
    }
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h2&gt;朋友列表&lt;/h2&gt;
        &lt;ul&gt;
          {
            this.state.friends.map((item, index) =&gt; {
              return (
                &lt;li key={item.name}&gt;
                  &lt;span&gt;{`姓名:${item.name} 年龄: ${item.age}`}&lt;/span&gt;
                  &lt;button onClick={e =&gt; this.incrementAge(index)}&gt;年龄+1&lt;/button&gt;
                &lt;/li&gt;
              )
            })
          }
        &lt;/ul&gt;
        &lt;button onClick={e =&gt; this.insertFriend()}&gt;添加新数据&lt;/button&gt;
      &lt;/div&gt;
    )
  }

  insertFriend() {
     
  }

  incrementAge(index) {
    
  }
}
</code></pre></div><p><strong>我们来思考一下inertFriend应该如何实现？</strong></p> <p>实现方式一：</p> <ul><li>这种方式会造成界面不会发生刷新，添加新的数据；</li> <li>原因是继承自PureComponent，会进行浅层比较，浅层比较过程中两个friends是相同的对象；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>insertFriend() {
  this.state.friends.push({name: &quot;why&quot;, age: 18, height: 1.88});
  this.setState({
    friends: this.state.friends
  })
}
</code></pre></div><p>实现方式二：</p> <ul><li><code>[...this.state.friends, {name: &quot;why&quot;, age: 18, height: 1.88}]</code>会生成一个新的数组引用；</li> <li>在进行浅层比较时，两个引用的是不同的数组，所以它们是不相同的；</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>insertFriend() {
  this.setState({
    friends: [...this.state.friends, {name: &quot;why&quot;, age: 18, height: 1.88}]
  })
}
</code></pre></div><p><strong>我们再来思考一下incrementAge应该如何实现？</strong></p> <p>实现方式一：</p> <ul><li>和上面方式一类似</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>incrementAge(index) {
  this.state.friends[index].age += 1;
  this.setState({
    friends: this.state.friends
  })
}
</code></pre></div><p>实现方式二：</p> <ul><li>和上面方式二类似</li></ul> <div class="language-react extra-class"><pre class="language-text"><code>incrementAge(index) {
  const newFriends = [...this.state.friends];
  newFriends[index].age += 1;
  this.setState({
    friends: newFriends
  })
}
</code></pre></div><p>所以，在真实开发中，我们要尽量保证state、props中的数据不可变性，这样我们才能合理和安全的使用PureComponent和memo。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/ccbeango/blog/edit/master/docs/React核心技术与开发实战/07.setState详解和React性能优化.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2021/12/01, 12:13:22</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/blog/pages/f34018/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">组件化开发</div></a> <a href="/blog/pages/77cea2/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">受控和非受控组件</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/pages/f34018/" class="prev">组件化开发</a></span> <span class="next"><a href="/blog/pages/77cea2/">受控和非受控组件</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/blog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/blog/pages/78ad41/"><div>
            阅读精通正则表达式总结
            <!----></div></a> <span class="date">09-29</span></dt></dl><dl><dd>02</dd> <dt><a href="/blog/pages/1e1cbc/"><div>
            项目搭建规范的配置
            <!----></div></a> <span class="date">07-15</span></dt></dl><dl><dd>03</dd> <dt><a href="/blog/pages/4c97eb/"><div>
            Vite的使用
            <!----></div></a> <span class="date">07-03</span></dt></dl> <dl><dd></dd> <dt><a href="/blog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="liuyh940@gamil.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/ccbeango" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://space.bilibili.com/316494239" title="Bilibili" target="_blank" class="iconfont icon-bilibili"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2018-2023
    <span>Ccbeango</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.0ed7b280.js" defer></script><script src="/blog/assets/js/2.7308dfd9.js" defer></script><script src="/blog/assets/js/93.3ae60e73.js" defer></script>
  </body>
</html>
