(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{400:function(t,s,a){"use strict";a.r(s);var i=a(1),l=Object(i.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"什么是hash表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是hash表"}},[t._v("#")]),t._v(" 什么是Hash表")]),t._v(" "),s("p",[t._v("Hash表本质上还是利用数组来存储数据。")]),t._v(" "),s("p",[t._v("但是哈希表解决了数组存在的一些问题：数据插入和删除效率较低、关键在于查找数据时，如果使用元素去查找，时间复杂度是"),s("code",[t._v("O(n)")]),t._v("。")]),t._v(" "),s("p",[t._v("哈希表能够很好的提供插入、查找、删除操作。插入和删除的时间复杂度接近于常量时间，也就是"),s("code",[t._v("O(1)")]),t._v("。查找速度也很快，取决于哈希表的实现方案。基本上两到三次就可以找到查找数据。")]),t._v(" "),s("p",[t._v("那么哈希表的实现：")]),t._v(" "),s("ol",[s("li",[t._v("首先是通过将存储值通过哈希化，将一个较大值通过哈希函数计算得到一个存储数组的下标。具体如下：\n"),s("ul",[s("li",[t._v("首先计算哈希值，根据霍纳法则，哈希值乘以质数，与将要计算值的每一位进行异或操作，得到最终的哈希值，")]),t._v(" "),s("li",[t._v("然后再与存储数组的长度进行取余，获取要存储的下表。")])])]),t._v(" "),s("li",[t._v("然后将值存储到数组的这个下标位置。但是可能会出现多个值有相同的下标，此时就需要解决地址冲突。")]),t._v(" "),s("li",[t._v("解决地址冲突的方法分为两种：一种是开放地址法，一种是链地址法。\n"),s("ul",[s("li",[t._v("链地址法：数组的每一位存储的不是一个元素，而是一个链表或者数组，每个元素数据存储在对应位置的链表中，发生冲突，新数据添加到链表中即可")]),t._v(" "),s("li",[t._v("开放地址法又分为三种：\n"),s("ul",[s("li",[s("strong",[t._v("线性探测")]),t._v("：如果发生冲突，那么就将向下一个个位置移动查找空白单元，存储数据。但是会出现聚集问题，也就是多个数据集中存储在数组的一块位置，其余位置为空。")]),t._v(" "),s("li",[t._v("然后又有"),s("strong",[t._v("二次探测")]),t._v("方法：发生冲突时，之前是一个个移动位置，现在通过获取不同的步长，如第一个"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("msup",[s("mn",[t._v("1")]),s("mn",[t._v("2")])],1)],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("1^2")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.8141079999999999em","vertical-align":"0em"}}),s("span",{staticClass:"mord"},[s("span",{staticClass:"mord"},[t._v("1")]),s("span",{staticClass:"msupsub"},[s("span",{staticClass:"vlist-t"},[s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[s("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),s("span",{staticClass:"sizing reset-size6 size3 mtight"},[s("span",{staticClass:"mord mtight"},[t._v("2")])])])])])])])])])])])]),t._v("，第二次"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("msup",[s("mn",[t._v("2")]),s("mn",[t._v("2")])],1)],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^2")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.8141079999999999em","vertical-align":"0em"}}),s("span",{staticClass:"mord"},[s("span",{staticClass:"mord"},[t._v("2")]),s("span",{staticClass:"msupsub"},[s("span",{staticClass:"vlist-t"},[s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[s("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),s("span",{staticClass:"sizing reset-size6 size3 mtight"},[s("span",{staticClass:"mord mtight"},[t._v("2")])])])])])])])])])])])]),t._v("，以此类推。但是还是会出现此种步长的聚集。")],1),t._v(" "),s("li",[t._v("最后的方案是再"),s("strong",[t._v("哈希化法")]),t._v("：也就是再次哈细化，将这个值"),s("code",[t._v("key")]),t._v("用另一个哈希函数处理，得到的值作为步长。工作很好的函数"),s("code",[t._v("stepSize = constant - (key % constant)")]),t._v("，其中 constant 是质数，且小于数组的容量。")])])])])]),t._v(" "),s("li",[t._v("数组存储在数组中，如果出现冲突过多，就需要进行数组的"),s("strong",[t._v("扩容")]),t._v("；或者数组远大于要存储的数据个数，就要进行"),s("strong",[t._v("压缩")]),t._v("。那么评判的标准就需要用到"),s("strong",[t._v("装载因子")]),t._v("，装载因子等于数据个数除以数组长度。一般情况下，如果装载因子大于"),s("code",[t._v("0.75")]),t._v("，就扩容两倍，然后如果不是质数，再计算直接累加，直到是质数为止。如果装载因子小于"),s("code",[t._v("0.25")]),t._v("，就需要压缩数组。保证平均查找次数为2次。")])]),t._v(" "),s("p",[t._v("实现哈希表，主要解决数据查找的效率问题。")]),t._v(" "),s("p",[t._v("哈希表的问题：")]),t._v(" "),s("ul",[s("li",[t._v("空间利用率不高，底层使用数组，有空位")]),t._v(" "),s("li",[t._v("数据本身无序的")])]),t._v(" "),s("h3",{attrs:{id:"什么是二叉树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是二叉树"}},[t._v("#")]),t._v(" 什么是二叉树")]),t._v(" "),s("p",[t._v("如果树中每个节点最多有两个子节点，这样的树就称为二叉树。")]),t._v(" "),s("p",[t._v("二叉树的特性：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("一个二叉树第i层的最大节点数为"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("msup",[s("mn",[t._v("2")]),s("mrow",[s("mi",[t._v("i")]),s("mo",[t._v("−")]),s("mn",[t._v("1")])],1)],1)],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^{i-1}")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.824664em","vertical-align":"0em"}}),s("span",{staticClass:"mord"},[s("span",{staticClass:"mord"},[t._v("2")]),s("span",{staticClass:"msupsub"},[s("span",{staticClass:"vlist-t"},[s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.824664em"}},[s("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),s("span",{staticClass:"sizing reset-size6 size3 mtight"},[s("span",{staticClass:"mord mtight"},[s("span",{staticClass:"mord mathdefault mtight"},[t._v("i")]),s("span",{staticClass:"mbin mtight"},[t._v("−")]),s("span",{staticClass:"mord mtight"},[t._v("1")])])])])])])])])])])])])])],1)]),t._v(" "),s("li",[s("p",[t._v("深度为k的二叉树最多节点个数为"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("msup",[s("mn",[t._v("2")]),s("mi",[t._v("k")])],1),s("mo",[t._v("−")]),s("mn",[t._v("1")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^{k} - 1")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.932438em","vertical-align":"-0.08333em"}}),s("span",{staticClass:"mord"},[s("span",{staticClass:"mord"},[t._v("2")]),s("span",{staticClass:"msupsub"},[s("span",{staticClass:"vlist-t"},[s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.849108em"}},[s("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),s("span",{staticClass:"sizing reset-size6 size3 mtight"},[s("span",{staticClass:"mord mtight"},[s("span",{staticClass:"mord mathdefault mtight",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])])])])])]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),s("span",{staticClass:"mbin"},[t._v("−")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),s("span",{staticClass:"mord"},[t._v("1")])])])])])],1)]),t._v(" "),s("li",[s("p",[t._v("任何非空二叉树，")])])]),t._v(" "),s("p",[t._v("二叉搜索树：")]),t._v(" "),s("ul",[s("li",[t._v("非空左子树所有键值小于其根节点的值")]),t._v(" "),s("li",[t._v("非空右子树所有键值大于其根节点的值")]),t._v(" "),s("li",[t._v("左、右子树本身也都是二叉搜索树")])]),t._v(" "),s("p",[t._v("红黑树：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("节点非黑即红")])]),t._v(" "),s("li",[s("p",[t._v("根节点是黑色的")])]),t._v(" "),s("li",[s("p",[t._v("叶子节点是黑色的Nil节点")])]),t._v(" "),s("li",[s("p",[t._v("红节点的叶子节点是黑色的，也就是说不能有两个连续的红节点")])]),t._v(" "),s("li",[s("p",[t._v("任意节点到叶子节点，路径中包含的黑色节点数是相同的")])]),t._v(" "),s("li",[s("p",[t._v("插入节点 （插入节点是红色节点）")]),t._v(" "),s("ol",[s("li",[t._v("插入节点是根节点，直接变为黑色")]),t._v(" "),s("li",[t._v("插入节点父节点是黑色节点，直接插入即可")]),t._v(" "),s("li",[t._v("插入节点父节点是红色，叔叔节点也是红色，此时祖父节点必为黑色。那么将父叔节点变黑，祖父节点变红。此时视角移到祖父节点，可能遇到其它情况。")]),t._v(" "),s("li",[t._v("插入节点父节点红色且是父节点的左子节点，叔叔节点和祖父节点是黑色。此时，父节点变黑，祖父节点变红；以祖父节点为轴进行右旋转。")]),t._v(" "),s("li",[t._v("插入节点父节点是红色且是父节点的右子节点，叔叔和祖父节点黑色。父节点左旋转。然后回归到情况4，是左子节点的情况。")])])])])])}),[],!1,null,null,null);s.default=l.exports}}]);