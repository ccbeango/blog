(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{423:function(e,t,r){"use strict";r.r(t);var s=r(1),a=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue源码初探"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue源码初探"}},[e._v("#")]),e._v(" Vue源码初探")]),e._v(" "),t("p",[e._v("本节记录阅读Vue2源码的整体目录结构，对Vue2的代码模块设计和划分有一个初步的了解。")]),e._v(" "),t("h2",{attrs:{id:"vue中的flow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue中的flow"}},[e._v("#")]),e._v(" Vue中的Flow")]),e._v(" "),t("p",[e._v("我们都知道，Javascript作为动态类型语言十分灵活。最初的JavaScript只是为了实现简单的页面交互逻辑，寥寥几句就能完成一个网页的交互任务。不过随着前端的发展，前端项目越来越庞大，JS代码越来越多，过于灵活的语言特性也导致了一些难以在开发编译阶段发现的问题，但在运行阶段却会出现各种各样的bug。")]),e._v(" "),t("p",[e._v("项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。")]),e._v(" "),t("p",[e._v("Vue2使用"),t("a",{attrs:{href:"https://flow.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flow"),t("OutboundLink")],1),e._v("作为类型检查工具，可以让我们在编译阶段提前发现一些难以发现的问题。")]),e._v(" "),t("blockquote",[t("p",[e._v("类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。")])]),e._v(" "),t("p",[e._v("那么Vue 2.0 为什么选用 Flow 进行静态代码检查而不是直接使用 TypeScript？")]),e._v(" "),t("blockquote",[t("p",[e._v("作者的"),t("a",{attrs:{href:"https://www.zhihu.com/question/46397274/answer/101193678",target:"_blank",rel:"noopener noreferrer"}},[e._v("回复"),t("OutboundLink")],1),e._v("：")]),e._v(" "),t("p",[e._v("这个选择最根本的还是在于工程上成本和收益的考量。Vue 2.0 本身在初期的快速迭代阶段是用 ES2015 写的，整个构建工具链也沿用了 Vue 1.x 的基于 ES 生态的一套（Babel, ESLint, Webpack, Rollup...)，全部换 TS 成本过高，短期内并不现实。")])]),e._v(" "),t("p",[e._v("可总结为，Vue.js在做2.0重构的时候，在ES2015的基础上，除了ESLint保证代码风格之外，引入了Flow做静态类型检查。之所以选择Flow，主要是因为Babel和ESLint都有对应的 Flow插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。")]),e._v(" "),t("h2",{attrs:{id:"项目目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#项目目录"}},[e._v("#")]),e._v(" 项目目录")]),e._v(" "),t("h3",{attrs:{id:"flow"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flow"}},[e._v("#")]),e._v(" flow")]),e._v(" "),t("p",[e._v("可以看到项目中的"),t("code",[e._v(".flowconfig")]),e._v("配置文件中，有Vue的源码flow配置。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[ignore]\n.*/node_modules/.*\n.*/test/.*\n.*/scripts/.*\n.*/examples/.*\n.*/benchmarks/.*\n\n[include]\n\n[libs]\nflow\n\n[options]\nunsafe.enable_getters_and_setters=true\nmodule.name_mapper='^compiler/\\(.*\\)$' -> '<PROJECT_ROOT>/src/compiler/\\1'\nmodule.name_mapper='^core/\\(.*\\)$' -> '<PROJECT_ROOT>/src/core/\\1'\nmodule.name_mapper='^shared/\\(.*\\)$' -> '<PROJECT_ROOT>/src/shared/\\1'\nmodule.name_mapper='^web/\\(.*\\)$' -> '<PROJECT_ROOT>/src/platforms/web/\\1'\nmodule.name_mapper='^weex/\\(.*\\)$' -> '<PROJECT_ROOT>/src/platforms/weex/\\1'\nmodule.name_mapper='^server/\\(.*\\)$' -> '<PROJECT_ROOT>/src/server/\\1'\nmodule.name_mapper='^entries/\\(.*\\)$' -> '<PROJECT_ROOT>/src/entries/\\1'\nmodule.name_mapper='^sfc/\\(.*\\)$' -> '<PROJECT_ROOT>/src/sfc/\\1'\nsuppress_comment= \\\\(.\\\\|\\n\\\\)*\\\\$flow-disable-line\n\n")])])]),t("p",[e._v("我们可以看到")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("[ignore]")]),e._v("忽略对指定目录的类型检查。")]),e._v(" "),t("li",[t("code",[e._v("[libs]")]),e._v(" 配置使用库flow")]),e._v(" "),t("li",[t("code",[e._v("[options]")]),e._v("配置了项目中src目录下一些目录别名和一个注释忽略配置\n"),t("ul",[t("li",[e._v("这样可以直接使用类似"),t("code",[e._v("import Vue from 'core/index'")]),e._v("导入模块，rollup打包时，会自动识别到对应的模块")]),e._v(" "),t("li",[e._v("代码中"),t("code",[e._v("// $flow-disable-line")]),e._v("可以忽略下一行的类型检查，源码中多处使用，避免一些情况下的类型检查")])])])]),e._v(" "),t("p",[e._v("接下来我们看下到"),t("code",[e._v("flow")]),e._v("目录中的文件，详见"),t("RouterLink",{attrs:{to:"/Vue2源码探究/01.初探Vue/00.Vue2目录结构总览.html"}},[e._v("目录结构总览")]),e._v("，这里定义了Vue中自定义的类型检查配置。")],1),e._v(" "),t("p",[e._v("我们后面的源码学习中，可以根据需要，查阅类型定义，在不了解Vue代码前通读类型定义没有什么必要，也没有什么实际的意义。")]),e._v(" "),t("h3",{attrs:{id:"scripts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scripts"}},[e._v("#")]),e._v(" scripts")]),e._v(" "),t("p",[e._v("该目录为Vue源码打包构建的配置目录。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("├── scripts\n│   ├── alias.js\n│   ├── build.js\n│   ├── config.js\n│   ├── feature-flags.js\n│   ├── gen-release-note.js\n│   ├── get-weex-version.js\n│   ├── git-hooks\n│   │   ├── commit-msg\n│   │   └── pre-commit\n│   ├── release-weex.sh\n│   ├── release.sh\n│   └── verify-commit-msg.js\n")])])]),t("h3",{attrs:{id:"src"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#src"}},[e._v("#")]),e._v(" src")]),e._v(" "),t("p",[e._v("Vue的源码定义在src目录下，其结构如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("src\n├── compiler        # 编译相关 \n├── core            # 核心代码 \n├── platforms       # 不同平台的支持\n├── server          # 服务端渲染\n├── sfc             # .vue 文件解析\n├── shared          # 全局工具方法\n")])])]),t("h4",{attrs:{id:"compiler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compiler"}},[e._v("#")]),e._v(" compiler")]),e._v(" "),t("p",[e._v("Vue中一个很重要的点是VirtualDOM，虚拟DOM的生成实际上执行的是render函数。但在Vue中我们通常不会手写"),t("code",[e._v("render()")]),e._v("函数，往往会写"),t("code",[e._v("template")]),e._v("。那么template转成render的实现就在compiler目录下。")]),e._v(" "),t("p",[e._v("该目录是Vue中所有编译相关的代码。主要的作用是解析template模板成AST（抽象语法树）、AST优化、将AST转换成代码字符串，再通过处理，返回页面DOM渲染要用到的render函数。")]),e._v(" "),t("p",[e._v("编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。")]),e._v(" "),t("h4",{attrs:{id:"core"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#core"}},[e._v("#")]),e._v(" core")]),e._v(" "),t("p",[e._v("该目录包含了 Vue.js 的核心代码，包括内置组件、全局API 封装（Vue的静态属性和方法），Vue 实例化、观察者Observer、虚拟 DOM、工具函数等等。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("├── core\n│   ├── components \t\t\t# 全局内置组件\n│   ├── global-api \t\t\t# Vue静态属性和方法\n│   ├── instance \t\t\t\t# Vue原型属性和方法 -> 实例化\n│   ├── observer \t\t\t\t# 数据观察者Observer\n│   ├── util \t\t\t\t\t  # core工具函数 \n│   ├── vdom \t\t\t\t\t\t# 虚拟DOM\n│   ├── config.js \t\t\t# Vue全局默认配置\n│   └── index.js\t \t\t\t# 入口\n")])])]),t("h4",{attrs:{id:"platforms"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#platforms"}},[e._v("#")]),e._v(" platforms")]),e._v(" "),t("p",[e._v("Vue是一个跨平台的MVV 框架，它既可以在web端运行，也可以配合weex在native客户端上运行。")]),e._v(" "),t("p",[e._v("该目录是Vue的入口，2 个目录代表2个主要入口，分别打包成运行在web上和weex上的Vue.js。weex 类似于RN。我们从不同的平台入口就可以编译出不同的vue代码")]),e._v(" "),t("p",[e._v("我们会重点分析 web 入口打包后的 Vue.js，对于 weex 入口打包的 Vue.js，笔记中不会涉及到。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("├── platforms\n│   ├── web\n│   │   ├── compiler\n│   │   ├── runtime\n│   │   ├── server\n│   │   ├── util\n│   │   ├── entry-compiler.js\n│   │   ├── entry-runtime-with-compiler.js\n│   │   ├── entry-runtime.js\n│   │   ├── entry-server-basic-renderer.js\n│   │   └── entry-server-renderer.js\n")])])]),t("p",[e._v("我们可以看到，web目录下除了平台相关的编译、运行时、服务端渲染、工具函数外，还有5个"),t("code",[e._v("entry-*")]),e._v("的入口文件。")]),e._v(" "),t("h4",{attrs:{id:"server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[e._v("#")]),e._v(" server")]),e._v(" "),t("p",[e._v("该目录包含服务端渲染相关代码。学习笔记中不会涉及到。")]),e._v(" "),t("p",[e._v('服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。')]),e._v(" "),t("h4",{attrs:{id:"sfc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sfc"}},[e._v("#")]),e._v(" sfc")]),e._v(" "),t("p",[e._v("通常我们开发Vue都会借助webpack构建， 然后通过 "),t("code",[e._v(".vue")]),e._v("单文件来编写组件。")]),e._v(" "),t("p",[e._v("这个目录下的代码逻辑会把 "),t("code",[e._v(".vue")]),e._v(" 文件内容解析成一个 JavaScript 的对象。")]),e._v(" "),t("h4",{attrs:{id:"shared"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shared"}},[e._v("#")]),e._v(" shared")]),e._v(" "),t("p",[e._v("所有目录共享的一个公共方法。")]),e._v(" "),t("p",[e._v("Vue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。")]),e._v(" "),t("h3",{attrs:{id:"dist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dist"}},[e._v("#")]),e._v(" dist")]),e._v(" "),t("p",[e._v("该目录是Vue打包结果，我们开发中引用的Vue代码，来自于此。")]),e._v(" "),t("h3",{attrs:{id:"examples"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[e._v("#")]),e._v(" examples")]),e._v(" "),t("p",[e._v("该目录中是官方的一些示例代码。")]),e._v(" "),t("p",[e._v("本次学习中在目录下创建了"),t("code",[e._v("demo")]),e._v("目录，存放源码阅读的调试例子")]),e._v(" "),t("h3",{attrs:{id:"其它目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其它目录"}},[e._v("#")]),e._v(" 其它目录")]),e._v(" "),t("p",[e._v("packages、test、types、benchmarks、examples与本次学习源码阅读关系不大，详见"),t("RouterLink",{attrs:{to:"/Vue2源码探究/01.初探Vue/00.Vue2目录结构总览.html"}},[e._v("目录结构总览")])],1),e._v(" "),t("blockquote",[t("p",[e._v("benchmark 的目的主要有两种，一是验证性能，另一个是获得一些基准数据，从而可以与本软件的其他版本或其他同类软件进行比较。通常不使用benchmark做正确性验证。benchmark测试不一定会发生在每个版本的开发期间。有可能仅会在有较大改动的时候才会进行一次benchmark测试。因此频率相对单元测试来说要低很多。")])]),e._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),t("p",[e._v("从目录结构可以看出，Vue根据功能进行了清晰的模块拆分，相关的逻辑放在一个独立的目录下维护，并且把复用的代码也抽成一个独立目录。")]),e._v(" "),t("p",[e._v("这样的目录设计让代码的阅读性和可维护性都变强，是非常值得学习。")])])}),[],!1,null,null,null);t.default=a.exports}}]);