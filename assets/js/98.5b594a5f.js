(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{414:function(t,e,n){"use strict";n.r(e);var o=n(1),s=Object(o.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react学习-十二-reacthooks的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react学习-十二-reacthooks的使用"}},[t._v("#")]),t._v(" React学习（十二）——ReactHooks的使用")]),t._v(" "),e("h2",{attrs:{id:"认识hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#认识hook"}},[t._v("#")]),t._v(" 认识hook")]),t._v(" "),e("h3",{attrs:{id:"为什么需要hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要hook"}},[t._v("#")]),t._v(" 为什么需要hook")]),t._v(" "),e("p",[e("em",[t._v("Hook")]),t._v(" 是 React 16.8 的新增特性，它可以让我们在不编写class的情况下使用state以及其他的React特性（比如生命周期）。")]),t._v(" "),e("p",[t._v("我们先来思考一下"),e("code",[t._v("class组件")]),t._v("相对于"),e("code",[t._v("函数式组件")]),t._v("有什么优势？比较常见的是下面的优势：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("class组件可以定义自己的state，用来保存组件自己内部的状态；")])]),t._v(" "),e("li",[e("ul",[e("li",[t._v("函数式组件不可以，因为函数每次调用都会产生新的临时变量；")])])]),t._v(" "),e("li",[e("p",[t._v("class组件有自己的生命周期，我们可以在对应的生命周期中完成自己的逻辑；")])]),t._v(" "),e("li",[e("ul",[e("li",[t._v("比如在"),e("code",[t._v("componentDidMount")]),t._v("中发送网络请求，并且该生命周期函数只会执行一次；")]),t._v(" "),e("li",[t._v("函数式组件在学习hooks之前，如果在函数中发送网络请求，意味着每次重新渲染都会重新发送一次网络请求；")])])]),t._v(" "),e("li",[e("p",[t._v("class组件可以在状态改变时只会重新执行render函数以及我们希望重新调用的生命周期函数componentDidUpdate等；")])]),t._v(" "),e("li",[e("ul",[e("li",[t._v("函数式组件在重新渲染时，整个函数都会被执行，似乎没有什么地方可以只让它们调用一次；")])])])]),t._v(" "),e("p",[t._v("所以，在Hook出现之前，对于上面这些情况我们通常都会编写class组件。")]),t._v(" "),e("p",[e("strong",[t._v("但是class组件依然存在很多的问题：")])]),t._v(" "),e("p",[e("strong",[t._v("复杂组件变得难以理解：")])]),t._v(" "),e("ul",[e("li",[t._v("我们在最初编写一个class组件时，往往逻辑比较简单，并不会非常复杂。")]),t._v(" "),e("li",[t._v("但是随着业务的增多，我们的class组件会变得越来越复杂；")]),t._v(" "),e("li",[t._v("比如componentDidMount中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在componentWillUnmount中移除）；")]),t._v(" "),e("li",[t._v("而对于这样的class实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度；")])]),t._v(" "),e("p",[e("strong",[t._v("难以理解的class：")])]),t._v(" "),e("ul",[e("li",[t._v("很多人发现学习ES6的class是学习React的一个障碍。")]),t._v(" "),e("li",[t._v("比如在class中，我们必须搞清楚this的指向到底是谁，所以需要花很多的精力去学习this；")]),t._v(" "),e("li",[t._v("虽然我认为前端开发人员必须掌握this，但是依然处理起来非常麻烦；")])]),t._v(" "),e("p",[e("strong",[t._v("组件复用状态很难")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("在前面为了一些状态的复用我们需要通过高阶组件或render props；")]),t._v(" "),e("li",[t._v("像我们之前学习的redux中connect或者react-router中的withRouter，这些高阶组件设计的目的就是为了状态的复用；")]),t._v(" "),e("li",[t._v("或者类似于Provider、Consumer来共享一些状态，但是多次使用Consumer时，我们的代码就会存在很多嵌套；")]),t._v(" "),e("li",[t._v("这些代码让我们不管是编写和设计上来说，都变得非常困难；")])]),t._v(" "),e("p",[t._v("Hook的出现，可以解决上面提到的这些问题；")]),t._v(" "),e("p",[e("strong",[t._v("简单总结一下hooks：")])]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("它可以让我们在不编写class的情况下使用state以及其他的React特性")]),t._v("；")]),t._v(" "),e("li",[t._v("但是我们可以由此延伸出非常多的用法，来让我们前面所提到的问题得到解决；")])]),t._v(" "),e("p",[t._v("Hook的使用场景：")]),t._v(" "),e("ul",[e("li",[t._v("Hook的出现基本可以代替我们之前所有使用class组件的地方（除了一些非常不常用的场景）；")]),t._v(" "),e("li",[t._v("但是如果是一个旧的项目，你并不需要直接将所有的代码重构为Hooks，因为它完全向下兼容，你可以渐进式的来使用它；")]),t._v(" "),e("li",[t._v("Hook只能在函数组件中使用，不能在类组件，或者函数组件之外的地方使用；")])]),t._v(" "),e("p",[t._v("函数式组件结合"),e("code",[t._v("hooks")]),t._v("让整个代码变得非常简洁，并且再也不\n用考虑"),e("code",[t._v("this")]),t._v("相关的问题；")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ccbeango/blogImages/React/React%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B530.png",alt:"image-20210630102618030"}})]),t._v(" "),e("h3",{attrs:{id:"hooks的基本演练"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hooks的基本演练"}},[t._v("#")]),t._v(" hooks的基本演练")]),t._v(" "),e("p",[t._v("我们通过一个计数器案例，来对比一下class组件和函数式组件结合hooks的对比：")]),t._v(" "),e("p",[t._v("class组件实现：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { PureComponent } from 'react'\n\nexport default class App extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      counter: 0\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>当前计数 {this.state.counter}</h2>\n        <button onClick={e => this.increment()}>+1</button>\n        <button onClick={e => this.decrement()}>-1</button>\n      </div>\n    )\n  }\n\n  increment() {\n    this.setState({ counter: this.state.counter + 1 });\n  }\n\n  decrement() {\n    this.setState({ counter: this.state.counter - 1 });\n  }\n}\n")])])]),e("p",[t._v("函数式组件实现：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState } from 'react'\n\nexport default function App() {\n  const [ counter, setCounter ] = useState(0);\n\n  return (\n    <div>\n      <h2>当前计数 {counter}</h2>\n      <button onClick={e => setCounter(counter + 1)}>+1</button>\n      <button onClick={e => setCounter(counter - 1)}>-1</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("会发现上面的代码差异非常大：函数式组件结合hooks让整个代码变得非常简洁，并且再也不用考虑this相关的问题；")]),t._v(" "),e("p",[t._v("那么我们来研究一下核心的一段代码代表什么意思：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("useState来自react，需要从react中导入，它是一个hook；")])]),t._v(" "),e("li",[e("ul",[e("li",[t._v("元素一：当前状态的值（第一调用为初始化值）；")]),t._v(" "),e("li",[t._v("元素二：设置状态值的函数；")]),t._v(" "),e("li",[t._v("参数：初始化值，如果不设置为undefined；")]),t._v(" "),e("li",[t._v("返回值：数组，包含两个元素；")])])]),t._v(" "),e("li",[e("p",[t._v("点击button按钮后，会完成两件事情：")])]),t._v(" "),e("li",[e("ul",[e("li",[t._v("调用setCount，设置一个新的值；")]),t._v(" "),e("li",[t._v("组件重新渲染，并且根据新的值返回DOM结构；")])])]),t._v(" "),e("li",[e("p",[t._v("React在重新渲染时，会保留这个state状态，并不会每次都使用初始化值；")])])]),t._v(" "),e("p",[t._v("Hook 就是 JavaScript 函数，这个函数可以帮助你 "),e("code",[t._v("钩入（hook into）")]),t._v(" React State以及生命周期等特性；")]),t._v(" "),e("p",[t._v("但是使用它们会有两个额外的规则：")]),t._v(" "),e("ul",[e("li",[t._v("只能在"),e("strong",[t._v("函数最外层")]),t._v("调用 Hook。不要在循环、条件判断或者子函数中调用。")]),t._v(" "),e("li",[t._v("只能在 "),e("strong",[t._v("React 的函数组件")]),t._v("中调用 Hook。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中）。")])]),t._v(" "),e("p",[t._v("Tip：Hook指的类似于useState、useEffect这样的函数，Hooks是对这类函数的统称；")]),t._v(" "),e("h2",{attrs:{id:"hooks基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hooks基础"}},[t._v("#")]),t._v(" hooks基础")]),t._v(" "),e("h3",{attrs:{id:"state-hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#state-hook"}},[t._v("#")]),t._v(" State Hook")]),t._v(" "),e("p",[t._v("State Hook的API就是 "),e("code",[t._v("useState")]),t._v("，我们在前面已经进行了学习：")]),t._v(" "),e("ul",[e("li",[t._v("**"),e("code",[t._v("useState")]),t._v("**会帮助我们定义一个 "),e("code",[t._v("state变量")]),t._v("，"),e("code",[t._v("useState")]),t._v(" 是一种新方法，它与 class 里面的 "),e("code",[t._v("this.state")]),t._v(" 提供的功能完全相同。一般来说，在函数退出后变量就会”消失”，而 state 中的变量会被 React 保留。")]),t._v(" "),e("li",[t._v("**"),e("code",[t._v("useState")]),t._v("**接受唯一一个参数，在第一次组件被调用时使用来作为初始化值。（如果没有传递参数，那么初始化值为undefined）。")]),t._v(" "),e("li",[t._v("**"),e("code",[t._v("useState")]),t._v("**是一个数组，我们可以通过数组的解构，来完成赋值会非常方便。")])]),t._v(" "),e("p",[t._v("FAQ：为什么叫 "),e("code",[t._v("useState")]),t._v(" 而不叫 "),e("code",[t._v("createState")]),t._v("?")]),t._v(" "),e("ul",[e("li",[t._v("“Create” 可能不是很准确，因为 state 只在组件首次渲染的时候被创建。")]),t._v(" "),e("li",[t._v("在下一次重新渲染时，"),e("code",[t._v("useState")]),t._v(" 返回给我们当前的 state。")]),t._v(" "),e("li",[t._v("如果每次都创建新的变量，它就不是 “state”了。")]),t._v(" "),e("li",[t._v("这也是 Hook 的名字总是以 "),e("code",[t._v("use")]),t._v(" 开头的一个原因。")])]),t._v(" "),e("p",[t._v("当然，我们也可以在一个组件中定义多个变量和复杂变量（数组、对象）：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState } from 'react'\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n  const [age, setAge] = useState(18);\n  const [friends, setFriends] = useState(['tom', 'jack'])\n  const [students, setStudents] = useState([\n    { id: 1, name: 'ccbean', score: 96 },\n    { id: 1, name: 'jack', score: 99 },\n    { id: 1, name: 'tom', score: 97 }\n  ])\n\n  function addFriend() {\n    friends.push('lily');\n    setFriends(friends);\n  }\n\n  function setStudentAgeWithIndex(index) {\n    const newStudents = [...students];\n    newStudents[index].score += 1;\n\n    setStudents(newStudents);\n  }\n\n\n  return (\n    <div>\n      <h2>当前计数：{count}</h2>\n      <h2>我的年龄：{age}</h2>\n      <h2>好友列表</h2>\n      <ul>\n        {\n          friends.map((item, index) => (\n            <li key={index}>{item}</li>\n          ))\n        }\n      </ul>\n      <button onClick={e => setFriends([...friends, 'penny'])}>新增好友</button>\n      {/* 错误方法 */}\n      <button onClick={addFriend}>新增好友2</button>\n      <h2>学生列表</h2>\n      {\n        students.map((item, index) => (\n          <li key={item.id}>\n            学生：{item.name}\n            分数：{item.score}\n            <button onClick={e => setStudentAgeWithIndex(index)}>score + 1</button>\n          </li>\n        ))\n      }\n    </div>\n  )\n}\n")])])]),e("p",[t._v("useState也会出现和class组件中的setState都会发生state合并：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState } from 'react'\n\nexport default function App() {\n  const [ counter, setCounter ] = useState(0);\n\n  function increment10() {\n    // +40最终只会+10 react会对state进行合并\n    // setCounter(counter + 10);\n    // setCounter(counter + 10);\n    // setCounter(counter + 10);\n    // setCounter(counter + 10);\n\n    // 使用函数写法可以实现+40\n    setCounter((prevCount) => prevCount + 10);\n    setCounter((prevCount) => prevCount + 10);\n    setCounter((prevCount) => prevCount + 10);\n    setCounter((prevCount) => prevCount + 10);\n  }\n\n  return (\n    <div>\n      <h2>当前计数 {counter}</h2>\n      <button onClick={e => setCounter(counter + 1)}>+1</button>\n      <button onClick={increment10}>+10</button>\n      <button onClick={e => setCounter(counter - 1)}>-1</button>\n    </div>\n  )\n}\n")])])]),e("h3",{attrs:{id:"effect-hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#effect-hook"}},[t._v("#")]),t._v(" Effect Hook")]),t._v(" "),e("p",[t._v("目前我们已经通过hook在函数式组件中定义state，那么类似于生命周期这些呢？")]),t._v(" "),e("ul",[e("li",[t._v("Effect Hook 可以让你来完成一些类似于class中生命周期的功能；")]),t._v(" "),e("li",[t._v("事实上，类似于网络请求、手动更新DOM、一些事件的监听，都是React更新DOM的一些副作用（Side Effects）；")]),t._v(" "),e("li",[t._v("所以对于完成这些功能的Hook被称之为 Effect Hook；")])]),t._v(" "),e("h4",{attrs:{id:"effect基本使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#effect基本使用"}},[t._v("#")]),t._v(" Effect基本使用")]),t._v(" "),e("p",[t._v("假如我们现在有一个需求："),e("strong",[t._v("页面的title总是显示counter的数字")])]),t._v(" "),e("p",[t._v("使用class组件如何实现呢？")]),t._v(" "),e("ul",[e("li",[t._v("我们会发现 "),e("code",[t._v("document.title")]),t._v(" 的设置必须在两个生命周期中完成；")]),t._v(" "),e("li",[t._v("这是因为React的class组件并没有给我们提供一个统一的生命周期函数，可以让无论是否是第一次渲染都会执行的生命周期函数；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { PureComponent } from 'react'\n\nexport default class App extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    document.title = this.state.count;\n  }\n\n  componentDidUpdate() {\n    document.title = this.state.count;\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>计数： {this.state.count}</h2>\n        <button onClick={e => this.increment()}>+1</button>\n      </div>\n    )\n  }\n\n  increment() {\n    this.setState({\n      count: this.state.count + 1\n    })\n  }\n}\n")])])]),e("p",[t._v("这个时候，我们可以使用useEffect的Hook来完成：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState, useEffect } from 'react'\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = count;\n  });\n\n  return (\n    <div>\n      <h2>计数： {count}</h2>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n    </div>\n  )\n}\n")])])]),e("p",[e("strong",[t._v("useEffect的解析：")])]),t._v(" "),e("ul",[e("li",[t._v("通过useEffect的Hook，可以告诉React需要在渲染后执行某些操作；")]),t._v(" "),e("li",[t._v("useEffect要求我们传入一个"),e("code",[t._v("回调函数")]),t._v("，在React执行完更新DOM操作之后，就"),e("code",[t._v("会回调这个函数")]),t._v("；")]),t._v(" "),e("li",[t._v("默认情况下，无论是第一次渲染之后，还是每次更新之后，都会执行这个 "),e("code",[t._v("回调函数")]),t._v("；")])]),t._v(" "),e("h4",{attrs:{id:"需要清除effect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#需要清除effect"}},[t._v("#")]),t._v(" 需要清除Effect")]),t._v(" "),e("p",[t._v("在class组件的编写过程中，某些副作用的代码，我们需要在componentWillUnmount中进行清除：")]),t._v(" "),e("ul",[e("li",[t._v("比如我们之前的事件总线或Redux中手动调用subscribe；")]),t._v(" "),e("li",[t._v("都需要在componentWillUnmount有对应的取消订阅；")]),t._v(" "),e("li",[t._v("Effect Hook通过什么方式来模拟componentWillUnmount呢？")])]),t._v(" "),e("p",[t._v("useEffect传入的"),e("code",[t._v("回调函数A本身")]),t._v("可以有一个返回值，这个返回值是"),e("code",[t._v("另外一个回调函数B")]),t._v("：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type EffectCallback = () => (void | (() => void | undefined));\n")])])]),e("p",[t._v("我们可以这样来编写Effect Hook：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import React, { useState, useEffect } from \'react\';\n\nexport default function EffectHookClear() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `当前计数: ${count}`;\n    console.log("每次DOM更新时会回调");\n\n    return () => {\n      console.log("DOM被移除时会回调");\n    }\n  })\n\n  return (\n    <div>\n      <h2>当前计数: {count}</h2>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      <button onClick={e => setCount(count - 1)}>-1</button>\n    </div>\n  )\n}\n')])])]),e("p",[e("strong",[t._v("为什么要在 effect 中返回一个函数？")])]),t._v(" "),e("ul",[e("li",[t._v("这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数；")]),t._v(" "),e("li",[t._v("如此可以将添加和移除订阅的逻辑放在一起；")]),t._v(" "),e("li",[t._v("它们都属于 effect 的一部分；")])]),t._v(" "),e("p",[e("strong",[t._v("React 何时清除 effect？")])]),t._v(" "),e("ul",[e("li",[t._v("React 会在组件更新和卸载的时候执行清除操作；")]),t._v(" "),e("li",[t._v("正如之前学到的，effect 在每次渲染的时候都会执行；")])]),t._v(" "),e("h4",{attrs:{id:"使用多个effect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用多个effect"}},[t._v("#")]),t._v(" 使用多个Effect")]),t._v(" "),e("p",[t._v("使用Hook的其中一个目的就是解决class中生命周期经常将很多的逻辑放在一起的问题：")]),t._v(" "),e("ul",[e("li",[t._v("比如网络请求、事件监听、手动修改DOM，这些往往都会放在componentDidMount中；")])]),t._v(" "),e("p",[t._v("使用Effect Hook，我们可以将它们分离到不同的useEffect中：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import React, { useEffect } from \'react\';\n\nexport default function MultiUseEffect() {\n  useEffect(() => {\n    console.log("网络请求");\n  });\n\n  useEffect(() => {\n    console.log("修改DOM");\n  })\n\n  useEffect(() => {\n    console.log("事件监听");\n\n    return () => {\n      console.log("取消监听");\n    }\n  })\n\n  return (\n    <div>\n      <h2>MultiUseEffect</h2>\n    </div>\n  )\n}\n')])])]),e("p",[e("strong",[t._v("Hook 允许我们按照代码的用途分离它们，")]),t._v(" 而不是像生命周期函数那样：")]),t._v(" "),e("ul",[e("li",[t._v("React 将按照 effect 声明的顺序依次调用组件中的"),e("em",[t._v("每一个")]),t._v(" effect；")])]),t._v(" "),e("h4",{attrs:{id:"effect性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#effect性能优化"}},[t._v("#")]),t._v(" Effect性能优化")]),t._v(" "),e("p",[t._v("默认情况下，useEffect的回调函数会在每次渲染时都重新执行，但是这会导致两个问题：")]),t._v(" "),e("ul",[e("li",[t._v("某些代码我们只是希望执行一次即可，类似于componentDidMount和componentWillUnmount中完成的事情；（比如网络请求、订阅和取消订阅）；")]),t._v(" "),e("li",[t._v("另外，多次执行也会导致一定的性能问题；")])]),t._v(" "),e("p",[t._v("我们如何决定useEffect在什么时候应该执行和什么时候不应该执行呢？")]),t._v(" "),e("ul",[e("li",[t._v("useEffect实际上有两个参数：")]),t._v(" "),e("li",[t._v("参数一：执行的回调函数；")]),t._v(" "),e("li",[t._v("参数二：该useEffect在哪些state发生变化时，才重新执行；（受谁的影响）")])]),t._v(" "),e("p",[t._v("我们来看下面的一个案例：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState, useEffect } from 'react'\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n  const [isLogin, setIsLogin] = useState(true);\n  useEffect(() => {\n    console.log('修改dom');\n  }, [count]);\n\n  useEffect(() => {\n    console.log('订阅事件')\n  }, []);\n\n  useEffect(() => {\n    console.log('网络请求')\n  }, [isLogin]);\n\n  return (\n    <div>\n      <h2>计数：{count}</h2>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      <h2>{ isLogin ? 'ccbean' : '请登录' }</h2>\n      <button onClick={e => setIsLogin(!isLogin)}>登录/注销</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("计数器的effect只会在count发生变化时进行调用；网络请求只会在isLogin发生变化时进行调用；")]),t._v(" "),e("p",[t._v("如果一个函数我们不希望依赖任何的内容时，也可以传入一个空的数组 []：")]),t._v(" "),e("ul",[e("li",[t._v("那么这里的两个回调函数分别对应的就是componentDidMount和componentWillUnmount生命周期函数了；")])]),t._v(" "),e("h3",{attrs:{id:"context-hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#context-hook"}},[t._v("#")]),t._v(" Context Hook")]),t._v(" "),e("p",[t._v("在之前的开发中，我们要在组件中使用共享的Context有两种方式：")]),t._v(" "),e("ul",[e("li",[t._v("类组件可以通过 "),e("code",[t._v("类名.contextType = MyContext")]),t._v("方式，在类中获取context；")]),t._v(" "),e("li",[t._v("多个Context或者在函数式组件中通过 "),e("code",[t._v("MyContext.Consumer")]),t._v(" 方式共享context；")])]),t._v(" "),e("p",[t._v("但是多个Context共享时的方式会存在大量的嵌套：")]),t._v(" "),e("ul",[e("li",[t._v("Context Hook允许我们通过Hook来直接获取某个Context的值；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const value = useContext(MyContext);\n")])])]),e("p",[t._v("在App.js中使用Context")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { createContext } from 'react';\nimport App01 from './01_useContext的使用';\n\nexport const UserContext = createContext();\nexport const ThemeContext = createContext();\n\nexport default function App() {\n  return (\n    <ThemeContext.Provider value={{ color: 'red' }}>\n      <UserContext.Provider value={{ name: 'ccbean' }}>\n        <App01/>\n      </UserContext.Provider>\n    </ThemeContext.Provider>\n  )\n}\n\n")])])]),e("p",[t._v("在对应的函数式组件中使用Context Hook：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useContext } from 'react'\nimport { UserContext, ThemeContext } from './index';\n\nexport default function App() {\n  const user = useContext(UserContext);\n  const theme = useContext(ThemeContext);\n\n  return (\n    <div>\n      <h2>user: {JSON.stringify(user)}</h2>\n      <h2>theme: {JSON.stringify(theme)}</h2>\n    </div>\n  );\n}\n")])])]),e("p",[t._v("注意事项：当组件上层最近的 "),e("code",[t._v("<MyContext.Provider>")]),t._v(" 更新时，该 Hook 会触发重新渲染，并使用最新传递给 "),e("code",[t._v("MyContext")]),t._v(" provider 的 context "),e("code",[t._v("value")]),t._v(" 值。")]),t._v(" "),e("h3",{attrs:{id:"usereducer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usereducer"}},[t._v("#")]),t._v(" useReducer")]),t._v(" "),e("p",[t._v("很多人看到useReducer的第一反应应该是redux的某个替代品，其实并不是。")]),t._v(" "),e("p",[t._v("useReducer仅仅是useState的一种替代方案：")]),t._v(" "),e("ul",[e("li",[t._v("在某些场景下，如果state的处理逻辑比较复杂，我们可以通过useReducer来对其进行拆分；")]),t._v(" "),e("li",[t._v("或者这次修改的state需要依赖之前的state时，也可以使用；")])]),t._v(" "),e("p",[t._v("单独创建一个reducer/counter.js文件：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('export function counterReducer(state, action) {\n  switch(action.type) {\n    case "increment":\n      return {...state, counter: state.counter + 1}\n    case "decrement":\n      return {...state, counter: state.counter - 1}\n    default:\n      return state;\n  }\n}\n')])])]),e("p",[t._v("home.js")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useReducer } from 'react'\nimport { counterReducer } from '../reducer/counter'\n\nexport default function Home() {\n  const [state, dispatch] = useReducer(counterReducer, {counter: 100});\n\n  return (\n    <div>\n      <h2>当前计数: {state.counter}</h2>\n      <button onClick={e => dispatch({type: \"increment\"})}>+1</button>\n      <button onClick={e => dispatch({type: \"decrement\"})}>-1</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("我们来看一下，如果我们创建另外一个profile.js也使用这个reducer函数，是否会进行数据的共享：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useReducer } from 'react'\nimport { counterReducer } from '../reducer/counter'\n\nexport default function Profile() {\n  const [state, dispatch] = useReducer(counterReducer, {counter: 0});\n\n  return (\n    <div>\n      <h2>当前计数: {state.counter}</h2>\n      <button onClick={e => dispatch({type: \"increment\"})}>+1</button>\n      <button onClick={e => dispatch({type: \"decrement\"})}>-1</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("数据是不会共享的，它们只是使用了相同的counterReducer的函数而已。")]),t._v(" "),e("p",[e("strong",[t._v("所以，useReducer只是useState的一种替代品，并不能替代Redux。")])]),t._v(" "),e("h3",{attrs:{id:"usecallback"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[t._v("#")]),t._v(" useCallback")]),t._v(" "),e("p",[t._v("useCallback实际的目的是为了进行性能的优化。")]),t._v(" "),e("p",[t._v("如何进行性能的优化呢？")]),t._v(" "),e("ul",[e("li",[t._v("useCallback会返回一个函数的 memoized（记忆的） 值；")]),t._v(" "),e("li",[t._v("在依赖不变的情况下，多次定义的时候，返回的值是相同的；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const memoizedCallback = useCallback(\n  () => {\n    doSomething(a, b);\n  },\n  [a, b]\n);\n")])])]),e("p",[t._v("我们来看下面一段很有趣的代码：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("increment1在每次函数组件重新渲染时，会返回相同的值；")])]),t._v(" "),e("li",[e("p",[t._v("increment2每次定义的都是不同的值；")])]),t._v(" "),e("li",[e("p",[t._v("问题：是否increment1会比increment2更加节省性能呢？")])]),t._v(" "),e("li",[e("ul",[e("li",[t._v("事实上，经过一些测试，并没有更加节省内存，因为useCallback中还是会传入一个函数作为参数；")]),t._v(" "),e("li",[t._v("increment1和increment2中都有函数的创建过程，创建了相同的函数，所以并不存在increment2每次创建新的函数，而increment1不需要创建新的函数这种性能优化；")])])]),t._v(" "),e("li",[e("p",[t._v("那么，为什么说useCallback是为了进行性能优化呢？")])])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { memo, useState, useCallback } from 'react'\n\nexport default function CallbackHookDemo() {\n  const [count, setCount] = useState(0);\n\n  const increment1 = useCallback(function increment() {\n    setCount(count + 1);\n  }, []);\n\n  const increment2 = function() {\n    setCount(count + 1);\n  }\n\n  return (\n    <div>\n      <h2>当前计数: {count}</h2>\n      <button onClick={increment1}>+1</button>\n      <button onClick={increment2}>+1</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("我们来对上面的代码进行改进：")]),t._v(" "),e("ul",[e("li",[t._v("在下面的代码中，我们将回调函数传递给了子组件，在子组件中会进行调用；")]),t._v(" "),e("li",[t._v("在发生点击时，我们会发现接受increment1的子组件不会重新渲染，但是接受increment2的子组件会重新渲染。因为由于使用useCallback对increment1进行包裹，其只在初次挂载和count发生改变时，才会有所改变，否则返回值是不发生变化的，即increment1返回memoized 版本。")]),t._v(" "),e("li",[t._v("所以useCallback最主要用于性能渲染的地方应该是和memo结合起来，决定子组件是否需要重新渲染；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { memo, useState, useCallback } from 'react'\n\nconst HYButton = memo((props) => {\n  console.log('HyButton渲染' + props.title)\n  return (\n    <button onClick={props.increment}>HYButton + 1</button>\n  );\n});\n\nexport default function CallbackHookDemo() {\n  console.log('CallbackHookDemo重新渲染');\n  const [count, setCount] = useState(0);\n  const [show, setShow] = useState(true);\n\n  const increment1 = useCallback(function increment() {\n    setCount(count + 1);\n  }, [count]);\n\n  const increment2 = function() {\n    setCount(count + 1);\n  }\n\n  return (\n    <div>\n      <button onClick={e => setShow(!show)}>切换</button>\n      <h2>当前计数: {count}</h2>\n      <HYButton title='btn1' increment={increment1} />\n      <HYButton title='btn2' increment={increment2} />\n    </div>\n  )\n}\n")])])]),e("p",[t._v("通常使用"),e("code",[t._v("useCallback")]),t._v("的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存。所以，"),e("code",[t._v("useCallback")]),t._v("的使用场景是：在一个组件中的函数，传递给子元素进行回调使用时，使用"),e("code",[t._v("useCallback")]),t._v("对函数进行处理，避免子组件不必要的渲染，提升性能。")]),t._v(" "),e("h3",{attrs:{id:"usememo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usememo"}},[t._v("#")]),t._v(" useMemo")]),t._v(" "),e("p",[t._v("useMemo实际的目的也是为了进行性能的优化。")]),t._v(" "),e("p",[t._v("如何进行性能的优化呢？")]),t._v(" "),e("ul",[e("li",[t._v("useMemo返回的也是一个 memoized（记忆的） 值；")]),t._v(" "),e("li",[t._v("在依赖不变的情况下，多次定义的时候，返回的值是相同的；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n")])])]),e("p",[t._v("我们来看一个案例：")]),t._v(" "),e("ul",[e("li",[t._v("无论我们点击了是 "),e("code",[t._v("+1")]),t._v("还是 "),e("code",[t._v("切换")]),t._v(" 案例都会重新计算一次；")]),t._v(" "),e("li",[t._v("事实上，我们只是希望在count发生变化时重新计算；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { memo, useState, useCallback, useMemo } from 'react'\n\nconst calcTotal = (count) => {\n  console.log('计算总数')\n  return (1 + count) * count / 2; \n}\n\nexport default function CallbackHookDemo() {\n  const [count, setCount] = useState(0);\n  const [show, setShow] = useState(true);\n\n  // 点击切换也会计算\n  const total = calcTotal(count);\n\n  return (\n    <div>\n      <button onClick={e => setShow(!show)}>切换</button>\n      <h2>总计: {total}</h2>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("这个时候，我们可以使用useMemo来进行性能的优化：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { memo, useState, useCallback, useMemo } from 'react'\n\nconst calcTotal = (count) => {\n  console.log('计算总数')\n  return (1 + count) * count / 2; \n}\n\nexport default function CallbackHookDemo() {\n  const [count, setCount] = useState(0);\n  const [show, setShow] = useState(true);\n\n  const total = useMemo(() => {\n    return calcTotal(count); \n  }, [count]);\n\n\n  return (\n    <div>\n      <button onClick={e => setShow(!show)}>切换</button>\n      <h2>总计: {total}</h2>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("当然，useMemo也可以用于子组件的性能优化：")]),t._v(" "),e("ul",[e("li",[t._v("ShowCounter子组件依赖的是一个基本数据类型，所以在比较的时候只要值不变，那么就不会重新渲染；")]),t._v(" "),e("li",[t._v("ShowInfo接收的是一个对象，每次都会定义一个新的对象，所以我们需要通过useMemo来对其进行优化；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { memo, useState, useMemo } from 'react'\n\nfunction calcNum(count) {\n  let total = 0;\n  for (let i = 0; i < count; i++) {\n    total += i;\n  }\n  console.log(\"计算一遍\");\n  return total\n}\n\nconst ShowCounter = memo((props) => {\n  console.log(\"重新渲染\");\n  return <h1>Counter: {props.total}</h1>\n})\n\nconst ShowInfo = memo((props) => {\n  console.log(\"ShowInfo重新渲染\");\n  return <h2>名字：{props.info.name} 年龄：{props.info.age}</h2>\n})\n\nexport default function MemoHookDemo() {\n  const [count, setCount] = useState(10);\n  const [isLogin, setIsLogin] = useState(true);\n\n  const total = useMemo(() => {\n    return calcNum(count);\n  }, [count]);\n\n  // 局部变量 每次点击切换都会渲染 可以使用useState解决\n  // const info = { name: 'ccbean', age: 18 };\n  // 使用useMemo\n  const info = useMemo(() => {\n    return { name: 'ccbean', age: 18 };\n  }, [])\n\n  return (\n    <div>\n      <button onClick={e => setIsLogin(!isLogin)}>切换</button>\n      <h2>数字和: {total}</h2>\n      <ShowCounter total={total} />\n      <ShowInfo info={info}/>\n      <button onClick={e => setCount(count + 1)}>+1</button>\n      {isLogin && <h2>Coderwhy</h2>}\n    </div>\n  )\n}\n")])])]),e("p",[e("code",[t._v("useMemo")]),t._v("的返回值是值，永远是对返回值来做优化的，返回之可以是基本数据类型、对象类型，也可以是函数类型；"),e("code",[t._v("useCallback")]),t._v("只是针对函数进行优化，它返回的是一个函数。")]),t._v(" "),e("p",[e("code",[t._v("useCallback(fn, deps)")]),t._v(" 相当于 "),e("code",[t._v("useMemo(() => fn, deps)")]),t._v("。即相当于"),e("code",[t._v("useMemo")]),t._v("的返回值是函数。")]),t._v(" "),e("p",[t._v("我们看具体的例子：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { memo, useState, useCallback, useMemo } from 'react'\n\nconst HYButton = memo((props) => {\n  console.log('HyButton渲染' + props.title)\n  return (\n    <button onClick={props.increment}>HYButton + 1</button>\n  );\n});\n\nexport default function App() {\n  console.log('CallbackHookDemo重新渲染');\n  const [count, setCount] = useState(0);\n  const [show, setShow] = useState(true);\n\n  const increment1 = useCallback(() => {\n    setCount(count + 1);\n  }, [count]);\n  // useMemo实现useCallback\n  const increment2 = useMemo(() => {\n    return () => {\n      setCount(count + 1);\n    }\n  }, [count]);\n\n  return (\n    <div>\n      <button onClick={e => setShow(!show)}>切换</button>\n      <h2>当前计数: {count}</h2>\n      <HYButton title='btn1' increment={increment1} />\n      <HYButton title='btn2' increment={increment2} />\n    </div>\n  )\n}\n")])])]),e("p",[e("code",[t._v("increment1")]),t._v("和"),e("code",[t._v("increment2")]),t._v("分别使用useCallback和useMemo实现，可以看到"),e("code",[t._v("increment2")]),t._v("其实就是返回了"),e("code",[t._v("increment1")]),t._v("中的回调函数。")]),t._v(" "),e("h3",{attrs:{id:"useref"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#useref"}},[t._v("#")]),t._v(" useRef")]),t._v(" "),e("p",[t._v("useRef返回一个ref对象，返回的ref对象在组件的整个生命周期保持不变。")]),t._v(" "),e("p",[t._v("最常用的ref是两种用法：")]),t._v(" "),e("ul",[e("li",[t._v("用法一：引入DOM（或者组件，但是需要是class组件）元素；")]),t._v(" "),e("li",[t._v("用法二：保存一个数据，这个对象在整个生命周期中可以保存不变；")])]),t._v(" "),e("p",[t._v("用法一：引用DOM")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useRef, useState } from 'react';\n\nclass TestCpn extends React.Component {\n  render() {\n    return (\n      <h2>TestCpn</h2>\n    );\n  }\n}\n\nfunction TestCpn2() {\n  return (\n    <h2>TestCpn2</h2>\n  );\n}\n\nexport default function App() {\n  const [show, setShow] = useState(true);\n  const titleRef = useRef();\n  const inputRef = useRef();\n  const testCpnRef = useRef();\n  const testCpnRef2 = useRef(); // 报错\n\n  function changeDOM() {\n    titleRef.current.innerHTML = 'Hello React';\n    inputRef.current.focus();\n    console.log(testCpnRef);\n  }\n\n  return (\n    <div>\n      <button onClick={e => setShow(!show)}>切换</button>\n      <h2 ref={titleRef}>Hello World</h2>\n      <input ref={inputRef} type=\"text\" />\n      <TestCpn ref={testCpnRef}/>\n      <TestCpn2 ref={testCpnRef2}/>\n      <button onClick={changeDOM}>修改DOM</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("用法二：使用ref保存上一次的某一个值")]),t._v(" "),e("ul",[e("li",[t._v("useRef可以想象成在ref对象中保存了一个.current的可变盒子；")]),t._v(" "),e("li",[t._v("useRef在组件重新渲染时，返回的依然是之前的ref对象，但是current是可以修改的；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useRef, useState } from 'react'\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  const countRef = useRef(count);\n\n  return (\n    <div>\n      <h2>useRef中的值：{countRef.current}</h2>\n      <h2>count中的值：{count}</h2>\n      <button onClick={e => setCount(count + 10)}>+10</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("这里可以看到countRef中的值是一直不变的，永远都是初始值"),e("code",[t._v("0")]),t._v("。")]),t._v(" "),e("p",[t._v("我们使用useRef实现一个例子，每次点击+10按钮，都会显示上次的值和当前值：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useRef, useState, useEffect } from 'react';\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  const countRef = useRef(count);\n\n  useEffect(() => {\n    countRef.current = count;\n  }, [count]);\n\n  return (\n    <div>\n      <h2>useRef中的值：{countRef.current}</h2>\n      <h2>count中的值：{count}</h2>\n      <button onClick={e => setCount(count + 10)}>+10</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("上面的代码中，每次+10进行渲染时，count值发生了修改，但因为countRef整个生命周期中useRef中的值保持不变，所以渲染时，count值是最新的，而countRef中的值是没有变化的。渲染完成后，"),e("code",[t._v("useEffect")]),t._v("中副作用修改"),e("code",[t._v("countRef.current")]),t._v("中的值，记录此次渲染时的"),e("code",[t._v("count")]),t._v("值；所以它的记录值正好就是上次的"),e("code",[t._v("count")]),t._v("值。")]),t._v(" "),e("h3",{attrs:{id:"useimperativehandle"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#useimperativehandle"}},[t._v("#")]),t._v(" useImperativeHandle")]),t._v(" "),e("p",[t._v("我们先来回顾一下ref和forwardRef结合使用：")]),t._v(" "),e("ul",[e("li",[t._v("通过forwardRef可以将ref转发到子组件；")]),t._v(" "),e("li",[t._v("子组件拿到父组件中创建的ref，绑定到自己的某一个元素中；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { forwardRef, useRef } from 'react';\n\nconst HYInput = forwardRef((props, ref) => {\n  return (\n    <input ref={ref} type=\"text\"/>\n  );\n})\n\nexport default function App() {\n  const inputRef = useRef();\n\n  return (\n    <div>\n      <HYInput ref={inputRef}/>\n      <button onClick={e => inputRef.current.focus()}>聚焦</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("上面的做法本身没有什么问题，但是我们是将子组件的DOM直接暴露给了父组件：")]),t._v(" "),e("ul",[e("li",[t._v("直接暴露给父组件带来的问题是某些情况的不可控；")]),t._v(" "),e("li",[t._v("父组件可以拿到DOM后进行任意的操作；")]),t._v(" "),e("li",[t._v("但是，事实上在上面的案例中，我们只是希望父组件可以操作的focus，其他并不希望它随意操作；")])]),t._v(" "),e("p",[t._v("通过useImperativeHandle可以只暴露固定的操作：")]),t._v(" "),e("ul",[e("li",[t._v("通过useImperativeHandle的Hook，将"),e("code",[t._v("传入的ref")]),t._v("和"),e("code",[t._v("useImperativeHandle第二个参数返回的对象")]),t._v("绑定到了一起；")]),t._v(" "),e("li",[t._v("所以在父组件中，使用 "),e("code",[t._v("inputRef.current")]),t._v("时，实际上使用的是useImperativeHandle"),e("code",[t._v("返回的对象")]),t._v("；")]),t._v(" "),e("li",[t._v("比如我调用了 "),e("code",[t._v("focus函数")]),t._v("，甚至可以调用 "),e("code",[t._v("printHello函数")]),t._v("；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { forwardRef, useImperativeHandle, useRef } from 'react';\n\nconst HYInput = forwardRef((props, ref) => {\n  // 子组件的ref\n  const inputRef = useRef();\n  // 只对外面使用的ref暴露需要的方法\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    },\n    printHello: () => {\n      console.log('hello world')\n    }\n  }), [ inputRef.current ]);\n\n  return (\n    <input ref={inputRef} type=\"text\"/>\n  );\n})\n\nexport default function App() {\n  const inputRef = useRef();\n\n  return (\n    <div>\n      <HYInput ref={inputRef}/>\n      <button onClick={e => inputRef.current.focus()}>聚焦</button>\n      <button onClick={e => inputRef.current.printHello()}>Hello World</button>\n    </div>\n  )\n}\n")])])]),e("h3",{attrs:{id:"uselayouteffect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#uselayouteffect"}},[t._v("#")]),t._v(" useLayoutEffect")]),t._v(" "),e("p",[t._v("useLayoutEffect看起来和useEffect非常的相似，事实上他们也只有一点区别而已：")]),t._v(" "),e("ul",[e("li",[t._v("useEffect会在渲染的内容更新到DOM上后执行，不会阻塞DOM的更新；")]),t._v(" "),e("li",[t._v("useLayoutEffect会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新；")])]),t._v(" "),e("p",[t._v("如果我们希望在某些操作发生之后再更新DOM，那么应该将这个操作放到useLayoutEffect。")]),t._v(" "),e("p",[t._v("两者的渲染流程如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/ccbeango/blogImages/React/React%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B531.png",alt:"image-20210701123459020"}})]),t._v(" "),e("p",[t._v("我们来看下面的一段代码：")]),t._v(" "),e("ul",[e("li",[t._v("这段代码在开发中会发生闪烁的现象；")]),t._v(" "),e("li",[t._v("因为我们先将count设置为了8，那么DOM会被更新，并且会执行一次useEffect中的回调函数；")]),t._v(" "),e("li",[t._v("在useEffect中我们发现count为8，又执行一次setCount操作，那么DOM会再次被更新，并且useEffect又会被执行一次；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState, useEffect } from 'react'\n\nexport default function App() {\n  const [count, setCount] = useState(10);\n  \n  useEffect(() => {\n    if (count === 8) {\n      setCount(Math.random());\n    }\n  });\n  \n  return (\n    <div>\n      <h2>数字：{count}</h2>\n      <button onClick={e => setCount(8)}>修改</button>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("事实上，我们上面的操作的目的是在count被设置为8时，随机另外一个数字：")]),t._v(" "),e("ul",[e("li",[t._v("如果我们使用useLayoutEffect，那么会等到useLayoutEffect代码执行完毕后，再进行DOM的更新；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useState, useLayoutEffect } from 'react'\n\nexport default function App() {\n  const [count, setCount] = useState(10);\n  \n  useLayoutEffect(() => {\n    if (count === 8) {\n      setCount(Math.random());\n    }\n  });\n  \n  return (\n    <div>\n      <h2>数字：{count}</h2>\n      <button onClick={e => setCount(8)}>修改</button>\n    </div>\n  )\n}\n")])])]),e("h2",{attrs:{id:"自定义hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义hook"}},[t._v("#")]),t._v(" 自定义Hook")]),t._v(" "),e("h3",{attrs:{id:"认识自定义hook"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#认识自定义hook"}},[t._v("#")]),t._v(" 认识自定义hook")]),t._v(" "),e("p",[e("strong",[t._v("自定义Hook本质上只是一种函数代码逻辑的抽取，严格意义上来说，它本身并不算React的特性。")])]),t._v(" "),e("p",[t._v("需求：所有的组件在创建和销毁时都进行打印")]),t._v(" "),e("ul",[e("li",[t._v("组件被创建：打印 "),e("code",[t._v("组件被创建了")]),t._v("；")]),t._v(" "),e("li",[t._v("组件被销毁：打印 "),e("code",[t._v("组件被销毁了")]),t._v("；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('export default function CustomHookDemo() {\n  useEffect(() => {\n    console.log("组件被创建了");\n    return () => {\n      console.log("组件被销毁了");\n    }\n  }, [])\n\n  return (\n    <div>\n      <h2>CustomHookDemo</h2>\n    </div>\n  )\n}\n')])])]),e("p",[t._v("但是这样来做意味着所有的组件都需要有对应的逻辑：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function Home(props) {\n  useEffect(() => {\n    console.log("组件被创建了");\n    return () => {\n      console.log("组件被销毁了");\n    }\n  }, [])\n  return <h2>Home</h2>\n}\n\nfunction Profile(props) {\n  useEffect(() => {\n    console.log("组件被创建了");\n    return () => {\n      console.log("组件被销毁了");\n    }\n  }, [])\n  return <h2>Profile</h2>\n}\n')])])]),e("p",[t._v("如何可以对它们的逻辑进行抽取呢？")]),t._v(" "),e("ul",[e("li",[t._v("非常简单，函数以特殊的方式命名，以 "),e("code",[t._v("use")]),t._v(" 开头即可；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function useLoggingLife() {\n  useEffect(() => {\n    console.log("组件被创建了");\n    return () => {\n      console.log("组件被销毁了");\n    }\n  }, [])\n}\n')])])]),e("p",[t._v("当然，自定义Hook可以有参数，也可以有返回值：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function useLoggingLife(name) {\n  useEffect(() => {\n    console.log(`${name}组件被创建了`);\n    return () => {\n      console.log(`${name}组件被销毁了`);\n    }\n  }, [])\n}\n")])])]),e("h3",{attrs:{id:"自定义hook练习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义hook练习"}},[t._v("#")]),t._v(" 自定义Hook练习")]),t._v(" "),e("p",[t._v("我们通过一些案例来练习一下自定义Hook。")]),t._v(" "),e("p",[e("strong",[t._v("使用User、Token的Context")])]),t._v(" "),e("p",[t._v("比如多个组件都需要使用User和Token的Context：")]),t._v(" "),e("ul",[e("li",[t._v("这段代码我们在每次使用user和token时都需要导入对应的Context，并且需要使用两次useContext；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React, { useContext } from 'react'\nimport { UserContext, TokenContext } from './index'\nimport useUserToken from './hooks/user-hook'; \n\nexport default function CustomHookContextDemo() {\n  const user = useContext(UserContext);\n  const token = useContext(TokenContext);\n\n  console.log(user, token);\n\n  const a = useUserToken();\n  console.log(a);\n\n  return (\n    <div>\n      <h2>CustomHookContextDemo</h2>\n    </div>\n  )\n}\n")])])]),e("p",[t._v("我们可以抽取到一个自定义Hook中：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" useContext "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" UserContext"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" TokenContext "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'../'")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("useUserToken")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" user "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("useContext")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("UserContext"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" token "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("useContext")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("TokenContext"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("user"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" token"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[e("strong",[t._v("获取窗口滚动的位置")])]),t._v(" "),e("p",[t._v("在开发中，某些场景我们可能总是希望获取创建滚动的位置：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import React, { useEffect, useState } from \'react\'\n\nexport default function CustomScrollPositionHook() {\n\n  const [scrollPosition, setScrollPosition] = useState(0);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      setScrollPosition(window.scrollY);\n    }\n    document.addEventListener("scroll", handleScroll);\n\n    return () => {\n      document.removeEventListener("scroll", handleScroll);\n    }\n  }, [])\n\n  return (\n    <div style={{padding: "1000px 0"}}>\n      <h2 style={{position: "fixed", top: 0, left: 0}}>CustomScrollPositionHook: {scrollPosition}</h2>\n    </div>\n  )\n}\n')])])]),e("p",[t._v("但是如果每一个组件都有对应这样的一个逻辑，那么就会存在很多的冗余代码：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function useScrollPosition() {\n  const [scrollPosition, setScrollPosition] = useState(0);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      setScrollPosition(window.scrollY);\n    }\n    document.addEventListener("scroll", handleScroll);\n\n    return () => {\n      document.removeEventListener("scroll", handleScroll);\n    }\n  }, [])\n\n  return scrollPosition;\n}\n')])])]),e("p",[e("strong",[t._v("数据存储的localStorage")])]),t._v(" "),e("p",[t._v("在开发中，我们会有一些数据希望通过localStorage进行存储（当然，你可以根据自己的情况选择sessionStorage）")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import React, { useState, useEffect } from \'react\'\n\nexport default function CustomDataStoreHook() {\n  const [name, setName] = useState(() => {\n    return JSON.parse(window.localStorage.getItem("name"))\n  });\n\n  useEffect(() => {\n    window.localStorage.setItem("name", JSON.stringify(name));\n  }, [name])\n\n  return (\n    <div>\n      <h2>CustomDataStoreHook: {name}</h2>\n      <button onClick={e => setName("coderwhy")}>设置name</button>\n    </div>\n  )\n}\n')])])]),e("p",[t._v("如果每一个里面都有这样的逻辑，那么代码就会变得非常冗余：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function useLocalStorange(key) {\n  const [data, setData] = useState(() => {\n    return JSON.parse(window.localStorage.getItem(key))\n  });\n\n  useEffect(() => {\n    window.localStorage.setItem(key, JSON.stringify(data));\n  }, [data]);\n\n  return [data, setData];\n}\n")])])]),e("h2",{attrs:{id:"redux-hooks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redux-hooks"}},[t._v("#")]),t._v(" Redux Hooks")]),t._v(" "),e("p",[t._v("在之前的redux开发中，为了让组件和redux结合起来，我们使用了react-redux中的connect：")]),t._v(" "),e("ul",[e("li",[t._v("但是这种方式必须使用"),e("code",[t._v("高阶函数")]),t._v("结合返回的"),e("code",[t._v("高阶组件")]),t._v("；")]),t._v(" "),e("li",[t._v("并且必须编写："),e("code",[t._v("mapStateToProps")]),t._v("和 "),e("code",[t._v("mapDispatchToProps")]),t._v("映射的函数；")])]),t._v(" "),e("p",[t._v("在Redux7.1开始，提供了Hook的方式，我们再也不需要编写connect以及对应的映射函数了")]),t._v(" "),e("h3",{attrs:{id:"_4-1-useselector使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-useselector使用"}},[t._v("#")]),t._v(" 4.1. useSelector使用")]),t._v(" "),e("p",[t._v("useSelector的作用是将state映射到组件中：")]),t._v(" "),e("ul",[e("li",[t._v("参数一：将state映射到需要的数据中；")]),t._v(" "),e("li",[t._v("参数二：可以进行比较来决定是否组件重新渲染；（后续讲解）")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const result: any = useSelector(selector: Function, equalityFn?: Function)\n")])])]),e("p",[t._v("现在，我可以改进一下之前的Profile中使用redux的代码：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function Profile(props) {\n  const {banners, recommends, counter} = useSelector(state => ({\n    banners: state.homeInfo.banners,\n    recommends: state.homeInfo.recommends\n  }));\n\n  console.log("Profile重新渲染");\n\n  return (\n    <div>\n      <h2>数字: {counter}</h2>\n      <h1>Banners</h1>\n      <ul>\n        {\n          banners.map((item, index) => {\n            return <li key={item.acm}>{item.title}</li>\n          })\n        }\n      </ul>\n      <h1>Recommends</h1>\n      <ul>\n        {\n          recommends.map((item, index) => {\n            return <li key={item.acm}>{item.title}</li>\n          })\n        }\n      </ul>\n    </div>\n  )\n}\n')])])]),e("p",[t._v("但是这段代码会有一个问题：")]),t._v(" "),e("ul",[e("li",[t._v("当前我们的组件并不依赖counter，但是counter发生改变时，依然会引起Profile的重新渲染；")])]),t._v(" "),e("p",[t._v("原因是什么呢？")]),t._v(" "),e("ul",[e("li",[t._v("useSelector默认会比较我们返回的两个对象是否相等；")]),t._v(" "),e("li",[t._v("如何比较呢？"),e("code",[t._v("const refEquality = (a, b) => a === b")]),t._v("；")]),t._v(" "),e("li",[t._v("也就是我们必须返回两个完全相等的对象才可以不引起重新渲染；")])]),t._v(" "),e("p",[t._v("这个时候，我们可以使用react-redux中给我们提供的 shallowEqual：")]),t._v(" "),e("ul",[e("li",[t._v("这段代码的作用是避免不必要的重新渲染；")])]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  const {banners, recommends, counter} = useSelector(state => ({\n    banners: state.homeInfo.banners,\n    recommends: state.homeInfo.recommends\n  }), shallowEqual);\n")])])]),e("p",[t._v("当然，你也可以编写自己的比较函数，来决定是否重新渲染。")]),t._v(" "),e("h3",{attrs:{id:"_4-2-usedispatch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-usedispatch"}},[t._v("#")]),t._v(" 4.2. useDispatch")]),t._v(" "),e("p",[t._v("useDispatch非常简单，就是直接获取dispatch函数，之后在组件中直接使用即可：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const dispatch = useDispatch()\n")])])]),e("p",[t._v("直接使用dispatch：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<button onClick={e => dispatch(subAction(1))}>-1</button>\n<button onClick={e => dispatch(subAction(5))}>-5</button>\n")])])]),e("p",[t._v("我们还可以通过useStore来获取当前的store对象：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const store = useStore()\n")])])]),e("p",[t._v("在组件中可以使用store：")]),t._v(" "),e("div",{staticClass:"language-react extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const store = useStore();\nconsole.log(store.getState());\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);