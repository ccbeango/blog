(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{335:function(e,v,s){"use strict";s.r(v);var a=s(1),t=Object(a.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vue源码学习01"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue源码学习01"}},[e._v("#")]),e._v(" Vue源码学习01")]),e._v(" "),v("h2",{attrs:{id:"flow"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flow"}},[e._v("#")]),e._v(" Flow")]),e._v(" "),v("p",[v("a",{attrs:{href:"https://flow.org/en/docs/getting-started/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flow"),v("OutboundLink")],1),e._v(" 是 facebook 出品的 JavaScript 静态类型检查工具。")]),e._v(" "),v("p",[e._v("Vue.js 的源码利用了 Flow 做了静态类型检查。")]),e._v(" "),v("p",[e._v("Vue.js 在做 2.0 重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，主要是因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。")]),e._v(" "),v("h3",{attrs:{id:"flow-在-vue-js-源码中的应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flow-在-vue-js-源码中的应用"}},[e._v("#")]),e._v(" Flow 在 Vue.js 源码中的应用")]),e._v(" "),v("p",[e._v("有时候我们想引用第三方库，或者自定义一些类型，但 Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个 "),v("code",[e._v("libdef")]),e._v(" 的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。")]),e._v(" "),v("p",[e._v("在 Vue.js 的主目录下有 "),v("code",[e._v(".flowconfig")]),e._v(" 文件， 它是 Flow 的配置文件。")]),e._v(" "),v("p",[e._v("配置文件中，"),v("code",[e._v("[libs]")]),e._v("定义Vue中自定义的位置。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("...\n\n[libs]\nflow\n\n...\n\n")])])]),v("p",[e._v("这里 "),v("code",[e._v("[l ibs]")]),e._v(" 配置的是 "),v("code",[e._v("flow")]),e._v("，表示指定的库定义都在 "),v("code",[e._v("flow")]),e._v(" 文件夹内。")]),e._v(" "),v("p",[e._v("我们可以看到flow中配置如下：")]),e._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[e._v("flow\n├── compiler"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("js        # 编译相关\n├── component"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("js       # 组件数据结构\n├── global"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("api"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("js      # Global "),v("span",{pre:!0,attrs:{class:"token constant"}},[e._v("API")]),e._v(" 结构\n├── modules"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("js         # 第三方库定义\n├── options"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("js         # 选项相关\n├── ssr"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("js             # 服务端渲染相关\n├── vnode"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("js           # 虚拟 node 相关\n")])])]),v("p",[e._v("静态类型检查的方式非常有利于大型项目源码的开发和维护。Vue3中使用的是TypeScript。")]),e._v(" "),v("h2",{attrs:{id:"src目录设计"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#src目录设计"}},[e._v("#")]),e._v(" src目录设计")]),e._v(" "),v("p",[e._v("ue.js 的源码都在 src 目录下，其目录结构如下。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("src\n├── compiler        # 编译相关 \n├── core            # 核心代码 \n├── platforms       # 不同平台的支持\n├── server          # 服务端渲染\n├── sfc             # .vue 文件解析\n├── shared          # 共享代码\n")])])]),v("h3",{attrs:{id:"compiler"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#compiler"}},[e._v("#")]),e._v(" compiler")]),e._v(" "),v("p",[e._v("Vue中一个很重要的点是VirtualDOM，虚拟DOM的生成实际上执行的是render()函数。")]),e._v(" "),v("p",[e._v("但在Vue中我们通常不会手写"),v("code",[e._v("render()")]),e._v("函数，往往会写"),v("code",[e._v("template")]),e._v("。那么template转成render的实现就在compiler目录下。")]),e._v(" "),v("p",[e._v("compiler 目录包含 Vue.js 所有编译相关的代码。它包括")]),e._v(" "),v("ul",[v("li",[e._v("把模板解析成 ast 语法树")]),e._v(" "),v("li",[e._v("ast 语法树优化")]),e._v(" "),v("li",[e._v("代码生成等功能。")])]),e._v(" "),v("p",[e._v("编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。显然，编译是一项耗性能的工作，所以更推荐前者——离线编译。")]),e._v(" "),v("h3",{attrs:{id:"core"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#core"}},[e._v("#")]),e._v(" core")]),e._v(" "),v("p",[e._v("core 目录包含了 Vue.js 的核心代码，包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。")]),e._v(" "),v("p",[e._v("目录如下：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("core\n├── components        # 内置组件 keep-alive \n├── global-api        # 全局API\n├── instance          # 渲染的实例\n├── observer          # 响应式相关\n├── vdom              # .vue 文件解析\n")])])]),v("ul",[v("li",[e._v("components 内置组件\n"),v("ul",[v("li",[e._v("keep-alive在这里实现")])])]),e._v(" "),v("li",[e._v("global-api 全局的API\n"),v("ul",[v("li",[e._v("Vue.use")]),e._v(" "),v("li",[e._v("Vue.minxn")]),e._v(" "),v("li",[e._v("Vue.extend")])])]),e._v(" "),v("li",[e._v("instance 渲染实例\n"),v("ul",[v("li",[e._v("render-helpers 渲染辅助函数")]),e._v(" "),v("li",[e._v("event 事件相关\n"),v("ul",[v("li",[e._v("$emit")]),e._v(" "),v("li",[e._v("$on")]),e._v(" "),v("li",[e._v("$once")]),e._v(" "),v("li",[e._v("$off")])])]),e._v(" "),v("li",[e._v("lifecycle 生命周期\n"),v("ul",[v("li",[e._v("挂载组件")]),e._v(" "),v("li",[e._v("更新子组件")])])]),e._v(" "),v("li",[e._v("proxy 非生产环境的proxy代理")]),e._v(" "),v("li",[e._v("render 渲染")])])]),e._v(" "),v("li",[e._v("observer 响应式相关\n"),v("ul",[v("li",[e._v("array 数据相关API")]),e._v(" "),v("li",[e._v("dep")]),e._v(" "),v("li",[e._v("scheduler")]),e._v(" "),v("li",[e._v("traverse")]),e._v(" "),v("li",[e._v("watcher  指令和watch使用")])])]),e._v(" "),v("li",[e._v("util 工具函数")]),e._v(" "),v("li",[e._v("vdom 虚拟DOM")])]),e._v(" "),v("h3",{attrs:{id:"platforms"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#platforms"}},[e._v("#")]),e._v(" platforms")]),e._v(" "),v("p",[e._v("Vue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 Vue.js")]),e._v(" "),v("p",[e._v("platforms")]),e._v(" "),v("ul",[v("li",[e._v("包含平台相关的运行代码\n"),v("ul",[v("li",[e._v("平台相关的编译、运行时、服务端渲染、工具函数等")])])]),e._v(" "),v("li",[e._v("web 浏览器相关程序")]),e._v(" "),v("li",[e._v("weex 类似于RN")]),e._v(" "),v("li",[e._v("那么我们从不同的平台入口就可以编译出不同的vue代码")])]),e._v(" "),v("h3",{attrs:{id:"server"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#server"}},[e._v("#")]),e._v(" server")]),e._v(" "),v("p",[e._v("服务端渲染相关代码。")]),e._v(" "),v("p",[e._v("Vue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。")]),e._v(" "),v("p",[e._v("注意：这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。")]),e._v(" "),v("p",[e._v('服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。')]),e._v(" "),v("h3",{attrs:{id:"sfc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sfc"}},[e._v("#")]),e._v(" sfc")]),e._v(" "),v("p",[e._v("讲"),v("code",[e._v(".vue")]),e._v("的代码文件编译成一个JS的对象。")]),e._v(" "),v("p",[e._v("通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件来编写组件。")]),e._v(" "),v("p",[e._v("这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。")]),e._v(" "),v("h3",{attrs:{id:"shared"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#shared"}},[e._v("#")]),e._v(" shared")]),e._v(" "),v("p",[e._v("所有目录共享的一个辅助方法。")]),e._v(" "),v("p",[e._v("Vue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。")]),e._v(" "),v("h2",{attrs:{id:"源码构建"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#源码构建"}},[e._v("#")]),e._v(" 源码构建")]),e._v(" "),v("p",[e._v("Vue.js 源码是基于 "),v("a",{attrs:{href:"https://github.com/rollup/rollup",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rollup"),v("OutboundLink")],1),e._v(" 构建的，它的构建相关配置都在 scripts 目录下。")]),e._v(" "),v("h2",{attrs:{id:"入口文件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#入口文件"}},[e._v("#")]),e._v(" 入口文件")])])}),[],!1,null,null,null);v.default=t.exports}}]);