# Webpack中的DevServer和HMR

目前我们开发的代码，为了运行需要有两个操作：

* 操作一：npm run build，编译相关的代码；
* 操作二：通过live server或者直接通过浏览器，打开index.html代码，查看效果；

这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成 编译和展示；

为了完成自动编译，webpack提供了几种可选的方式：

* webpack watch mode；
* webpack-dev-server；
* webpack-dev-middleware

## webpack watch mode

webpack给我们提供了[watch模式](https://webpack.docschina.org/configuration/watch/)，在该模式下，webpack依赖图中的所有文件，只要有一个发生了更新，那么代码将被重新编译，我们不需要手动去运行`npm run build`指令。

开启watch模式有两种方法：

**方式一： 在webpack的配置中，添加 watch: true**

```json {2}
module.exports = {
  watch: true,
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'build')
  },
  // ...
}
```

**方式二： 在启动webpack的命令中，添加 --watch的标识**

```json
"scripts": {
  "build": "webpack",
  "watch": "webpack --watch"
},
```

执行命令后，当文件繁盛修改，不用再此执行，webpack会自动监听。

## webpack DevServer

上面的方式可以监听到文件的变化，但是事实上它本身是没有自动刷新浏览器的功能的，当然，目前我们可以在VSCode中使用live-server来完成这样的功能。

但是，我们希望在不适用live-server的情况下，可以具备live reloading（实时重新加载）的功能。

我们可以使用[DevServer](https://webpack.docschina.org/configuration/dev-server/)来完成。

安装插件：

```shell
npm install webpack-dev-server -D
```

在`package.json`中添加启动脚本：

```json
"scripts": {
  "build": "webpack",
  "watch": "webpack --watch",
  "serve": "webpack serve"
},
```

运行`npm run serve`脚本就可以使用devServer了。

修改代码后，devServer会自动刷新浏览器页面。webpack-dev-server在编译之后不会将编译结果写入到任何输出文件。而是将 bundle文件保留在内存中，事实上是使用了一个叫[memfs](https://github.com/streamich/memfs)的库在内存中操作文件系统。

## webpack-dev-middleware

默认情况下，webpack-dev-server已经帮助我们做好了一切，比如通过express启动一个服务，比如HMR（热模块替换）；

如果我们想要有更好的自由度，可以使用[webpack-dev-middleware](https://webpack.docschina.org/guides/development/#using-webpack-dev-middleware)来定制自己的devServer。

webpack-dev-middleware 是一个封装器(wrapper)，它可以把 webpack 处理过的文件发送到一个 server。

webpack-dev-server 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义设置。

安装express和webpack-dev-middleware：

```shell
npm install express webpack-dev-middleware -D
```

然后我们创建`server.js`文件：

```js
const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();

const config = require("./webpack.config");

// 传入配置信息, webpack根据配置信息进行编译
const compiler =  webpack(config);

// 生成中间件并使用
const middleware = webpackDevMiddleware(compiler);
app.use(middleware);

app.listen(3000, () => {
  console.log("server has been started at http://localhost:3000");
});
```

启动服务`node server.js`，在浏览器中可以看到编译后的效果。

当然，也可以选择Koa来搭建此服务。

以上所有方式的，每次再修改文件自动编译时，都会刷新整个页面，也就是对所有的文件都进行重新编译。假如有成百上千个模块，修改一处，全部编译，显然这是不合理的。

我们可以使用HMR来解决此问题。

## 模块热替换HMR

[模块热替换](https://webpack.docschina.org/concepts/hot-module-replacement)(HMR - hot module replacement)功能会在应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面。

HMR通过如下几种方式，来提高开发的速度：

* 不重新加载整个页面，这样可以保留某些应用程序的状态不丢失
* 只更新需要变化的内容，节省开发的时间；
* 修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的devtools中直接修改样式；

默认情况下，webpack-dev-server已经支持HMR，从Webpack4开始，热模块替换是默认开启的；在不开启HMR的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是live reloading；

修改webpack配置以开启HMR：

```json
devServer: {
  hot: true
}
```

此时再执行`npm run serve`，此时可以看到浏览器控制台中有如下输出：

```shell {1,3,4}
[HMR] Waiting for update signal from WDS...
main.js:1 hello webpack!
index.js:551 [webpack-dev-server] Hot Module Replacement enabled.
index.js:551 [webpack-dev-server] Live Reloading enabled.
```

但是此时再修改文件，依然是刷新的整个页面，这是因为我们需要去指定哪些模块发生更新时，进行HMR，修改入口文件`main.js`如下：

```js {5-9}
import './util'

console.log('hello webpack')

if(module.hot) {
  module.hot.accept('./util', () => {
    console.log('utils 更新了')
  })
}
```

使用[accept函数](https://webpack.docschina.org/api/hot-module-replacement/#accept)监听`util.js`文件，当这个文件发生修改时，Webpack就会进行热替换，不会再刷新整个页面。

## 框架中使用HMR

在开发其他项目时，我们是否需要经常手动去写入`module.hot.accpet`相关的API，比如开发Vue、React项目，我们修改了组件，希望进行热更新，这个时候应该如何去操作。

这个问题，社区已经有了响应的[解决方案](https://webpack.docschina.org/guides/hot-module-replacement#other-code-and-frameworks)。

* vue开发中，使用vue-loader，此loader支持vue组件的HMR，提供开箱即用的体验；
* react开发中，有[React Hot Loader](https://github.com/gaearon/react-hot-loader)，实时调整react组件（目前React官方已经弃用了，改成使用[react-refresh](https://github.com/pmmmwh/react-refresh-webpack-plugin)）

### React的HMR

在之前，React是借助于React Hot Loader来实现的HMR，目前已经改成使用react-refresh来实现了。

安装react相关依赖：

```shell
npm install -D react react-dom
```

安装react HRM相关依赖：

```shell
npm install -D @pmmmwh/react-refresh-webpack-plugin react-refresh
```

配置`webpack.config.js`

```js
const ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin')

module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.jsx?$/i,
        loader: 'babel-loader'
      }
    ]
  },
  plugins: [
	 // ...
    new ReactRefreshWebpackPlugin()
  ],
}
```

修改`babel.config.js`文件：

```js
module.exports = {
  presets: [
    '@babel/preset-env',
    '@babel/preset-react',
  ],
  plugins: [
    'react-refresh/babel'
  ]
}
```

创建`App.jsx`文件

```jsx
import React, { Component } from "react";

class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      message: "Hello React",
    };
  }

  render() {
    return (
      <div>
        <h2>{this.state.message}</h2>
      </div>
    );
  }
}

export default App;
```

在`main.js`中引用

```js
import React from 'react';
import ReactDom from 'react-dom';
import ReactApp from './App.jsx'

ReactDom.render(<ReactApp/>, document.getElementById('reactRoot'))
```

`npm run serve`后，刷新页面可以看到渲染出`Hello React`

### Vue的HMR

Vue的加载需要使用vue-loader，而vue-loader加载的组件默认会帮助我们进行HMR的处理。

安装Vue相关依赖：

```shell
npm install -D vue
```

安装加载vue所需要的依赖：

```shell
npm install vue-loader vue-template-compiler -D
```

配置`webpack.config.js`

```js
const { VueLoaderPlugin } = require('vue-loader')

module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.vue$/i,
        loader: 'vue-loader'
      },
      {
        test: /\.css$/i,
        use: [
          'style-loader',
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
	 // ...
    new VueLoaderPlugin()
  ]
}
```

创建`App.vue`文件

```vue
<template>
  <div id="app">
    <h2 class="title">{{message}}</h2>
  </div>
</template>

<script>
export default {
  data() {
    return {
      message: "Hello Vue"
    }
  }
}
</script>

<style scoped>
  .title {
    color: red
  }
</style>
```

在`main.js`中引用

```js
import { createApp } from 'vue'
import VueApp from './App.vue'


createApp(VueApp).mount('#vueRoot')
```

`npm run serve`后，刷新页面可以看到渲染出`Hello Vue`

## HMR的原理

