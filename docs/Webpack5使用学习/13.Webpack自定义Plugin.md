# Webpack自定义Plugin

## Compiler和Compilation

webpack有两个非常重要的类：Compiler和Compilation。

Compiler和Compilation的区别如下：

*  Compiler：在Webpack构建之初就会创建此对象，并且在webpack的整个生命周期中都会存在(before - run - beforeCompiler - compile - make - finishMake - afterCompiler)，只要是webpack编译，都会创建一个Compiler，也就是每次执行如npm run build时会创建Compiler对象
* Compilation是到准备编译模块（如main.js），才会创建Compilation对象，主要存在于 compile之后 - make之前，且是make阶段主要使用的对象。

那么为什么要引入Compilation，只使用Compiler是否可以？

答案是不可以的。Compiler在整个生命周期中只使用一个对象即可。但是Compilation是每次编译都会创建新的。

比如webpack开启了watch，只要是原代码发生了变化，就需要重新编译模块；此时重新编译，如果再创建Compiler对象显然是不合理的，Compiler对象在初始化过程中做了很多操作，详见createCompiler。原代码发生改变，Compiler是可以继续使用的。

那么这个重新编译的工作，就可以创建一个新的Compilation对象来做编译。它们两个的生命周期不同，使用阶段也就不同。

## Webpack和Tapable

Compiler和Compilation是通过注入插件的方式，来监听webpack的所有生命周期。

插件的注入离不开各种各样的Hook，而他们的Hook是如何得到的呢？

其实是创建了Tapable库中的各种Hook的实例；所以，如果我们想要学习自定义插件，最好先了解[Tapable](https://github.com/webpack/tapable)

Tapable是官方编写和维护的一个库；这个库对外提供了很多Hook类，可以使用这些类创建插件的Hook。

在Webpack文档中可以看到这些由Tapable提供的生命周期Hook，包括[compiler 钩子](https://webpack.docschina.org/api/compiler-hooks/)和[compilation 钩子](https://webpack.docschina.org/api/compilation-hooks/)

Hook的类型共有四种：

* Basic：线性执行所有的监听

* Bail：当有返回值时，就不会执行后续的事件触发了；
* Loop：当返回值为true，就会反复执行该事件，当返回值为undefined或者不返回内容，就退出事件；
* Waterfall：当返回值不为undefined时，会将这次返回的结果作为下次事件的第一个参数；

同时Hook分为同步Hook和异步Hook，所以Tapple提供的Hook类包括：

* 同步Hook
  * SyncHook
  * SyncBailHook
  * SyncWaterfallHook
  * SyncLoopHook
* 异步Hook
  * AsyncParallelHook
  * AsyncParallelBailHook
  * AsyncSeriesHook
  * AsyncSeriesBailHook
  * AsyncSeriesWaterfallHook

异步Hook中还包括了串行和并行：

* Series：串行，会等待上一个异步的Hook执行完后再执行；
* Parallel：并行，会同时执行所有监听

## 自定义插件

在之前的学习中，已经使用了非常多的Plugin，如CleanWebpackPlugin、HTMLWebpackPlugin、MiniCSSExtractPlugin、CompressionPlugin。

这些Plugin被注册到webpack的生命周期中的过程如下：

1. 在webpack函数的createCompiler方法中，注册了所有的插件；
2. 在注册插件时，会调用插件函数或者插件对象的apply方法；
3. 插件方法会接收compiler对象，我们可以通过compiler对象来注册Hook的事件；
4. 某些插件也会传入一个compilation的对象，我们也可以监听compilation的Hook事件；

这里示例演示，将静态文件上传到指定服务器。

那么上传时机在资源输出到目录后，应该监听[afterEmit](https://webpack.docschina.org/api/compiler-hooks/#afteremit)钩子，这个钩子会在输出 asset 到 output 目录之后执行。

创建插件`/plugins/AutoUploadWebpackPlugin.js`

```js
const { NodeSSH } = require('node-ssh');

class AutoUploadWebpackPlugin {
  constructor(options) {
    this.options = options;
    this.ssh = new NodeSSH();
  }

  // 插件必须实现apply方法
  apply(compiler) {
    // 监听输出 asset 到 output 目录之后执行的Hook
    compiler.hooks.afterEmit.tapAsync('AutoUploadWebpackPlugin', async (compilation, callback) => {
      // 1. 获取打包输出目录
      const outputPath = compilation.outputOptions.path;
      console.log('打包了', outputPath)

      // 2. 创建SSH连接
      await this.connectServer()

      // 3. 删除服务端之前的资源文件
      const serverDir = this.options.remotePath;
      this.ssh.execCommand(`rm -rf ${serverDir}/*`);

      // 4. 上传文件
      this.uploadFiles(outputPath, serverDir)

      // 5. 断开SSH连接
      this.ssh.dispose();

      callback();
    });
  }

  async connectServer() {
    try {
      await this.ssh.connect({
        host: this.options.host,
        username: this.options.username,
        password: this.options.password
      });
      console.log('连接成功~');
    } catch (error) {
      console.log('连接失败：', error);
    }
  }

  async uploadFiles(localPath, remotePath) {
    const status = await this.ssh.putDirectory(localPath, remotePath, {
      recursive: true,
      concurrency: 10
    });
    console.log('传送到服务器: ', status ? "成功": "失败");
  }
}

module.exports = AutoUploadWebpackPlugin;
```

在Webpack中配置插件：

```js
const path = require("path");
const HtmlWebpackPlugin = require('html-webpack-plugin');
const AutoUploadWebpackPlugin = require('./plugins/AutoUploadWebpackPlugin');

module.exports = {
  mode: "development",
  devtool: "source-map",
  context: path.resolve(__dirname, "."),
  entry: "./src/main.js",
  output: {
    path: path.resolve(__dirname, "./build"),
    filename: "bundle.js",
  },
  module: {
    rules: [
    ],
  },
  plugins: [
    new HtmlWebpackPlugin(),
    new AutoUploadWebpackPlugin({
      host: '127.0.0.1',
      username: 'ccbean',
      password: '**********',
      remotePath: '/root/server'
    })
  ],
};
```

开发插件本质就是监听Webpack生命周期，然后进行相关的功能开发。

