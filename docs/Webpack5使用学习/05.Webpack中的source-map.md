---
title: Webpack中的source-map
date: 2022-04-27 20:06:54
permalink: /pages/6c36d0/
categories:
  - Webpack5使用学习
tags:
  - 
---
# Webpack中的source-map

## 认识source-map

我们的代码通常运行在浏览器上时，是通过打包压缩的，也就是真实跑在浏览器上的代码，和我们编写的代码其实是有差异的。

* 比如ES6的代码可能被转换成ES5；

* 比如对应的代码行号、列号在经过编译后肯定会不一致；

* 比如代码进行丑化压缩时，会将编码名称等修改；

* 比如我们使用了TypeScript等方式编写的代码，最终转换成JavaScript；

但是，当代码报错需要调试时（debug），调试转换后的代码是很困难的。

那么如何可以调试这种转换后不一致的代码呢？答案就是**source-map**

* source-map是从已转换的代码，映射到原始的源文件；
* 使浏览器可以重构原始源并在调试器中显示重建的原始源；

## 使用source-map

http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html

webpack在打包时，可以通过配置`devtool`选项生成source-map；

这里设置`devtool: source-map`并执行构建来看下效果。

我们可以看到`bundle.js`文件的最后一行是一行魔法注释：

```js
//# sourceMappingURL=bundle.js.map
```

它指向对应的source-map文件`bundle.js.map`。

浏览器会根据这一行注释，查找响应的source-map，并且根据source-map还原我们的代码，方便进行调试。

可在Chrome浏览器中开启source-map，默认是开启的：

![webpack中的source-map01](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/Webpack5/webpack中的source-map01.PNG)

## 分析source-map

最初source-map生成的文件带下是原始文件的10倍，第二版减少了约50%，第三版又减少了50%，所以目前一个133kb的文件，最终的source-map的大小大概在300kb。

整个`bundle.js.map`代码如下：

```json
{
  "version": 3,
  "file": "bundle.js",
  "mappings": ";;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACXO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;UCNA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA,eAAe,4BAA4B;WAC3C,eAAe;WACf,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA,8CAA8C;;;;;WCA9C;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNA;AACA,QAAQ,WAAW,EAAE,mBAAO,CAAC,mCAAW;AACxC;AACsD;AACtD;AACA;AACA;AACA;AACA,YAAY,sDAAU;AACtB,YAAY,uDAAW",
  "sources": [
    "webpack://06_learn_webpack/./src/js/format.js",
    "webpack://06_learn_webpack/./src/js/math.js",
    "webpack://06_learn_webpack/webpack/bootstrap",
    "webpack://06_learn_webpack/webpack/runtime/compat get default export",
    "webpack://06_learn_webpack/webpack/runtime/define property getters",
    "webpack://06_learn_webpack/webpack/runtime/hasOwnProperty shorthand",
    "webpack://06_learn_webpack/webpack/runtime/make namespace object",
    "webpack://06_learn_webpack/./src/main.js"
  ],
  "sourcesContent": [
    "const dateFormat = (date) => {\n  return \"2020-12-12\";\n}\n\nconst priceFormat = (price) => {\n  return \"100.00\";\n}\n\nmodule.exports = {\n  dateFormat,\n  priceFormat\n}\n",
    "export const sum = (num1, num2) => {\n  return num1 + num2;\n}\n\nexport const mul = (num1, num2) => {\n  return num1 * num2;\n}\n",
    "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n",
    "// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};",
    "// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};",
    "__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }",
    "// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};",
    "// commonjs模式导入es module\r\nconst { sum, mul } = require('./js/math');\r\n// es module模式导入commonjs\r\nimport { dateFormat, priceFormat } from './js/format';\r\n\r\nconsole.log(sum(20, 30));\r\nconsole.log(mul(20, 30));\r\n\r\nconsole.log(dateFormat(\"1213\"));\r\nconsole.log(priceFormat(\"1213\"));\r\n"
  ],
  "names": [],
  "sourceRoot": ""
}
```

字段含义如下：

* version：当前使用的版本，也就是最新的第三版；
* sources：从哪些文件转换过来的source-map和打包的代码（最初始的文件）；
* names：转换前的变量和属性名称（因为目前使用的是development模式，所以不需要保留转换前的名称）；
* mappings：source-map用来和源文件映射的信息（比如位置信息等），一串base64 VLQ（veriable-length quantity可变长度值）编码；
* file：打包后的文件（浏览器加载的文件）；
* sourceContent：转换前的具体代码信息（和sources是对应的关系）；
* sourceRoot：所有的sources相对的根目录；

关于source-map的具体细节可参考[JavaScript Source Map 详解](http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html)

## 生成source-map

如何在使用webpack打包的时候，生成对应的source-map呢？

webpack为提供了非常多的选项（目前是26个），来处理source-map，详见[Devtool](https://webpack.docschina.org/configuration/devtool/)。

选择不同的值，生成的source-map会稍微有差异，打包的过程也会有性能的差异，可以根据不同的情况进行选择。

