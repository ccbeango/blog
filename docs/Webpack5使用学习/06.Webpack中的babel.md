---
title: Webpack中的babel
date: 2022-05-08 09:24:21
permalink: /pages/f3d33b/
categories:
  - Webpack5使用学习
tags:
  - 
---
# Webpack中的babel

关于Babel的入门，可看这篇文章[Babel 入门教程](https://www.ruanyifeng.com/blog/2016/01/babel.html)

## 为什么需要babel

事实上，在开发中我们很少直接去接触babel，但是babel对于前端开发来说，目前是不可缺少的一部分：

* 开发中，我们想要使用ES6+的语法，想要使用TypeScript，开发React项目，它们都是离不开Babel的；
* 学习Babel对于我们理解代码从编写到线上的转变过程至关重要；

Babel是一个工具链，采用的是微内核架构，主要用于旧浏览器或者缓解中将ECMAScript 2015+代码转换为向后兼容版本的JavaScript代码。

这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。

包括：语法转换、源代码转换、Polyfill实现目标缓解缺少的功能等；

```js
// 转码前
input.map(item => item + 1);

// 转码后
input.map(function (item) {
  return item + 1;
});
```

## Babel命令行使用

babel本身可以作为一个独立的工具（和postcss一样），可以不和webpack等构建工具配置来单独使用。

如果我们希望在命令行尝试使用babel，需要安装如下库：

* `@babel/core`：babel的核心代码，必须安装；
* `@babel/cli`：可以让我们在命令行使用babel；

这里我们在`src/main.js`中实现如下代码：

```js
const message = 'hello world'

const foo = (info) => {
  console.log(info)
}

foo(message)
```

在命令行中执行：

```shell
npx babel src --out-dir dist
```

使用babel来处理我们的源代码：

* src：是源文件的目录；
* --out-dir：指定要输出的文件夹dist；

然后查看`dist/main.js`文件如下：

```js
const message = 'hello world';

const foo = info => {
  console.log(info);
};

foo(message);
```

可以看到，babel基本没有进行任何转换，只是去掉了箭头函数info参数的括号。

因为这里值使用了babel的内核代码`@babel/core`，至于`main.js`代码要如何转化，它是不知道的，所以为了让代码转换成我们想要的格式，就需要给babel设置相关的插件。

比如要转换箭头函数，那么我们就可以使用箭头函数转换相关的插件：

```shell
npm install @babel/plugin-transform-arrow-functions -D
```

然后命令行中使用此插件，输入如下命令：

```shell
npx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions
```

再查看输出结果：

```js
const message = 'hello world';

const foo = function (info) {
  console.log(info);
};

foo(message);
```

我们可以看到箭头函数已经转换成了普通的匿名函数。

比如要转换const为var，我们需要使用`@babel/plugin-transform-block-scoping` 来完成这样的功能：

```shell
npm install @babel/plugin-transform-block-scoping -D
```

然后命令行中使用此插件，输入如下命令：

```shell
npx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions
```

查看输出结果可以发现，const已经转换成了var：

```js
var message = 'hello world';

var foo = function (info) {
  console.log(info);
};

foo(message);
```

## Babel的预设preset

我们在转换箭头函数和const中，使用了两个插件，如果要转换的内容包含许多个ES6特性语法，一个个设置是比较麻烦的，这时我们可以使用**预设preset**

安装@babel/preset-env预设：

```shell
npm install @babel/preset-env -D
```

这个包是一系列插件的组合，使用此包会自动查找需要的插件来完成代码的转化。实现原理详见[此处]()

执行如下命令：

```shell
npx babel src --out-dir dist --presets=@babel/preset-env
```

可以看到转换结果如下：

```js
"use strict";

var message = 'hello world';

var foo = function foo(info) {
  console.log(info);
};

foo(message);
```

## Babel的底层原理

编译器的工作是将一种源代码（原生语言）转换成另一种源代码（目标语言）。

Bable其实就是一个编译器，只是将JS代码从一种格式转换成了另一种JS代码格式。

Babel编译器的作用就是将我们的源代码，转换成浏览器可以直接识别的另外一段源代码；

Babel编译器的工作流程有三个阶段：

* 解析阶段（Parsing）
* 转换阶段（Transformation）
* 生成阶段（Code Generation）

![webpack中的babel01](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/Webpack5/webpack中的babel01.png)

当然，这只是一个简化版的编译器工具流程，在每个阶段又会有自己具体的工作，流程如下：

![webpack中的babel02](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/Webpack5/webpack中的babel02.png)

可以结合代码看下具体的执行流程：

1. 我们有如下**原生源代码**：

   ```js
   const name = "ccbean";
   const foo = (name) => console.log(name);
   foo(name);
   ```

2. 进行**词法分析（Lexical Analysis）**，它会读取整个源代码文件，将整个源代码读取成字符串，代码中每个内容都会被提取出来，如第一行有5个部分，那么就会提取`const`、`name`、`=`、`"ccbean"`、`;`共5个部分。

3. 词法分析提取的每个部分会生成**tokens数组**，如下就是我们的代码在分析后得到的tokens数组，可以看到其中包含了一个个`{type, value}`元素，这些就是词法分析时提取的一个个词法。

   * type标识了每个词的类型，如关键字`Keyword`、标识符`Identifier`、标点符号`Punctuator`、字符串`String`。
   * value标识了所有词的对应值。

   ```js
   [
     {
         "type": "Keyword",
         "value": "const"
     },
     {
         "type": "Identifier",
         "value": "foo"
     },
     {
         "type": "Punctuator",
         "value": "="
     },
     {
         "type": "Punctuator",
         "value": "("
     },
     {
         "type": "Identifier",
         "value": "name"
     },
     {
         "type": "Punctuator",
         "value": ")"
     },
     {
         "type": "Punctuator",
         "value": "=>"
     },
     {
         "type": "Identifier",
         "value": "console"
     },
     {
         "type": "Punctuator",
         "value": "."
     },
     {
         "type": "Identifier",
         "value": "log"
     },
     {
         "type": "Punctuator",
         "value": "("
     },
     {
         "type": "Identifier",
         "value": "name"
     },
     {
         "type": "Punctuator",
         "value": ")"
     },
     {
         "type": "Punctuator",
         "value": ";"
     },
     {
         "type": "Identifier",
         "value": "foo"
     },
     {
         "type": "Punctuator",
         "value": "("
     },
     {
         "type": "String",
         "value": "\"ccbean\""
     },
     {
         "type": "Punctuator",
         "value": ")"
     },
     {
         "type": "Punctuator",
         "value": ";"
     }
   ]
   ```

4. 根据tokens数组中的词法，进行**语法分析（syntatic analysis）**，也称为**Parsing**，那么会生成抽象语法树。

   ```json
   {
     "type": "Program",
     "body": [
       {
         "type": "VariableDeclaration",
         "declarations": [
           {
             "type": "VariableDeclarator",
             "id": {
               "type": "Identifier",
               "name": "foo"
             },
             "init": {
               "type": "ArrowFunctionExpression",
               "id": null,
               "params": [
                 {
                   "type": "Identifier",
                   "name": "name"
                 }
               ],
               "body": {
                 "type": "CallExpression",
                 "callee": {
                   "type": "MemberExpression",
                   "computed": false,
                   "object": {
                     "type": "Identifier",
                     "name": "console"
                   },
                   "property": {
                     "type": "Identifier",
                     "name": "log"
                   }
                 },
                 "arguments": [
                   {
                     "type": "Identifier",
                     "name": "name"
                   }
                 ]
               },
               "generator": false,
               "expression": true,
               "async": false
             }
           }
         ],
         "kind": "const"
       },
       {
         "type": "ExpressionStatement",
         "expression": {
           "type": "CallExpression",
           "callee": {
             "type": "Identifier",
             "name": "foo"
           },
           "arguments": [
             {
               "type": "Literal",
               "value": "ccbean",
               "raw": "\"ccbean\""
             }
           ]
         }
       }
     ],
     "sourceType": "script"
   }
   ```

5. 对抽象语法树进行**遍历（Traversal）**，**访问（Visitor）**树中每一个节点。那么在这个访问过程中，假如想要将`const`关键字转换成为`var`关键字，那么就可以在访问的过程中**应用插件（Plugin）**，对节点中的代码进行修改。在整个遍历过程中，当有节点需要进行转换时，就应用对应的插件进行代码修改。

6. 当遍历完整颗树之后，就会生成一颗**新的抽象语法树**。

   ```json
   {
     "type": "Program",
     "body": [
       {
         "type": "VariableDeclaration",
         "declarations": [
           {
             "type": "VariableDeclarator",
             "id": {
               "type": "Identifier",
               "name": "foo"
             },
             "init": {
               "type": "FunctionExpression",
               "id": {
                 "type": "Identifier",
                 "name": "foo"
               },
               "params": [
                 {
                   "type": "Identifier",
                   "name": "name"
                 }
               ],
               "body": {
                 "type": "BlockStatement",
                 "body": [
                   {
                     "type": "ReturnStatement",
                     "argument": {
                       "type": "CallExpression",
                       "callee": {
                         "type": "MemberExpression",
                         "computed": false,
                         "object": {
                           "type": "Identifier",
                           "name": "console"
                         },
                         "property": {
                           "type": "Identifier",
                           "name": "log"
                         }
                       },
                       "arguments": [
                         {
                           "type": "Identifier",
                           "name": "name"
                         }
                       ]
                     }
                   }
                 ]
               },
               "generator": false,
               "expression": false,
               "async": false
             }
           }
         ],
         "kind": "var"
       },
       {
         "type": "ExpressionStatement",
         "expression": {
           "type": "CallExpression",
           "callee": {
             "type": "Identifier",
             "name": "foo"
           },
           "arguments": [
             {
               "type": "Literal",
               "value": "ccbean",
               "raw": "\"ccbean\""
             }
           ]
         }
       }
     ],
     "sourceType": "script"
   }
   ```

7. 根据新的AST再生成最终的转换代码。

   ```js
   "use strict";
   
   var name = "ccbean";
   
   var foo = function foo(name) {
     return console.log(name);
   };
   
   foo(name);
   ```

这就是babel的整个执行流程即运行原理。所以，无论是要转换什么样的代码，如TypeScript代码、ES6代码、JSX代码，只需要**在合适的位置应用对应的插件**，将代码转成一个新的AST，再根据新AST进行输出，就会得到我们想要的转换效果了。





