---
title: Webpack中的babel
date: 2022-05-08 09:24:21
permalink: /pages/f3d33b/
categories:
  - Webpack5使用学习
tags:
  - 
---
# Webpack中的babel

关于Babel的入门，可看这篇文章[Babel 入门教程](https://www.ruanyifeng.com/blog/2016/01/babel.html)

## 为什么需要babel

事实上，在开发中我们很少直接去接触babel，但是babel对于前端开发来说，目前是不可缺少的一部分：

* 开发中，我们想要使用ES6+的语法，想要使用TypeScript，开发React项目，它们都是离不开Babel的；
* 学习Babel对于我们理解代码从编写到线上的转变过程至关重要；

Babel是一个工具链，采用的是微内核架构，主要用于旧浏览器或者缓解中将ECMAScript 2015+代码转换为向后兼容版本的JavaScript代码。

这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。

包括：语法转换、源代码转换、Polyfill实现目标缓解缺少的功能等；

```js
// 转码前
input.map(item => item + 1);

// 转码后
input.map(function (item) {
  return item + 1;
});
```

## Babel命令行使用

babel本身可以作为一个独立的工具（和postcss一样），可以不和webpack等构建工具配置来单独使用。

如果我们希望在命令行尝试使用babel，需要安装如下库：

* `@babel/core`：babel的核心代码，必须安装；
* `@babel/cli`：可以让我们在命令行使用babel；

这里我们在`src/main.js`中实现如下代码：

```js
const message = 'hello world'

const foo = (info) => {
  console.log(info)
}

foo(message)
```

在命令行中执行：

```shell
npx babel src --out-dir dist
```

使用babel来处理我们的源代码：

* src：是源文件的目录；
* --out-dir：指定要输出的文件夹dist；

然后查看`dist/main.js`文件如下：

```js
const message = 'hello world';

const foo = info => {
  console.log(info);
};

foo(message);
```

可以看到，babel基本没有进行任何转换，只是去掉了箭头函数info参数的括号。

因为这里值使用了babel的内核代码`@babel/core`，至于`main.js`代码要如何转化，它是不知道的，所以为了让代码转换成我们想要的格式，就需要给babel设置相关的插件。

比如要转换箭头函数，那么我们就可以使用箭头函数转换相关的插件：

```shell
npm install @babel/plugin-transform-arrow-functions -D
```

然后命令行中使用此插件，输入如下命令：

```shell
npx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions
```

再查看输出结果：

```js
const message = 'hello world';

const foo = function (info) {
  console.log(info);
};

foo(message);
```

我们可以看到箭头函数已经转换成了普通的匿名函数。

比如要转换const为var，我们需要使用`@babel/plugin-transform-block-scoping` 来完成这样的功能：

```shell
npm install @babel/plugin-transform-block-scoping -D
```

然后命令行中使用此插件，输入如下命令：

```shell
npx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions
```

查看输出结果可以发现，const已经转换成了var：

```js
var message = 'hello world';

var foo = function (info) {
  console.log(info);
};

foo(message);
```

## Babel的预设preset

我们在转换箭头函数和const中，使用了两个插件，如果要转换的内容包含许多个ES6特性语法，一个个设置是比较麻烦的，这时我们可以使用**预设preset**

安装@babel/preset-env预设：

```shell
npm install @babel/preset-env -D
```

这个包是一系列插件的组合，使用此包会自动查找需要的插件来完成代码的转化。实现原理详见[此处]()

执行如下命令：

```shell
npx babel src --out-dir dist --presets=@babel/preset-env
```

可以看到转换结果如下：

```js
"use strict";

var message = 'hello world';

var foo = function foo(info) {
  console.log(info);
};

foo(message);
```

## Babel的底层原理

编译器的工作是将一种源代码（原生语言）转换成另一种源代码（目标语言）。

Bable其实就是一个编译器，只是将JS代码从一种格式转换成了另一种JS代码格式。

Babel编译器的作用就是将我们的源代码，转换成浏览器可以直接识别的另外一段源代码；

Babel编译器的工作流程有三个阶段：

* 解析阶段（Parsing）
* 转换阶段（Transformation）
* 生成阶段（Code Generation）

![webpack中的babel01](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/Webpack5/webpack中的babel01.png)

当然，这只是一个简化版的编译器工具流程，在每个阶段又会有自己具体的工作，流程如下：

![webpack中的babel02](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/Webpack5/webpack中的babel02.png)

可以结合代码看下具体的执行流程：

1. 我们有如下**原生源代码**：

   ```js
   const name = "ccbean";
   const foo = (name) => console.log(name);
   foo(name);
   ```

2. 进行**词法分析（Lexical Analysis）**，它会读取整个源代码文件，将整个源代码读取成字符串，代码中每个内容都会被提取出来，如第一行有5个部分，那么就会提取`const`、`name`、`=`、`"ccbean"`、`;`共5个部分。

3. 词法分析提取的每个部分会生成**tokens数组**，如下就是我们的代码在分析后得到的tokens数组，可以看到其中包含了一个个`{type, value}`元素，这些就是词法分析时提取的一个个词法。

   * type标识了每个词的类型，如关键字`Keyword`、标识符`Identifier`、标点符号`Punctuator`、字符串`String`。
   * value标识了所有词的对应值。

   ```js
   [
     {
         "type": "Keyword",
         "value": "const"
     },
     {
         "type": "Identifier",
         "value": "foo"
     },
     {
         "type": "Punctuator",
         "value": "="
     },
     {
         "type": "Punctuator",
         "value": "("
     },
     {
         "type": "Identifier",
         "value": "name"
     },
     {
         "type": "Punctuator",
         "value": ")"
     },
     {
         "type": "Punctuator",
         "value": "=>"
     },
     {
         "type": "Identifier",
         "value": "console"
     },
     {
         "type": "Punctuator",
         "value": "."
     },
     {
         "type": "Identifier",
         "value": "log"
     },
     {
         "type": "Punctuator",
         "value": "("
     },
     {
         "type": "Identifier",
         "value": "name"
     },
     {
         "type": "Punctuator",
         "value": ")"
     },
     {
         "type": "Punctuator",
         "value": ";"
     },
     {
         "type": "Identifier",
         "value": "foo"
     },
     {
         "type": "Punctuator",
         "value": "("
     },
     {
         "type": "String",
         "value": "\"ccbean\""
     },
     {
         "type": "Punctuator",
         "value": ")"
     },
     {
         "type": "Punctuator",
         "value": ";"
     }
   ]
   ```

4. 根据tokens数组中的词法，进行**语法分析（syntatic analysis）**，也称为**Parsing**，那么会生成抽象语法树。

   ```json
   {
     "type": "Program",
     "body": [
       {
         "type": "VariableDeclaration",
         "declarations": [
           {
             "type": "VariableDeclarator",
             "id": {
               "type": "Identifier",
               "name": "foo"
             },
             "init": {
               "type": "ArrowFunctionExpression",
               "id": null,
               "params": [
                 {
                   "type": "Identifier",
                   "name": "name"
                 }
               ],
               "body": {
                 "type": "CallExpression",
                 "callee": {
                   "type": "MemberExpression",
                   "computed": false,
                   "object": {
                     "type": "Identifier",
                     "name": "console"
                   },
                   "property": {
                     "type": "Identifier",
                     "name": "log"
                   }
                 },
                 "arguments": [
                   {
                     "type": "Identifier",
                     "name": "name"
                   }
                 ]
               },
               "generator": false,
               "expression": true,
               "async": false
             }
           }
         ],
         "kind": "const"
       },
       {
         "type": "ExpressionStatement",
         "expression": {
           "type": "CallExpression",
           "callee": {
             "type": "Identifier",
             "name": "foo"
           },
           "arguments": [
             {
               "type": "Literal",
               "value": "ccbean",
               "raw": "\"ccbean\""
             }
           ]
         }
       }
     ],
     "sourceType": "script"
   }
   ```

5. 对抽象语法树进行**遍历（Traversal）**，**访问（Visitor）**树中每一个节点。那么在这个访问过程中，假如想要将`const`关键字转换成为`var`关键字，那么就可以在访问的过程中**应用插件（Plugin）**，对节点中的代码进行修改。在整个遍历过程中，当有节点需要进行转换时，就应用对应的插件进行代码修改。

6. 当遍历完整颗树之后，就会生成一颗**新的抽象语法树**。

   ```json
   {
     "type": "Program",
     "body": [
       {
         "type": "VariableDeclaration",
         "declarations": [
           {
             "type": "VariableDeclarator",
             "id": {
               "type": "Identifier",
               "name": "foo"
             },
             "init": {
               "type": "FunctionExpression",
               "id": {
                 "type": "Identifier",
                 "name": "foo"
               },
               "params": [
                 {
                   "type": "Identifier",
                   "name": "name"
                 }
               ],
               "body": {
                 "type": "BlockStatement",
                 "body": [
                   {
                     "type": "ReturnStatement",
                     "argument": {
                       "type": "CallExpression",
                       "callee": {
                         "type": "MemberExpression",
                         "computed": false,
                         "object": {
                           "type": "Identifier",
                           "name": "console"
                         },
                         "property": {
                           "type": "Identifier",
                           "name": "log"
                         }
                       },
                       "arguments": [
                         {
                           "type": "Identifier",
                           "name": "name"
                         }
                       ]
                     }
                   }
                 ]
               },
               "generator": false,
               "expression": false,
               "async": false
             }
           }
         ],
         "kind": "var"
       },
       {
         "type": "ExpressionStatement",
         "expression": {
           "type": "CallExpression",
           "callee": {
             "type": "Identifier",
             "name": "foo"
           },
           "arguments": [
             {
               "type": "Literal",
               "value": "ccbean",
               "raw": "\"ccbean\""
             }
           ]
         }
       }
     ],
     "sourceType": "script"
   }
   ```

7. 根据新的AST再生成最终的转换代码。

   ```js
   "use strict";
   
   var name = "ccbean";
   
   var foo = function foo(name) {
     return console.log(name);
   };
   
   foo(name);
   ```

这就是babel的整个执行流程即运行原理。所以，无论是要转换什么样的代码，如TypeScript代码、ES6代码、JSX代码，只需要**在合适的位置应用对应的插件**，将代码转成一个新的AST，再根据新AST进行输出，就会得到我们想要的转换效果了。

关于编译器，可查看[the-super-tiny-compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)来学习更多，这是一个使用JS来实现的编译器。

## Webpack中使用babel

在实际开发中，我们通常会在构建工具中通过配置babel来对其进行使用的，比如在webpack中。

在Webpack中使用babel，需要安装相应的loader，即babel-loader。

```shell
npm install babel-loader -D
```

我们还需要用到`@babel/core`和项目中需要用到的babel插件或预设，这里做测试安装如下库：

```shell
npm install @babel/core @babel/plugin-transform-arrow-functions @babel/plugin-transform-block-scoping @babel/preset-env -D
```

我们配置规则来使用Babel：

```json
module: {
  rules: [
    {
      test: /\.js$/,
      use: {
        loader: 'babel-loader'
      }
    }
  ]
},
```

执行`npm run build`，可看到结果如下：

```js
// bundle.js
(function () {
  var __webpack_exports__ = {};

  const name = 'ccbean';

  const foo = name => {
    console.log(name);
  };

  foo(name);
})();
```

### 使用babel插件

这里并没有转换代码，我们需要配置插件，这里配置了两个插件：

```json
module: {
  rules: [
    {
      test: /\.js$/,
      use: {
        loader: 'babel-loader',
        options: {
          plugins: [
            '@babel/plugin-transform-arrow-functions',
            '@babel/plugin-transform-block-scoping'
          ]
        }
      }
    }
  ]
},
```

执行`npm run build`，可看到结果如下，转换了箭头函数和关键字`const`：

```js
(function () {
  var __webpack_exports__ = {};

  var name = 'ccbean';

  var foo = function (name) {
    console.log(name);
  };

  foo(name);
})();
```

### 使用babel预设

如果我们一个个去安装使用插件，那么需要手动来管理大量的babel插件，我们可以直接给webpack提供一个preset，webpack会根据我们的预设来加载对应的插件列表，并且将其传递给babel。

[Babel的预设](https://babel.dev/docs/en/babel-preset-env)有四个：

* env：`@babel/preset-env`
* react：`@babel/preset-react`
* typescript：`@babel/preset-typescript`
* flow：`@babel/preset-flow`

开发中可以根据需求设置一个或多个预设。

这里我们做测试，只安装preset-env：

```shell
npm install @babel/preset-env -D
```

然后进行配置：

```json
{
  test: /\.js$/,
  use: {
    loader: 'babel-loader',
    options: {
      presets: [
        '@babel/preset-env'
      ]
    }
  }
}
```

执行`npm run build`，可看到结果如下：

```js
(function () {
  var __webpack_exports__ = {};
  var name = 'ccbean';

  var foo = function foo(name) {
    console.log(name);
  };

  foo(name);
})();
```

### 设置目标浏览器

我们最终打包的JavaScript代码，是需要跑在目标浏览器上的，那么如何告知babel我们的目标浏览器呢？

有两种方法：

* browserslist工具
* targets属性

**使用browserslist**

使用预设，Babel在进行代码转换时，默认会根据目标浏览器的需要进行代码转换。默认会读取`browserslist`配置来获取需要适配的浏览器，然后再根据适配要求进行代码转换。

`.browserslistrc`配置如下

```js
last 2 version
```

执行`npm run build`，可看到结果如下：

```js
(function () {
  var __webpack_exports__ = {};
  var message = 'hello world';

  var foo = function foo(info) {
    console.log(info);
  };

  foo(message);
})();
```

修改`.browserslistrc`如下：

```js
chrome88
```

执行`npm run build`，可看到结果如下：

```js
(() => {
  var __webpack_exports__ = {};
  const message = 'hello world';

  const foo = info => {
    console.log(info);
  };

  foo(message);
})();
```

**使用targets属性**

我们也可以通过targets来进行配置目标浏览器

```json
module: {
  rules: [
    {
      test: /\.js$/,
      use: {
        loader: 'babel-loader',
        options: {
          presets: [
            ['@babel/preset-env', {
              // 数组格式，第二个元素设置options
              targets: "last 2 version"
            }]
          ]
        }
      }
    }
  ]
}
```

执行`npm run build`，可看到结果如下：

```js
(function () {
  var __webpack_exports__ = {};
  var message = 'hello world';

  var foo = function foo(info) {
    console.log(info);
  };

  foo(message);
})();
```

**如果两个同时配置了，`targets`属性的优先级更高，会覆盖browserslist。但是在开发中，更推荐通过browserslist来配置；类似的postcss工具，也会使用browserslist。方便进行统一浏览器的适配。**

### Babel的Stage-X设置

在babel7之前（比如babel6中），我们会经常看到这种设置方式：

```js
module.exports = {
  "presets": ["stage-0"]
}
```

上面的配置表达的含义是使用对应的`babel-preset-stage-x `预设，通常在旧的项目中会看到类似的配置；**从babel7开始**，已经不建议使用了，建议使用preset-env来设置。

不过我们还是要了解下Stage-X是什么含义，要了解Stage-X，我们需要先了解一下TC39的组织：

* TC39是指技术委员会（Technical Committee）第 39 号；
* 它是 ECMA 的一部分，ECMA 是 “ECMAScript” 规范下的 JavaScript 语言标准化的机构；
* ECMAScript 规范定义了 JavaScript 如何一步一步的进化、发展；

TC39 遵循的原则是：分阶段加入不同的语言特性，新流程涉及四个不同的 Stage：

* **Stage 0**：strawman（稻草人），任何尚未提交作为正式提案的讨论、想法变更或者补充都被认为是第 0 阶段的"稻草人"；
* **Stage 1**：proposal（提议），提案已经被正式化，并期望解决此问题，还需要观察与其他提案的相互影响；
* **Stage 2**：draft（草稿），Stage 2的提案应提供规范初稿、草稿。此时，语言的实现者开始观察 runtime 的具体实现是否合理；
* **Stage 3**：candidate（候补），Stage 3提案是建议的候选提案。在这个高级阶段，规范的编辑人员和评审人员必须在最终规范上签字。Stage 3 的提案不会有太大的改变，在对外发布之前只是修正一些问题；
* Stage 4：finished（完成），进入Stage 4的提案将包含在 ECMAScript 的下一个修订版中；

### Babel的配置文件

babel的配置信息可以放到一个独立的文件中，一是简化webpack中Rule的loader编写，二是多个地都需要使用babel，那么babel配置可以复用。

babel给我们提供了两种配置文件的编写：

* `babel.config.json`（或者`.js`、`.cjs`、`.mjs`）文件；
* `.babelrc.json`（或者`.babelrc`、`.js`、`.cjs`、`.mjs`）文件；

它们两个有什么区别呢？目前很多的项目都采用了多包管理的方式（babel本身、element-plus、umi等）；

* `.babelrc.json`：早期使用较多的配置方式，但是对于配置Monorepos项目是比较麻烦的； 
* `babel.config.json`（babel7）：可以直接作用于Monorepos项目的子包，更加推荐；

注：Monorepos是管理项目的一种方式即一个项目中分多个包，对应的是Multirepos即多仓库。

我们使用`babel.config.js`作为babel的配置文件，如下：

```js
module.exports = {
  plugins: [
    // '@babel/plugin-transform-arrow-functions',
    // '@babel/plugin-transform-block-scoping'
  ],
  presets: [
    '@babel/preset-env',
    // ['@babel/preset-env', {
    //   targets: "last 2 version"
    // }],
  ],
}
```

在`webpack.config.js`中修改配置：

```json
module: {
  rules: [
    {
      test: /\.js$/,
      loader: 'babel-loader'
    }
  ]
}
```

`.browserslistrc`中配置

```js
> 1%
last 2 version
not dead
```

再执行构建可看到如下结果：

```js
(function () {
  var __webpack_exports__ = {};
  var message = 'hello world';

  var foo = function foo(info) {
    console.log(info);
  };

  foo(message);
})();
```

可以修改相关配置再进行构建，测试配置是否生效。





