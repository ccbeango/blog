# Webpack环境分离和代码分离

## 区分开发环境

当配置越来越多时，单文件的Webpack配置会变得越来越不容易维护；某些配置只在开发环境需要使用，某些配置只在生成环境需要使用，对配置进行划分，方便维护和管理。

在启动时区分不同的配置有两种方案：

* 编写不同的配置文件，开发和生成时，分别加载不同的配置文件，结合插件webpack-merge来实现；
* 方式二：使用相同的一个入口配置文件，webpack配置为[导出函数](https://webpack.docschina.org/configuration/configuration-types/#exporting-a-function)，通过设置[Environment ](https://webpack.docschina.org/api/cli/#environment-options)参数来区分它们；

### 方案一 多配置文件

结合插件webpack-merge来实现。

在package.json中添加脚本：

```json
"scripts": {
  "build": "webpack --config ./config/webpack.prod.js",
  "serve": "webpack serve --config ./config/webpack.dev.js",
},
```

首先我们创建一个配置文件`webpack.base.js`：

```js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const { VueLoaderPlugin } = require('vue-loader');

module.exports = {
  context: path.resolve(__dirname, '../'),
  entry: './src/index.js',
  output: {
    clean: true,
    filename: "bundle.js",
    path: path.resolve(__dirname, "../build"),
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/i,
        use: "babel-loader"
      },
      {
        test: /\.vue$/i,
        use: "vue-loader"
      },
      {
        test: /\.css/i,
        use: [
          "style-loader",
          "css-loader"
        ]
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./src/index.html"
    }),
    new VueLoaderPlugin()
  ],
  resolve: {
    extensions: ['.js', '.json', '.jsx', '.ts', '.vue', '.wasm', '.mjs'],
    alias: {
      '@': path.resolve(__dirname, '../src'),
      "@pages": path.resolve(__dirname, "../src/pages")
    }
  }
}
```

然后分别创建两个配置：

`webpack.dev.js`

```js
const path = require('path');
const ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin');
const { merge } = require('webpack-merge');
const baseConfig = require('./webpack.base');

process.env.NODE_ENV = 'development'

module.exports = merge(baseConfig, {
  mode: "development",
  plugins: [
    new ReactRefreshWebpackPlugin(),
  ],
  devServer: {
    hot: true,
    host: 'localhost',
    port: 9090,
    open: true,
    compress: true,
    static: {
      directory: path.join(__dirname, '../public'), // 同之前的devServer.contentBase
      // publicPath: '/test', // 同之前的devServer.publicPath
      watch: true // 同之前的devServer.watchContentBase
    },
    proxy: {
      // '/api': 'http://httpbin.org',
      '/api': {
        target: 'http://httpbin.org',
        pathRewrite: {
          '^/api': ''
        },
        changeOrigin: true
      },
      '/hello': {
        target: 'http://localhost:9999',
        pathRewrite: {
          '^/hello': ''
        },
        logLevel: 'debug',
        changeOrigin: true
      }
    },
    historyApiFallback: true,
    // historyApiFallback: {
    //   rewrites: [
    //     {from: /abc/, to: "/index.html"}
    //   ]
    // }
  }
})
```

`webpack.prod.js`

```js
const { merge } = require('webpack-merge');
const baseConfig = require('./webpack.base'); 

module.exports = merge(baseConfig, {
  mode: "production",
})
```

### 方案二 environment参数

在package.json中添加脚本：

```json
"scripts": {
  "build2": "webpack --config ./config/webpack.common.js --env production",
  "serve2": "webpack serve ./config/webpack.common.js --env development"
},
```

然后我们在`config/webpack.common.js`中以导出函数形式实现配置：

```js
const path = require('path')

module.exports = function (env) {
  console.log('======= env ========', env)

  return {
    context: path.resolve(__dirname, '../'),
    entry: './src/main.js',
    output: {
      path: path.resolve(__dirname, '../build')
    }
  }
}
```

执行`npm run build2`可以看到日志输出：

```js
======= env ======== { WEBPACK_BUNDLE: true, WEBPACK_BUILD: true, production: true }
```

那么，就可以根据`env.production`来区分环境。

具体配置略过。

### 入口和上下文配置

我们可以注意到，配置文件在`config`目录下，但是我们的`entry`配置为`'./src/main.js'`，而不是`../src/main.js`。

这里`entry`的相对路径和`context`即上下文配置有关，上下文是入口文件所处的目录的绝对路径的字符串。

默认使用 Node.js 进程的当前工作目录，也就是我们运行脚本，如`npm run build2`时的执行目录。通常就是我们的根目录。

上面的`context`的配置是上一级目录，也等同于默认配置，指向了根目录。

如果配置`context`为当前目录即`path.resolve(__dirname, './')`，那么`entry`配置如下：

```js
const path = require('path')

module.exports = function (env) {
  return {
    context: path.resolve(__dirname, './'),
    entry: '../src/main.js',
    output: {
      path: path.resolve(__dirname, '../build')
    }
  }
}
```



