# Vue的静态属性和方法

在VUe的入口文件分析中，`initGlobalAPI(Vue)`初始化了全局的静态属性和方法，即全局API。

全局API的实现与Vue其它部分代码关联不大，本节统一记录Vue全局静态API的实现方法的实现，便于预览。

```js
/* @flow */

import config from '../config'
import { initUse } from './use'
import { initMixin } from './mixin'
import { initExtend } from './extend'
import { initAssetRegisters } from './assets'
import { set, del } from '../observer/index'
import { ASSET_TYPES } from 'shared/constants'
import builtInComponents from '../components/index'
import { observe } from 'core/observer/index'

import {
  warn,
  extend,
  nextTick,
  mergeOptions,
  defineReactive
} from '../util/index'

/**
 * Vue实例静态属性和方法
 */

export function initGlobalAPI (Vue: GlobalAPI) {
  // config
  const configDef = {}
  configDef.get = () => config
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = () => {
      // 警告 不要直接替换掉Vue.config的定义
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      )
    }
  }
  Object.defineProperty(Vue, 'config', configDef)

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn,
    extend,
    mergeOptions,
    defineReactive
  }

  Vue.set = set
  Vue.delete = del
  Vue.nextTick = nextTick

  // 2.6 explicit observable API
  Vue.observable = <T>(obj: T): T => {
    observe(obj)
    return obj
  }

  Vue.options = Object.create(null)
  ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
  })

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue

  // 扩展内置组件 options.components
  extend(Vue.options.components, builtInComponents)
  
  initUse(Vue)
  initMixin(Vue)
  initExtend(Vue)
  initAssetRegisters(Vue)
}
```

## Vue.config

将Vue.config设置为访问器属性，添加`getter`、`setter`方法，做了一层代理

允许修改`Vue.config`的属性值，但不允许重新赋值整个config，否则会提示警告。

Vue全局配置，默认config在`src/core/config.js`中，有如下字段：

```js
export type Config = {
  // user
  optionMergeStrategies: { [key: string]: Function };
  silent: boolean;
  productionTip: boolean;
  performance: boolean;
  devtools: boolean;
  errorHandler: ?(err: Error, vm: Component, info: string) => void;
  warnHandler: ?(msg: string, vm: Component, trace: string) => void;
  ignoredElements: Array<string | RegExp>;
  keyCodes: { [key: string]: number | Array<number> };

  // platform
  isReservedTag: (x?: string) => boolean;
  isReservedAttr: (x?: string) => boolean;
  parsePlatformTagName: (x: string) => string;
  isUnknownElement: (x?: string) => boolean;
  getTagNamespace: (x?: string) => string | void;
  mustUseProp: (tag: string, type: ?string, name: string) => boolean;

  // private
  async: boolean;

  // legacy
  _lifecycleHooks: Array<string>;
};
```
## Vue.util

扩展内部工具函数，如果不知道这些方法的风险，不建议外部使用。这里只是提供了一个访问这些方法的方式。

```js
Vue.util = {
  warn,
  extend,
  mergeOptions,
  defineReactive
}
```

### warn

`warn()`一个Vue内部常用到的方法，我们在开发阶段看到的警告提示，大都是调用此方法输出的。

在`src/core/util/debug.js`文件中可看到

```js
import config from '../config'
import { noop } from 'shared/util'

export let warn = noop
export let tip = noop
export let generateComponentTrace = (noop: any)
export let formatComponentName = (noop: any)

if (process.env.NODE_ENV !== 'production') {
  const hasConsole = typeof console !== 'undefined'
  // ...

  warn = (msg, vm) => {
    const trace = vm ? generateComponentTrace(vm) : ''

    if (config.warnHandler) {
      // 全局config自定义有warnHandler，调用自定义处理
      config.warnHandler.call(null, msg, vm, trace)
    } else if (hasConsole && (!config.silent)) {
      console.error(`[Vue warn]: ${msg}${trace}`)
    }
  }

  tip = (msg, vm) => {
    if (hasConsole && (!config.silent)) {
      console.warn(`[Vue tip]: ${msg}` + (
        vm ? generateComponentTrace(vm) : ''
      ))
    }
  }

  formatComponentName = (vm, includeFile) => {
    // ...
  }
  generateComponentTrace = vm => {
    // ...
  }
}
```

这里导出4个debug函数

* warn
* tip
* formatComponentName
* generateComponentTrace

生产环境下，这4个方法为`noop`；非生产环境下，会重新定义。

warn()函数，全局配置中定义了`config.warnHandler`，则调用此处理；否则，调用`console.error`输出警告。

### extend

在`src/shared/util.js`文件中定义。

```js
/**
 * Mix properties into target object.
 */
export function extend (to: Object, _from: ?Object): Object {
  for (const key in _from) {
    to[key] = _from[key]
  }
  return to
}
```

方法十分简单，将`_from`对象上的属性，合并到`to`对象上，如果属性相同，则用新的属性值覆盖旧值。

### mergeOptions、defineReactive

mergeOptions 根据不同的合并策略，合并options。详见Vue的options的合并策略

defineReactive 将对象上的属性设置成响应式的。详见深入响应式原理

## Vue.set\delete\nextTick\observable

```js
Vue.set = set
Vue.delete = del
Vue.nextTick = nextTick

// 2.6 explicit observable API
Vue.observable = <T>(obj: T): T => {
  observe(obj)
  return obj
}
```

这四个方法均是响应式相关。详见深入响应式原理

## Vue.options

该属性是Vue构造函数的默认options，在此进行了初始化。

```js
Vue.options = Object.create(null)
ASSET_TYPES.forEach(type => {
  Vue.options[type + 's'] = Object.create(null)
})

// this is used to identify the "base" constructor to extend all plain-object
// components with in Weex's multi-instance scenarios.
Vue.options._base = Vue // 指向Vue构造函数本身

// 扩展内置组件keep-alive到 options.components
extend(Vue.options.components, builtInComponents)
```

在实例化Vue时，我们会传入自定义的options，如最简单的：

```js
// 传入我们自定义的options
new Vue({
  el: "#app",
  data: {
    msg: "Hello Vue",
  },
})
```

或者是我们开发中定义的复杂的组件，如以`data`定义实例中的响应式数据，以`computed`描述实例中的计算属性，以`components`来进行组件注册，并且定义各个阶段生命周期的钩子等，这些都是在一个对象中包裹，这个对象就是用户自定义options。

那么在Vue初始化时，用户自定义options就描述了我们想要的Vue实例的行为。

其实Vue内部本身会自带一些默认的options，这些options和用户自定义的options会在后续一起合并参与到Vue实例的初始化中。合并后保存在`vm.$options`中。


Vue内部的默认options保留在Vue.options属性上，分别有：

* _base 指向Vue基类构造函数本身
* components 存储全局注册的组件
* directives 存储全局注册的指令
* filters 储存全局注册的过滤器

使用`extend`方法，Vue默认在这里给components扩展了内置`keep-alive`。

```js
extend(Vue.options.components, builtInComponents)
```

在`src/platforms/web/runtime/index.js`扩展Web平台配置中，options中该扩展了指令`v-model`、`v-show`和组件`transition-group`、`transition`

```js
// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives) // v-model v-show
extend(Vue.options.components, platformComponents) // transition-group transition
```

对于Web平台，Vue.options默认如下：

```js
Vue.options = {
  _base: Vue,
  components: {
    KeepAlive,
    Transition,
    TransitionGroup,
  },
  directives: {
    model,
    show
  },
  filters: {}
}
```

当我们调用`Vue.component\filter\directive` 注册或获取全局的组件、过滤器、指令时，本质上是在访问`Vue.options.component\filter\directive`对应的三个属性进行获取属性或注册新属性。

### Vue.component\filter\directive

通过`initAssetRegisters(Vue)`扩展这三个方法。

`Vue.component\filter\directive` 注册或获取全局的组件、过滤器、指令。

```js
/* @flow */

import { ASSET_TYPES } from 'shared/constants'
import { isPlainObject, validateComponentName } from '../util/index'

export function initAssetRegisters (Vue: GlobalAPI) {
  /**
   * Create asset registration methods.
   *  初始化3个全局函数
   *    Vue.component()
   *    Vue.directive()
   *    Vue.filter()
   * 调用方法时，其实是向Vue.options[components|directives|filters]中添加定义或获取定义
   */
  ASSET_TYPES.forEach(type => {
    Vue[type] = function (
      id: string,
      definition: Function | Object
    ): Function | Object | void {
      if (!definition) {
        // 只传id 直接返回该id的对应的asset
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' && type === 'component') {
          validateComponentName(id)
        }

        // 全局同步组件
        if (type === 'component' && isPlainObject(definition)) {
          // 有name，使用name作为组件名，否则使用id作为组件名
          definition.name = definition.name || id
          // 使用definition作为options 调用Vue.extend生成注册组件构造函数
          definition = this.options._base.extend(definition)
        }

        // 全局指令
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition }
        }

        /**
         * 对全局Vue.options进行扩展
         *  filter 直接赋值
         *  异步组件 直接赋值
         */
        this.options[type + 's'][id] = definition
        // 返回调用asset函数后的definition
        return definition
      }
    }
  })
}
```

### Vue.extend

通过`initExtend(Vue)`扩展`Vue.extend()`方法。

该方法的主要作用是基于Vue基类，创建一个子类构造函数。

当我们创建子组件时，会调用这个方法。在写小的Demo中我们可能会手动调用。在实际的项目开发中，Vue内部也是通过这个方法来实例化子类Vue实例的。

详见

### Vue.use

通过`initUse(Vue)`扩展`Vue.use()`方法。

该方法主要作用是向`Vue._installedPlugins = []`中添加插件，同一个插件只会被添加一次

```js
/* @flow */

import { toArray } from '../util/index'

export function initUse (Vue: GlobalAPI) {
  // 向Vue._installedPlugins中添加插件
  Vue.use = function (plugin: Function | Object) {
    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
    if (installedPlugins.indexOf(plugin) > -1) {
      // 已添加过
      return this
    }

    // additional parameters
    const args = toArray(arguments, 1)
    args.unshift(this) // 第一个参数是Vue本身
    if (typeof plugin.install === 'function') {
      // 执行插件的install方法
      plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
      // plugin是一个函数，当作install方法执行
      plugin.apply(null, args)
    }
    installedPlugins.push(plugin)
    return this
  }
}
```

### Vue.mixin

通过`initMixin(Vue)`扩展`Vue.mixin()`方法。

`Vue.mixin()`实际上调用的是`mergeOptions`，详见Vue的options合并策略

```js
import { mergeOptions } from '../util/index'

export function initMixin (Vue: GlobalAPI) {
  Vue.mixin = function (mixin: Object) {
    // mixin 实际是调用 mergeOptions 混入到 Vue.options 
    this.options = mergeOptions(this.options, mixin)
    return this
  }
}
```

## 小结

这里主要的方法，我们在开发中常见的，这里也只是将所有的方法大概列出，对简单的实现做一些分析，未涉及到的在之后具体的分析会涉及到。
