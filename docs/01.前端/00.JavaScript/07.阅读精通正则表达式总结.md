---
title: 阅读精通正则表达式总结
date: 2022-09-29 17:02:42
permalink: /pages/78ad41/
categories:
  - 前端
  - JavaScript
tags:
  - 
---
# 精通正则表达式

本书的目的不是提供具体问题的解决办法，而是教会读者利用正则表达式来思考，解决遇到的各种问题。

**正则表达式不是死板的教条，它更像是门艺术。**

## 第1章 正则表达式入门

### 什么是正则表达式

完整的正则表达式由两种字符构成：特殊字符，如元字符`*`  和 普通文本字符。

类比日常语言，普通字符对应单词，特殊字符对应的就是语法。根据语言规则，按照语法把单词组合起来，就会得到能传达思想的文本。

完整的正则表达式由小的构建模块单元（building block unit）组成，每个单独的构建模块都很简单，不过因为它们能够以无穷多种方式组合，将它们结合起来实现特殊目标必须依靠经验。

### 行的起始^和 结束$

脱字符号`^`代表一行的开始； 美元符号`$`代表一行的结束。

脱字符号`^`和美元符号`$`的特别之处就在于，**它们匹配的是一个位置，而不是具体的文本。**

最好能养成按照字符来理解正则表达式的习惯：

* 不要这样：`^cat`匹配以cat开头的行
* 而要按照字符解读：**`^cat`匹配的是以 c 作为一行的第一个字符，紧接一个 a，紧接一个 t 的文本。**

这两种理解的结果并无差异，但按照字符来解读更易于明白新遇到的正则表达式的内部逻辑。

![精通正则表达式1-01](https://cdn.staticaly.com/gh/ccbeango/blogImages@master/精通Regex/精通正则表达式1-01.png)

### 字符组 [ ]

字符组的表达式为`[...]`，它的作用是列出在某处期望匹配的字符。

**例子：搜索单词`grey`或`gray`**

`[ea]`能够匹配到`a`或`e`，所以`/gr[ea]y/`就是先找到g，跟着是一个r，然后是
一个a或者e，最后是一个y。

注意：

* 在字符组以外，普通字符（例如`/gr[ae]y/`中的 g 和 r）都有**接下来是**（and then）的意思，首先匹配 g，接下来是 r ······
* 在字符组内部，情况完全相反，字符组的内容是在**同一个位置**能够匹配的若干字符，它的意思是**或**

#### 连字符

在**字符组内部**，连字符`-`表示一个范围，而且允许多重范围，也允许随意组合字符范围和普通文本：

* `[0-9]`、`[a-z]`：匹配**一个**数字、匹配**一个**小写字母
* `[0-9a-fA-F]`：匹配**一个**数字、小写字母 a 到 f或大写字母 A 到 F 。顺序无所谓，即等价于`[A-Fa-f0-9]`
* `[0-9A-Z_!.?]`：匹配**一个**数字、大写字母、下画线、惊叹号、点号，或问号
* 字符组开头的连字符只是一个普通的连字符号

在字符组内部，真正的特殊字符是连字符，在字符组外部的特殊字符在内部仅是普通字符。**可以把字符组看作独立的微型语言。在字符组内部和外部，关于元字符的规定（哪些是元字符，以及它们的意义）是不同的**

#### 排除型字符组

排除型字符组的表达式为`[^...]`，这个字符组匹配任何未列出的字符，也就是这里列出的是不希望匹配的字符。

**脱字符号`^`必须在第一个方括号之后，表示排除，否则它只是一个普通字符。**

例子：

* `[^1-6]` 匹配1到6以外的任何字符
* `q[^u]` 匹配字母 q 后面字母不是 u
  * 可以匹配到单词Iraqi、qasida
  * 不可以匹配单词Iraq，**因为一个字符组，即使是排除型字符组，也要匹配一个字符**。如果Iraq后面又空格或者换行符，也可以匹配到。

请记住，排除型字符组表示：**匹配一个未列出的字符，而不是不要匹配列出的字符。（match a character that's not listed，don't match what is listed）**

### 任意字符 .

点号`.`用来匹配一个任意字符。它是用来匹配任意字符的字符组的简写。

例子：搜索03/19/76、03-19-76或者03.19.76

这里，可以用一个明确的字符组`[-./]`来匹配，也可以使用点号`.`来匹配

```js
const str = '03/19/76 03-19-76 03.19.76'

// 方法一
const regex1 = /03[-./]19[-./]76/g
// match1：['03/19/76', '03-19-76', '03.19.76']
const match1 = str.match(regex1)

// 方法二
const regex2 = /03.19.76/g
// match2：['03/19/76', '03-19-76', '03.19.76']
const match2 = str.match(regex2)
```

方法一更准确。方法二还可以匹配到`03x19y76`或`19 203319 7639`等很多其它结果。

那么应该如何选择？取决于你对需要检索文本的了解，以及你需要达到的准确程度。

一个重要但常见的问题是，**写正则表达式时，我们需要在对欲检索文本的了解程度与检索精确性之间求得平衡**。例如，如果我们知道，针对某个检索文本，`/03.19.76/g`这个正则表达式基本不可能匹配不期望的结果，那么使用它就是合理的。要想正确使用正则表达式，清楚地了解目标文本是非常重要的。

### 多选结构 |

竖杠`|`表示或，可以用它将把不同的子表达式组合成一个总的表达式，而这个总的表达式又能匹配任意的子表达式。

`Rob`和`Robert`是两个子表达式，`Rob|Robert`就可以匹配其中任意一个正则表达式。在这样的组合中，子表达式被称为**多选分支**（alternative）。

**例子：搜索单词`grey`或`gray`**

字符组方法：`/gr[ea]y/`

多选结构：

* `/grey|gray/` 
* 或使用括号 `/gr(a|e)y/`。

**括号可以用来界定元字符的作用范围。**多选结构可以包括很多字符，但不能超越括号的界限。

其它例子：

* `/(First|1st) [Ss]treet/`，都是`st`结尾，也可以把前面部分改成`/(Fir|1)st/`

  ```js
  const str = 'First Street | First street | 1st Street | 1st street'
  
  const regex1 = /(First|1st) [Ss]treet/g
  const match1 = str.match(regex1)
  console.log(match1)
  
  const regex2 = /(Fir|1)st [Ss]treet/g
  const match2 = str.match(regex2)
  console.log(match2)
  ```

* `^(From|Subject|Date):`，匹配以From：Subject：或者Date：开头的文本行

### 可选项元素 ?

问号`?`表示之前紧邻的元素出现零次或一次。

**例子：匹配7月4日，其中月份可写为July或Jul，日子可写为fourth、4th、4**

正则表达式：`/July? (fourth|4(th)?)/`，**括号用于界定元字符的作用范围**。

```js
const str = 'July 4th | July fourth | July 4 | Jul 4th |  Jul 4'

const regex1 = /July? (fourth|4(th)?)/g
const match1 = str.match(regex1)
console.log(match1)
```

### 重复出现元素 + *

加号`+`表示之前紧邻的元素出现一次或多次。

星号`*`表示之前紧邻的元素出现任意多次，或者不出现。

**例子：匹配HR标签，并且可设置SIZE**

```js
const str = '<HR SIZE=14> <HR SIZE = 14 > <HR SIZE= 14    >'

const regex1 = /<HR +SIZE *= *[0-9]+ *>/g
const match1 = str.match(regex1)
console.log(match1)
```

* 使用空格加加号`/ +/`来匹配HR和SIZE之间的一个空格，空格加星号` / */`来匹配后面位置的任意多个空格。

### 量词

**问号、加号、星号这三个元字符统称为量词。因为它们限定了所作用元素的匹配次数。**

每个量词都规定了匹配成功至少需要的次数下限，以及尝试匹配的次数上
限。对某些量词来说，下限是0，对某些量词来说，上限是无穷大。

这里还有一种量词是区间量词，它能够使用元字符序列来自定义重复次数的区间，语法为`...{min,max}`，如`...{3, 12}`表示能够容许前面的元素重现次数在3到12之间。

| 量词       | 次数下限 | 次数上限 | 含义           |
| ---------- | -------- | -------- | -------------- |
| ?          | 无       | 1        | 单次可选       |
| *          | 无       | 无       | 任意次数均可   |
| +          | 1        | 无       | 至少一次       |
| {min, max} | min      | max      | 出现min到max次 |

### 括号及反向引用

括号有两种用途：

* 第一种是上面提到的，**界定元字符的作用范围**
* 第二种是**记住它们包含的子表达式匹配的文本**，称为**捕获**，然后可以用**反向引用**来调用捕获到的值。

反向引用是正则表达式的特性之一，它允许我们**匹配与表达式先前部分匹配的同样文本**。也就是允许我们调用之前捕获到的值。

在一个表达式中我们可以使用多个括号。再用`\1`、`
\2`、`\3`等来表示第一、第二、第三组括号匹配的文本。括号是按照开括号`(`从左至右的出现顺序进行
的，所以`/([a-z])(0-9)\1\2`中的`\1`代表`[a-z]`匹配的内容，而`\2`代表`
[0-9]`匹配的内容。

**例子：查询重复的单词正则**

```js
const str = 'hello hello world, this is a test test, not the theory'

const regex  = /\b([a-z]+) +\1\b/ig

const match = str.match(regex)

console.log('match', match)
```

### 转义符

在字符组外部，使用斜杠加元字符时，如`\.`，斜杠`\`表示转义符，它作用的元字符会失去而特殊含义，成为普通字符。

特殊的元字符包括：`( [ { \ ^ $ | ) ] } ? * + .`

### 理解子表达式

子表达式指的是整个正则表达式中的一部分，通常是括号内的表达式，或者是由`|`分隔的多选分支。

例如，在`^(Subject|Date):`中，`Subject|Date`通常被视为一个子表达式。其中的`Subject`和`Date`也算得上子表达式。而且，严格说起来，`S`、`u`、`b`、`j`这些字符，都算子表达式。`1-6`这样的字符序列并不能算`H[1-6] *`的子表达式，因为`1-6`所属的字符组是不可分割的**单元（unit）**。但是，`H`、`[1-6]`、`·＊`都是`H[1-6]·*`的子表达式。

与多选分支不同的是，量词（星号、加号和问号）作用的对象是它们之前紧邻的子表达式。所以`mis+pell`中的`+`作用的是`s`，而不是`mis`或者`is`。当然，如果量词之前紧邻的是一个括号包围的子表达式，整个子表达式（无论多复杂）都被视为一个单元。

### 更多的例子

1. 匹配程序中的标识符：标识符只包含字母、数字以及下划线，但不能以数字开头。

   ```js
   const regex = /[a-zA-Z_][a-zA-Z_0-9]*/
   
   // 如果标识符长度有限制，如最长32个字符
   const regex2 = /[a-zA-Z_][a-zA-Z_0-9]{0,31}/
   ```

2. 匹配引号内的字符串。

   ```js
   // 用[^"]匹配除双引号之外的任何字符
   const regex = /"[^"]*"/
   ```

3. 匹配美元金额，可能包含小数

   ```js
   const str = 'Shirts $9.45, pants $12, shoes $20'
   
   const regex = /\$[0-9]+(\.[0-9][0-9])?/g
   
   const match = str.match(regex)
   console.log(match)
   ```

4. 匹配时间，12小时制，如`09:17 am`、`12:30 pm`，避免匹配不正确时间，如`99:33 am`

   ```js
   const str = '09:17 am 12:30 pm 99:33 am'
   
   const regex = /(1[012]|0[1-9]):[0-5][0-9] (am|pm)/g
   
   const match = str.match(regex)
   console.log(match)
   ```

5. 匹配时间，24小时制，如`18:17`、`09:45`

   ![精通正则表达式1-02](https://cdn.staticaly.com/gh/ccbeango/blogImages@master/精通Regex/精通正则表达式1-02.png.png)

## 第二章 入门示例拓展

