---
title: 数据结构与算法-红黑树（二）
date: 2022-01-09 12:50:22
permalink: /pages/2be117/
categories:
  - JavaScript数据结构与算法
tags:
  - 
---
# 数据结构与算法-红黑树（二）

红黑树的规则：

* 规则1：每个节点的颜色不是红色的，就是黑色的
* 规则2：根节点是黑色的
* 规则3：每个叶子节点Nil都是黑色的
* 规则4：不能连续两红
* 规则5：任一节点的左右子树黑高相等

## 红黑树的删除操作

### 二叉搜索树删除操作

我们先来简单回顾下二叉搜索树的删除操作。假如我们有一个搜索二叉树（省略Nil节点）如下：

![红黑树30](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/红黑树30.svg)

二叉搜索树中删除节点有3种场景：

- 场景 1：删除节点无子节点，可以直接删除。如删除6。
- 场景 2：删除节点只有一个子节点，则将父结点的指向它的孩子。如删除8，然后7指向8的子节点9即可。
- 场景 3：删除节点有两个子节点，可以用前驱（后继）节点替换删除节点。如删除15，找到15的前驱节点9，交换15与9的位置，然后删除15即可，此时删除15就退化成了删除单个节点。

![红黑树31](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/红黑树31.svg)

所以删除节点有两个子节点时，交换节点与前驱（后继）节点位置，然后再删除节点。

**总结：所有删除，最后都会退化成：**

* **删除单个子节点：**待删除节点有两个子（树）节点 或 待删除节点没有子节点
* **删除只有一个子树的节点：** 待删除节点有一个子（树）节点

那么我们在红黑树种，就不需要考虑删除的节点有两个双子树的情况，只需要考虑删除单个节点或删除节点只有一个子树。

### 红黑树的删除操作

红黑树删除分为两个部分：

* 一是按照二叉搜索树删除对应节点
* 二是删除之后的自平衡。

二叉树的删除操作我们已分析过，下面来看自平衡的维护。

#### 情况1 - 删除只有一个子树的节点

**删除只有一个子树的节点**

可以推断出的是，待删除节点必定是黑色（红色结点不可能只有一个孩子），且唯一的子树一定是单个红色节点。否则都会违反红黑树规则。

这种情况下需要：

1. 删除黑色节点D
2. 用红色S节点变成黑色顶替D节点

![红黑树32](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/红黑树32.svg)

其它情况下，均不满足红黑树的规则：

* D、S都为红色，违反规则4
* D黑S黑、D红S黑，违反规则5
* S不是单个红节点而是一个子树，更是违反规则5

#### 情况2 - 删除单个红色子节点

**删除单个红色子节点**

删除的节点是红色节点，删除之后不影响红黑树的平衡，结束处理。

### 删除单个黑色子节点

删除单个黑色子节点，则会破坏树的平衡。

如果待删除结点为黑色，这种情况下，不可能通过涂色的方式弥补缺少的黑色，所以要判断其兄弟和侄子的状况，希望通过兄弟那边分支的旋转，来保持黑色的数量。

可归纳为以下4种情况：

* **黑兄弟，右红侄**
* **黑兄弟，左红侄**
* **黑兄弟，双黑侄**
* **红兄弟**

情况 3 到情况 6 是针对删除单个黑色子节点，且待删除节点是父节点的左孩子的分析。

#### 情况3

**黑兄弟，右红侄**

这种情况优先级最高，此时：

* 无视兄弟的左节点颜色以及是否存在；兄弟的左子节点一定是红色或不存在(Nil)，如果是黑色则违反规则5。
* 也无视父节点颜色。

**解决：左旋父，祖染父色，父叔黑。**

父节点为红色时：

* 首先，以P为支点进行左旋转
* 然后以待删除节点D为参照，祖父节点B染父节点P的颜色，B变成红色
* 待删除节点D的父节点P和叔叔节点BR变成黑色。
* 最后，删除D节点。BL可为红色或Nil节点

![红黑树33](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/红黑树33.svg)

父节点为黑色时：

* 首先，以P为支点进行左旋转
* 然后以待删除节点D为参照，祖父节点B染父节点P的颜色，B变成黑色；（B已经是黑色了，为了统一逻辑，还是进行此项操作）
* 待删除节点D的父节点P（已是黑色）和叔叔节点BR变成黑色
* 最后，删除D节点。BL可为红色或Nil节点

![红黑树34](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/红黑树34.svg)

#### 情况4

**黑兄弟，左红侄**

此时：

* 兄弟右侄子因为不是红的（情况3之外），所以一定不存在（Nil）。如果存在且是黑色，则违反规则5

**解决：右旋兄，交换兄弟与其右子颜色，变成情况3**

无视父节点颜色：

*  首先以兄弟节点B为支点右旋转
* 以D为参照，交换兄弟节点BL和其右子节点B的颜色，此时回归情况3：黑兄弟右红侄

![红黑树35](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/红黑树35.svg)

#### 情况5

**黑兄弟，双黑侄**

此时，两个侄子节点一定不存在（Nil）。如果存在，则违反规则5

**解决：兄弟红，向上找，遇根或红节点，染黑即解决；**

如果父节点P是根节点或红色，染成黑色即可解决：

* 首先将兄弟节点B染成红色，此时视角在D、B层
* 然后向上找，视角上移到P层，P为红色，变成黑色即可修复平衡

![红黑树36](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/红黑树36.svg)

如果父节点P是黑色：

* 首先将兄弟节点B染成红色，此时视角在D、B层
* 然后向上找，视角上移到P层，P为黑色，需要根据兄弟节点PB以及侄子节点分情况处理，总会回归到这几种情况。然后再根据对应情况处理即可。

![红黑树40](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/红黑树40.svg)

#### 情况6

**红兄弟**

此时，父节点一定是黑节点。

**解决：左旋父，父、祖换色，变成前3种情况**

处理：

* 首先以父节点P为支点左旋转
* 然后交换父节点P和祖父节点B的颜色此时BL节点情况

![红黑树37](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/红黑树37.svg)

此时，以目标节点D为参照，根据黑兄弟BL以及侄子节点情况可能变成的情况：

* 回归情况3：黑兄弟右红侄
* 回归情况4：黑兄弟左红侄
* 回归情况5：黑兄弟双黑侄

![红黑树38](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/红黑树38.svg)

那么至此，删除节点已分析完毕。待删除节点是父节点的右孩子的，正好是情况 3-6 的镜像，不再赘述。

