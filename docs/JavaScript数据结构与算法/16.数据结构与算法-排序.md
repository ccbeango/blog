---
title: 数据结构与算法-排序
date: 2022-01-18 09:53:02
permalink: /pages/0c5a57/
categories:
  - JavaScript数据结构与算法
tags:
  - 
---
# 数据结构与算法 - 排序

排序算法演示网站：https://visualgo.net/zh/sorting

## 排序介绍

一旦我们将数据放置在某个数据结构中存储起来后(比如数组)，就可能根据需求对数据进行不同方式的排序

- 比如对姓名按字母排序
- 对学生按年龄排序
- 对商品按照价格排序
- 对城市按照面积或者人口数量排序
- 对恒星按照大小排序

由于排序非常重要而且可能非常耗时，所以它已经成为一个计算机科学中广泛研究的课题，人们已经研究出一套成熟的方案来实现排序。学习已有的排序方法是非常有必要的。

## 冒泡排序

### 冒泡排序思路

1. 对未排序的元素从头到尾依次进行两两比较
2. 首先选取第1个元素和第2个比较，如果第一个元素大，则交换位置；否则不交换
3. 然后后移动一位，选择第2个和第3个进行比较，依次类推，当一轮比较完成，最大的在未排序元素的最右边，成为已排序元素。
4. 重复上面步骤，每一轮都会少一个待排序元素，直至所有元素排序完成

### 冒泡排序实现

```js
/**
 * 冒泡排序
 */
function bubbleSort(arr) {
  // 外层循环：根据元素个数，决定几轮冒泡
  for (let i = arr.length - 1; i > 0; i--) {
    for (let j = 0; j < i; j++) {
      // 内层循环：每轮比较相邻元素的大小
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
      }
    }
  }

  return arr
}
```

**代码分析**

通过两层循环来实现冒泡排序：

* 外层循环：控制一共需要多少轮冒泡；每轮排序都排除掉已经排序的元素。
  * 第一轮排序，冒泡到最后一个`length - 1`
  * 第二轮排序，冒泡到倒数第二个元素`lenght - 2`
* 内层循环：根据每轮冒泡未排序元素个数，确定每轮冒泡，相邻元素的比较次数
  * 第一次比较，0和1；
  * 第二次比较，1和2；以此类推

![排序1](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/排序1.png)

交换元素位置`swap`函数代码如下：

```js
/**
 * 交换元素位置
 * @param {*} arr 
 * @param {*} idxA 
 * @param {*} idxB 
 */
function swap(arr, idxA, idxB) {
  [arr[idxA], arr[idxB]] = [arr[idxB], arr[idxA]]
}
```

### 冒泡排序效率

比较次数：$$O(n^2)$$

* 第一次比较`n - 1`次，第二次比较`n-2`次，......最后一次比较`1`次
* 那么比较次数就是$$(n - 1) + (n - 2) + ... + 1 = \frac{n(n - 1)}{2}$$，即$$O(n^2)$$

交换次数：$$O(n^2)$$

* 每次比较有需要交换和不需要两种可能，如果每两次比较需要一次交换，那么交换次数就是$$\frac{n(n - 1)}{2} / 2 = \frac{n(n - 1)}{4}$$ 即 $$O(n^2)$$

## 选择排序

选择排序改进了冒泡排序，将交换的次数由O(N²)减少到O(N)，但是比较的次数依然是O(N²)

### 选择排序思路

1. 选择第1个索引位置元素，然后依次与后面元素比较
2. 比较过程中，如果第i个位置元素比第1个小，记录i位置索引
3. 每次比较都记录最小索引，一轮比较结束后，交换首次选出的待比较元素与最小元素的位置
4. 后移一位选择待比较元素，重复步骤，直到所有元素比较完毕

### 选择排序实现

```js
/**
 * 选择排序
 */
function selectionSort(arr) {
  // 外层循环：每次初始化标记最小元素位置索引
  for (let i = 0; i < arr.length - 1; i++) {
    let min = i
    for (let j = i + 1; j < arr.length; j++) {
      // 内层循环：记录一轮循环中，未排序的元素中最小元素位置索引
      if (arr[min] > arr[j]) {
        min = j
      }
    }
    // 最小元素位置索引不等于每次循环初始值 i 本身
    // 说明最小元素在后面，交换原i位置元素和min位置元素 
    if (i !== min) swap(arr, i, min)
  }

  return arr
}
```

**代码分析**

通过两层循环来实现冒泡排序：

* 外层循环：每次初始化标记最小元素位置索引
* 内层循环：记录一轮循环中，未排序的元素中最小元素位置索引
* 最小元素位置索引不等于每次循环初始值 i 本身，说明最小元素在后面，交换原i位置元素和min位置元素

### 选择排序效率

比较次数：$$O(n^2)$$

* 比较次数同冒泡排序，都为$$\frac{n(n - 1)}{2}$$，即$$O(n^2)$$

交换次数：$$O(n)$$

* 交换次数未$$n - 1$$，即$$O(n)$$
* 所以通常认为选择排序在执行效率上是高于冒泡排序的

## 插入排序

插入排序思想的核心是局部有序。

- 比如在一个队列中的人，我们选择其中一个作为标记的队员。这个被标记的队员左边的所有队员已经是局部有序的。
- 这意味着，有一部分人是按顺序排列好的。有一部分还没有顺序。

### 插入排序思路

1. 首先取出一个元素，认为该元素左边的元素已经是有序的。第一次取第一个元素
2. 从已选择元素的右侧取出一个新元素，然后从后向前依次与已排序元素进行比对
3. 如果本次选取已排序元素大于新元素，则向前移动一位继续选取已排序元素与新元素比对
4. 直到找到已选取元素小于新元素，将新元素插入到这个后面
5. 重复以上步骤直到所有元素排序完毕

### 插入排序实现

```js
/**
 * 插入排序
 */
function insertionSort(arr) {
  // 外层循环：每次选出待排序元素
  for (let i = 1; i < arr.length; i++) {
    const element = arr[i] // 选出待排序元素

    let j = i // 记录新插入位置 默认在原位置
    while (j > 0 && arr[j - 1] > element) {
      // 后移前一个元素
      arr[j] = arr[j - 1]
      j-- // 更新插入位置
    }
    // 插入元素到索引j位置
    arr[j] = element
  }
}
```

**代码分析**

通过两层循环实现插入排序：

* 外层循环：取出待插入（排序）元素
  * 从1开始，默认0位置已排序好
  * 选出待排序元素，暂存到element
* 内层while循环：确定插入位置
  * 如果前面元素大于待插入元素，将前面的元素后移一位
  * 更新插入位置`j--`

### 插入排序效率

比较次数：$$O(n^2)$$

* 第一次**最多**比较`1`次，第二次**最多**比较`2`次，...... 最后一次**最多**比较`n - 1`次
* 那么最多比较次数就是$$(n - 1) + (n - 2) + ... + 1 = \frac{n(n - 1)}{2}$$
* 但并不是每次插入都需要这么多次比较，可能只比较一次就插找到了插入位置
* 所以平均只有全体比较次数的一半，$$\frac{n(n - 1)}{2} / 2 = \frac{n(n - 1)}{4}$$
* 复杂度虽然仍是$$O(n^2)$$，但平均情况下，相对于选择排序，比较次数少了一半。
* 也就是说，**插入排序最差情况下比较次数等于选择排序和冒泡排序**

复制次数：$$O(n^2)$$

* 第一次**最多**复制`1`次，第二次**最多**复制`2`次，...... 最后一次**最多**复制`n - 1`次
* 那么最多复制次数就是$$(n - 1) + (n - 2) + ... + 1 = \frac{n(n - 1)}{2}$$
* 平均复制次数是$$\frac{n(n - 1)}{2} / 2 = \frac{n(n - 1)}{4}$$

交换次数：$$O(n)$$

* 交换次数为外层循环次数

对于基本有序的情况

- 对于已经有序或基本有序的数据来说，插入排序要好很多。
- 当数据有序的时候，while循环的条件总是为假，所以它变成了外层循环中的一个简单语句，执行N-1次
- 在这种情况下，算法运行至需要N(N)的时间，效率相对来说会更高
- 另外别忘了，我们的比较次数是选择排序的一半，所以这个算法的效率是高于选择排序的

## 希尔排序

希尔排序，也称递减增量排序，是插入排序的一种更高效的改进版本。

- 希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布。
- 希尔算法首次突破了计算机界一直认为的**算法的时间复杂度都是$$O( n^2)$$**的大关，为了纪念该算法里程碑式的意义，用Shell来命名该算法

回顾插入排序：

* 在插入排序执行到一半的时候，标识符左边这部分数据项都是排好序的，而标识符右边的数据项是没有排序的
* 此时，取出指向的那个数据项，把它存储在一个临时变量中；接着，从刚刚移除的位置左边第一个单元开始，每次把有序的数据项向右移动一个单元，直到存储在临时变量中的数据项可以成功插入

插入排序的问题：

* 假设一个很小的数据项在很靠近右端的位置上，这里本来应该是较大的数据项的位置

* 把这个小数据项移动到左边的正确位置，所有的中间数据项都必须向右移动一位

* 如果每个步骤对数据项都进行n次复制，平均下来是移动n/2，N个元素就是n²/2，所以我们通常认为插入排序的效率是$$O(n^2)$$
* 如果有某种方式，不需要一个个移动所有中间的数据项，就能把较小的数据项移动到左边，那么这个算法的执行效率就会有很大的改进，希尔排序实现了这种方法

### 希尔排序思路

希尔排序主要通过对数据进行**分组**实现快速排序

1. 首先确定一个增量gap，按序列增量进行分组
2. 根据设定的增量gap将序列分为gap个组，每组再进行局部的插入排序
3. 排序完成后，减小增量gap，每组再进行局部单独排序，直至gap减小到1，进行最后一次排序即可。

整个排序过程和插入排序思路相同，区别在于，比较后希尔排序元素可能需要移动gap，插入排序每次移动1。gap为1时，就是插入排序。

![排序2](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/排序2.png)

如上图：81, 94, 11, 96, 12, 35, 17, 95, 28, 58, 41, 75, 15.

* 我们先让间隔为5分组，同颜色为一组，得到 (81, 35, 41)、(94, 17, 75)、(11, 95, 15)、(96, 28)、(12, 58)
* 分组插入排序后的新序列，一定可以让数字离自己的正确位置更近一步
* 再让间隔位3，得到(35, 28, 75, 58, 95)、(17, 12, 15, 81)、(11, 41, 96, 94)
* 分组插入排序后的新序列，让数字离自己的正确位置又近了一步
* 最后，我们让间隔为1，也就是所有数据看成一组进行插入排序，这时，数字都离自己的位置更近，那么需要复制的次数一定会减少很多

**增量gap选择**

原始序列：

* 希尔排序原稿中，他建议的初始间距是N / 2，简单的把每趟排序分成两半
* 也就是说，对于N = 100的数组，增量间隔序列为: 50、25、12、6、3、1
* 最坏时间复杂度是$$O(n^2)$$

Knuth增量序列：

* {1, 4, 13, 40 ...}，多项式为$$\frac{1}{2}(3^k-1)$$ 
* 最坏时间复杂度是$$O(n^\frac{3}{2})$$

Hibbard增量序列：

*  {1, 3, 5, 7 ...} ，多项式为$$2^k - 1$$
* 这种增量的最坏复杂度为$$O(n^\frac{3}{2})$$；猜想的平均复杂度为$$O(n^\frac{5}{4})$$，未被证明

Sedgewick增量序列：

* {1, 5, 19, 41, 109 ...}，该序列的多项或是$$9 * 4^i - 9 * 2^1 + 1$$或是$$4^i - 3 * 2^i + 1$$
* 猜想：最坏复杂度为$$O(n^\frac{4}{3})$$，平均复杂度为$$O(n^\frac{7}{6})$$

### 希尔排序实现

```js
/**
 * 希尔排序
 */
function shellSort(arr) {
  // 普通增量序列
  // let gap = Math.floor(arr.length / 2) // 默认增量

  // Knuth增量序列
  let gap = 1
  while (gap < arr.length / 3) { // gap 1, 4, 13, 40 ...
    gap = gap * 3 + 1
  }

  // 第一层循环：while循环，使gap不断减小
  while (gap > 0) {
    // 第二层循环：插入排序 以gap为增量，进行分组，对分组进行插入排序
    // 每组从第二个开始排序，默认第一个为有序的
    for (let i = gap; i < arr.length; i++) {
      let element = arr[i]

      // 第三层循环：确定插入位置
      let j = i
      while (j >= gap && arr[j - gap] > element) {
        arr[j] = arr[j - gap] // 每次元素后移gap
        j -= gap
      }

      arr[j] = element
    }

    // 普通增量 重新计算增量
    // gap = Math.floor(gap / 2)
    // Knuth增量 重新计算增量
    gap = (gap - 1) / 3
  }

  return arr
}
```

代码分析：

1. 首先确定gap增量，第一层循环控制增量不断减小，直至`gap = 1`
2. 第二层循环，以gap为增量，进行分组，对分组进行插入排序
3. 第三层循环：确定插入位置，元素需要后移时，后移gap长度

### 希尔排序效率

希尔排序的效率和增量有直接关系

- 原稿中的增量效率都高于简单排序，最坏时间复杂度$$O(n^2)$$
- Knuth增量序列，最坏时间复杂度是$$O(n^\frac{3}{2})$$
- Hibbard增量序列，最坏时间复杂度为$$O(n^\frac{3}{2})$$
- Sedgewick增量序列，最坏复杂度为$$O(n^\frac{4}{3})$$

## 快速排序

### 快速排序思路

### 快速排序实现

### 快速排序效率

## 堆排序

### 堆排序思路

### 堆排序实现

### 堆排序效率

## 归并排序

### 归并排序思路

### 归并排序实现

### 归并排序效率

## 桶排序

### 桶排序思路

### 桶排序实现

### 桶排序效率

## 基数排序

### 基数排序思路

### 基数排序实现

### 基数排序效率

## 计数排序

### 计数排序思路

### 计数排序实现

### 计数排序效率
