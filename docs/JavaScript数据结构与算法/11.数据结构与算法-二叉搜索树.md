---
title: 数据结构与算法-二叉搜索树
date: 2021-12-29 18:30:56
permalink: /pages/43a3be/
categories:
  - JavaScript数据结构与算法
tags:
  - 
---
# 数据结构与算法-二叉搜索树

二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。

## 二叉搜索树的定义

二叉搜索树是一棵二叉树，可以为空。

如果不为空，则满足以下性质：

* 非空左子树的所有键值小于其根节点的键值
* 非空右子树的所有键值大于其根节点的键值
* 左、右子树本身也都是二叉搜索树

![二叉搜索树01](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树01.png)

如上图所示，树二和树三符合 3 个条件属于二叉树，树一不满足条件 3 所以不是二叉树。

总结：二叉搜索树的特点就是相对较小的值总是保存在左结点上，相对较大的值总是保存在右节点上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中“搜索”的来源。

### 应用举例

下面是一个二叉搜索树：

![二叉搜索树02](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树02.png)

若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。

* 第 1 次：将 10 与根节点 9 进行比较，由于 10 > 9，所以 10 下一步与根节点 9 的右子节点 13 比较；
* 第 2 次：由于 10 < 13，所以 10 下一步与父节点 13 的左子节点 11 比较；
* 第 3 次：由于 10 < 11，所以 10 下一步与父节点 11 的左子节点 10 比较；
* 第 4 次：由于 10 = 10，最终查找到数据 10 。

![二叉搜索树03](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树03.png)



同样是 15 个数据，如果在未排序好的数组中查询数据 10，需要查询 10 次：

![二叉搜索树04](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树04.png)

如果是排序好的数组，可以通过二分查找：第一次找 8，第二次找 12，第三次找 11，第四次找10。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树。这就是数组二分法查找效率之所以高的原因。

## 二叉搜索树的封装

二叉搜索树有四个最基本的属性：指向节点的根（root），节点中的键（key）、左指针（right）、右指针（right）。

![二叉搜索树05](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树05.png)

所以，二叉搜索树中除了定义 root 属性外，还应定义一个节点内部类，里面包含每个节点中的 left、right 和 key 三个属性。

```js
class Node {
  constructor (key, value) {
    this.key = key // 节点对应的key
    this.value = value
    this.left = null // 指向的左子树
    this.right = null // 指向的右子树
  }
}
```

### 常见操作

- `insert(key)` 向树中插入一个新的键。
- `search(key)` 在树中查找一个节点，如果节点存在，则返回 true；如果不存在，则返回 `false`。
- `preOrderTraverse` 通过先序遍历方式遍历所有节点。
- `inOrderTraverse` 通过中序遍历方式遍历所有节点。
- `postOrderTraverse` 通过后序遍历方式遍历所有节点。
- `min` 返回树中最小的值/键。
- `max` 返回树中最大的值/键。
- `remove(key)` 从树中移除某个键的节点。

### 封装

首先创建二叉搜索树 BinarySearchTree，并添加必要属性，再进行其他方法的实现。

```js
class BinarySearchTree {
  constructor () {
    this.root = null // 根节点
  }
}
```

对于BinarySearchTree来说，只需要保存根结点即可，因为其他结点都可以通过根结点找到。

#### 插入节点

```js
// 向树中插入一个新的键
insert (key) {
  const newNode = new Node(key)
  if (this.root === null) { // 插入根节点
    this.root = newNode
  } else { // 插入非根节点
    this._insertNode(this.root, newNode)
  }
}
```

分析：

- 首先，根据传入的key，创建对应的Node
- 然后，向树中插入数据需要分成两种情况：
  - 第一次插入，直接修改根结点即可。
  - 其它插入，需要进行相关的比较决定插入的位置，然后插入节点。

非根节点插入方法，如下：

```js
/**
  * 插入非根节点到树结构中
  * @param {*} node 与插入节点比较的树节点
  * @param {*} newNode 插入节点
  */
_insertNode (node, newNode) {
  if (newNode.key < node.key) { // 准备向左子树插入节点 插入节点key小于树节点key
    if (node.left === null) {
      // 树节点左子树上没有节点
      node.left = newNode
    } else {
      // 树节点左子树上已有节点 递归
      this._insertNode(node.left, newNode)
    }
  } else { // 准备向右子树插入节点 插入节点key大于等于树节点key
    if (node.right === null) {
      // 树节点右子树上没有节点
      node.right = newNode
    } else {
      // 树节点右子树上已有节点 递归
      this._insertNode(node.right, newNode)
    }
  }
}
```

分析：

* 根据比较传入的两个节点，通过递归一直查找新节点适合插入的位置，直到成功插入新节点为止。
* 当插入节点`newNode.key`小于树节点`node.key`，向左查找:
  - 情况 1：当 node 无左子节点时，直接插入；
  - 情况 2：当 node 有左子节点时，递归调用 `_insertNode()`继续向下查找合适的插入位置；
* 当插入节点`newNode.key`大于等于`node.key`，向右查找，与向左查找类似：
  - 情况 1：当 node 无右子节点时，直接插入；
  - 情况 2：当 node 有右子节点时，递归调用 `_insertNode()`继续向下查找合适的插入位置；

测试：

```js
const bst = new BinarySearchTree()

// insert
bst.insert(11)
bst.insert(7)
bst.insert(15)
bst.insert(5)
bst.insert(3)
bst.insert(9)
bst.insert(8)
bst.insert(10)
bst.insert(13)
bst.insert(12)
bst.insert(14)
bst.insert(20)
bst.insert(18)
bst.insert(25)
console.log(bst)
```

插入结果如下图：

![二叉搜索树06](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树06.png)

此时再新插入一个节点6

```js
bst.insert(6)
```

![二叉搜索树07](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树07.png)

#### 二叉树遍历

这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。

遍历一棵树是指访问树的每个结点，可以对树的每个节点进行一些操作，二叉树的遍历常见的有三种方式：

* 先序遍历
* 中序遍历
* 后续遍历

还有层序遍历，使用较少，可以使用队列来完成。

#### 先序遍历

遍历过程为：

1. 访问根结点
2. 先序遍历其左子树
3. 先序遍历其右子树

![二叉搜索树08](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树08.png)

为什么叫先序？

树结构在先拿到根节点之后，就直接先去调用`handler`处理，然后再去遍历根节点的左子树直到叶子节点，然后再遍历右子树。每一个节点的子树都遵循这个规则，每次都是先`handler`，再优先遍历左子树，最后遍历右子树，`handler`在前面，所以叫先序。

另一种理解是，因为最先处理A，然后处理A的左子树，再处理A的右子树，叫先序。

第一种理解更为恰当，第二种理解更好记忆。

```js
// 先序遍历
preOrderTraversal (handler) {
  this._preOrderTraversalNode(this.root, handler)
}

_preOrderTraversalNode (node, handler) {
  if (node !== null) {
    // 回调 handler
    handler(node.key)
    // 先遍历所有的左子树
    this._preOrderTraversalNode(node.left, handler)
    // 后遍历所有的右子树
    this._preOrderTraversalNode(node.right, handler)
  }
}
```

测试：

```js
// 先序遍历
let preString = ""
bst.preOrderTraversal((key) => {
  preString += `${key} `
})
console.log(preString) // 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25
```

分析：遍历树使用递归，每个节点都可能有自己的子节点，在遍历过程中，在经过节点时，会先将节点打印出来。

递归遍历从根节点开始，先遍历其左子树，再遍历其右子树。当遍历到叶子节点时，由于叶子节点不会再有子节点，那么就会结束当前节点的执行，从递归函数栈中弹出当前函数，回溯到上一层节点，再继续上层节点函数的执行。

上面测试用例的输出在遍历过程中，如下图所示，首先输出11，再先递归其左子树，输出7、5、3，然后3没有子节点，那么递归就回溯到5，再遍历5的右子树输出6，6没有子节点，递归再次回溯到5且已经执行结束，就再回溯到7，再遍历7的右子树，输出9...... 依次类推，完成整棵树的遍历。

![二叉搜索树09](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树09.png)

#### 中序遍历

遍历过程为:

1. 中序遍历其左子树
2. 访问根结点
3. 中序遍历其右子树

![二叉搜索树10](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树10.png)

为什么叫中序？

逻辑与先序相似。

树结构在拿到根节点后，优先遍历左子树直到叶子节点，然后调用`handler`处理，再遍历右子树。每一个节点的子树都遵循这个规则，每次都是先遍历左子树，再`handler`，然后再遍历右子树，handler在中间，所以叫中序。

```js
// 中序遍历
inOrderTraversal (handler) {
  this._inOrderTraversalNode(this.root, handler)
}

_inOrderTraversalNode (node, handler) {
  if (node !== null) {
    // 首先遍历所有的左子树
    this._inOrderTraversalNode(node.left, handler)
    // 然后回调 handler
    handler(node.key)
    // 最后遍历所有的右子树
    this._inOrderTraversalNode(node.right, handler)
  }
}
```

分析：先遍历左子树节点，输出，再遍历右子树节点。

上面测试用例的输出在遍历过程中，如下图所示，首先输出11，再先递归其左子树，直到叶子节点3，然后3没有子节点，输出2，那么递归就回溯到5，输出5，再遍历5的右子树，6没有子节点，输出6，递归再次回溯到5且已经执行结束，就再回溯到7，输出7，再遍历7的右子树，直到8，输出8...... 依次类推，完成整棵树的遍历。

![二叉搜索树11](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树11.png)

#### 后序遍历

遍历过程为：

1. 后序遍历其左子树
2. 后序遍历其右子树
3. 访问根结点

![二叉搜索树12](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树12.png)

为什么叫后序？

逻辑同先序相似。

```js
// 后序遍历
postOrderTraversal (handler) {
  this._postOrderTraversalNode(this.root, handler)
}
_postOrderTraversalNode (node, handler) {
  if (node !== null) {
    // 首先遍历所有的左子树
    this._postOrderTraversalNode(node.left, handler)
    // 然后遍历所有的右子树
    this._postOrderTraversalNode(node.right, handler)
    // 最后回调 handler
    handler(node.key)
  }
}
```

测试

```js
// 后序遍历
let postString = ""
bst.postOrderTraversal((key) => {
  postString += `${key} `
})
console.log(postString) // 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11
```

先遍历左子树上的节点，再遍历右子树上的节点，最后遍历根节点。

![二叉搜索树13](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树13.png)

总结：可以以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。

#### 最大值&最小值

在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值。

![二叉搜索树14](https://cdn.jsdelivr.net/gh/ccbeango/blogImages@master/JS数据结构与算法/二叉搜索树14.png)

```js
// 最小值
min () {
  let node = this.root
  // 循环找到最左子节点
  while (node.left !== null) {
    node = node.left
  }
  return node.key
}

// 最大值
max () {
  let node = this.root
  // 循环找到最右子节点
  while (node.right !== null) {
    node = node.right
  }
  return node.key
}
```

#### 搜索特定的值

查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的 key 值与之比较，若 `node.key < key` 则向左查找，若 `node.key > key` 就向右查找，直到找到或查找到 null 为止。这里可以使用递归实现，也可以采用循环来实现。

递归实现

```js
// 搜索值
search (key) {
  return this._searchNode(this.root, key)
}
_searchNode (node, key) {
  if (node === null) {
    return false
  }

  if (node.key > key) { // 向左子树查找
    return this._searchNode(node.left, key)
  } else if (node.key < key) { // 向右子树查找
    return this._searchNode(node.right, key)
  } else { // 相等 说明找到了key
    return true
  }
}
```

循环实现

```js
// 搜索值 循环
search2 (key) {
  let node = this.root

  while (node !== null) {
    if (node.key > key) { // 向左子树查找
      node = node.left
    } else if (node.key < key) { // 向右子树查找
      node = node.right
    } else {
      return true
    }
  }

  return false
}
```

递归or循环： 

- 其实递归和循环之间可以相互转换
- 大多数情况下，递归调用可以简化代码，但是也会增加空间的复杂度。
- 循环空间复杂度较低，但是代码会相对复杂。
- 可以根据实际的情况自行选择，不需要套死必须使用某种方式

#### 删除节点

